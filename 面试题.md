#	面试题
#	数组常用的方法有哪些	map filter-->不改原数组
	push	pop这些方法会直接修改原数组
1.	for in 枚举对象的时候除了可以枚举自身属性之外还会枚举原型的属性
for(var i in obj2){
	console.log(i);
}
hasOwnProperty-->验证是否是自身的属性
2.	var a = 3;
var b = 2;
//不借助第三方变量来交换ab的值
a = a + b;
b = a - b;
a = a - b;
3.	数组去重
ES5数组去重
indexOf()-->含有返回值  否则返回-1
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr(arr){
	let result = [];
	arr.forEach(function(item,index){
		//判断数组中是否包含原数组中的元素
		if(result.indexOf(item) === -1){
			result.push(item);
		}
	})
	return result;
}
ES6数组去重
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr2(arr){
	let set = new Set(arr);
	let result = [];
	for(let item of set){
		result.push(item);
	}-->记住用for of的时候也可以用...运算符
	return result;
}
以上代码可以简化一行代码
let uniqArr = arr => {...new Set(arr)} 
console.log(uniqArr(arr));
-	**数组的常见应用**
	-	产生一个每个元素都比原来大10的数组
		-	const arr = [1,2,3,4,45,5]
			//map函数遍历实现操作
			arr.map((item,index)=>item+10)
	-	得到奇数的和	reduce是一个累加器
		-	arr.reduce((preTotal,item,index)=>{
			preTotal + (item%2 === 1 ? item : 0)
		},0)
	-	得到值大于8且下标是偶数的元素组成的数组	用filter来过滤条件
		-	arr.filter((item,index)==>{index%2===0 && item>8})
	-	找到一个值大于8且下标是偶数位的元素		find元素
		-	arr.find((item,index)=>{index%2===0 && item>8})
	-	找出一个值大于8且下标是偶数位的元素的下标	findIndex下标
		-	arr.findIndex((item,index)=>{item>8 && index%2===0})
	-	判断下标是偶数的元素是否都是奇数	every()每个元素都满足条件		才返回true
		-	arr.every((item,index)=>{(index%2===0 && item%2===1) || index%2===1})//奇数不做限制	直接为真
	-	判断是否有下标为偶数的元素值为奇数	some()一个满足就返回true
		-	arr.some((item,index)=>{(index%2===0 && item%2===1) || index%2===1})
##	自己定义数组方法
-	**map函数自己定义**
-	Array.prototype.map = function(callback){
	const arr = []
	//遍历当前数组每一个元素	调用callback得到一个结果数据	添加arr
	for(let index = 0;index < this.length;index++){
		const element = this[index]
		const result = callback(element,index)
		arr.push(result)
	}
	return arr
}
-	**reduce自己定义	得到累加结果**
-	Array.prototype.reduce = function(callback,initValue){
	//结果为初始值
	let total = initValue
	for(let index = 0;index < this.length;index++){
		const element = this[index];
		total = callback(total,element,index)
	}
	return total
}
4. 手机号的正则		邮箱的正则
5. 	定义检测数据类型的方法
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
6.	实现深拷贝	对象		数组
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
function clone(target){
	let result;//最终加工拷贝完的数据
	//判断拷贝的数据是对象	数组	基本数据类型
	let targetType = checkoutType(target);
	if(targetType === 'Array'){
		result = [];
	}else if(targetType === 'Object'){
		result = {};
	}else{
		return target;
	}
	for(let item in target){
		//item：对象(key)	数组(index)
		let value = target[item];
		if(checkoutType(value) === 'Object' || 'Array'){
			result[item] = clone(value);//返回值有东西来接应
		}else{
			result[item] = value;
		}}
	return result;}
7.	a.x = a = {n:2}
-->分解动作
-->操作属性的优先级高于对象本身的赋值
a.x = {n:2}
a = {n:2}
8.	var x =10;
function fn(){
	console.log(x);
}
function show(f){
	var x = 20;
	f()
}
show(fn);//10-->因为fn()和show()函数是平级的那么找变量x的时候就会找到全局的x
9.	var obj = {
	fn2: function(){
		console.log(fn2)//obj是对象	对象没有作用域	那么当前function作用域里面没有fn2	就去全局作用域找	全局没有就直接报错	当然fn2改为this.fn2就可以正常输出了
	}
}
10.	function A(){}
	A.prototype.n = 1
	var b = new A()//这里b已经声明定义好了	那么__proto__的指向也就确定了	那么b.m就是undefined了	虽然后面A的prototype变了但是b的__proto__还是没有变化	A只是一个函数	不是一个对象
	A.prototype = {
		n:2,
		m:3
	}
	var c = new A()
	console.log(b.n,b.m,c.n,c.m)//1 undefined 2 3
11.	函数防抖		函数节流
-	事件频发触发造成的问题	
	-	onresize	mousemove等	触发频率高	造成浏览器性能问题
	-	后台发请求	频繁触发	对服务器造成压力
-	如何限制事件处理函数频繁调用
	-	函数节流
	-	函数防抖
-	函数防抖debounce	用定时器来实现	
	-	延迟要执行的内容	若是延迟时间内	再次触发	重新计时	防止服务器压力过大	百度牛逼没有做防抖	是专业的搜索引擎
-	let id;
	inputNode.addEventListener('keyup',function(){
		let value = inputNode.value;
		if(id)
		clearTimeout(id);
		id = setTimeout(()=>{
			sendAjax(value);
		},200)//目前防抖好的就是200 300
	})
12. 函数节流	throttle		lodash里面的函数_.throttle有可能最后一次会自动调用	可以设置参数最后一次默认不调用	第一次点击立即调用
	-	设定一个特定的时间	让函数在特定时间只执行一次	不会频繁执行
		-	定时器  标识来实现
		let conLog = true;
		document.body.onscroll = function(){
			if(conLog)
			console.log(1);
			conLog = false;
			setTimeout(()=>{
				conLog = true;
			},2000)
		}
	-	事件回调函数的this是发生事件的标签(event)
-	自己写的节流函数的工具函数	指定的时间周期	到点触发事件
	-	 function throttle(callback,delay){
        let pre = 0;//第一次直接调用执行
        return function(event){
            const currentTime = Date.now()
            if(currentTime - pre > delay){
                //时间到了一定的周期就会执行回调函数
                callback(this,event)
                //一个时间点的结束  是另一个时间点的开始
                pre = currentTime
            }
        }
    }
-	自己写的函数防抖	大于延迟时间	多次操作转化为了一次操作 触发防抖
	-	// 函数防抖     多次操作合并为一次操作
    function debounce(callback,delay){
        return function (event){
            //回调函数设置了一个定时器属性  用定时器属性就清除定时器
            if(callback.hasOwnProperty('timeoutId')){
                clearTimeout(callback.timeoutId)
            }
            //函数防抖用到了定时器  setTimeout
            //这个时候callback有了timeoutId的属性   只是会延迟时间执行  那么就实现了多次操作简化为了一次操作
            callback.timeoutId = setTimeout(()=>{
                callback.call(this,event)
                delete callback.timeoutId
            },delay)


        }
    }
-	函数防抖就是延迟大于延迟时间触发	函数节流就是指定时间周期触发
###	函数节流(throttle)场景
-	函数执行一次之后	只有大于执行周期的时候 才会执行第二次	适合多次事件按时间做平均分配触发
-	窗口调整(resize)
-	页面滚动(scroll)
-	DOM元素的拖拽功能实现(mousemove)
-	抢购点击(click)
###	函数防抖场景
-	多次连续快速事件		只做一次相应处理
-	输入框实时搜索联想(keyup/input)

#	补充
-	var定义的变量没有块级作用域
-	创建作用域	有着变量	函数	this指针
-	obj是对象	对象没有作用域
-	使用闭包完了之后记得清除	设置为null
-	把建立空间的声明成为“定义”，把不需要建立存储空间的成为“声明”
-	在预解析时，变量只会声明，而函数既会声明也会定义
-	var fn = 10;                                       
	function fn() {                                    
    console.log('hello world');                               
	}                                                  
	fn();Js引擎预解析，发现fn变量声明
	Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字
	**Js引擎预解析将fn和函数体联系在一起**
	执行第一句代码，fn定义为10
	Js引擎已经对fn和函数体联系，不再执行fn联系操作
	执行fn()，因为fn是变量不是函数，所以抛出访问异常
-	在代码块中使用let定义的变量均为局部变量，let定义之前会发生暂时性死区，如果在let定义之前访问了let定义的变量，那么会发生访问错误
-	一个名字不可既代表函数又代表变量
-	new Person().getAge()//实例.getAge()
-	存放在变量中的函数不需要函数名。他们总是使用变量名调用。
#	js引擎是单线程运行的  那么定时器是为什么
##	阻塞渲染
1.	关于css阻塞		link引入的css会阻塞	因为css解析器是同步的
2.	style标签的样式：
-	得到ip地址	
-	cmd	-->ping www.baidu.com
13.	从用户输入url按下回车	期间经历了什么？
-	DNS解析		拿着字典的大爷(优先走缓存)
	-	拿着一个对应关系的服务器------域名------IP地址
	-	找浏览器DNS缓存解析域名
	-	找本机DNS缓存
	-	找路由器DNS缓存
	-	找运营商DNS缓存(80%DNS查询.到这一步结束)
	-	递归查询(查全球13台根DNS服务器)
-	进行TCP(协议)连接	三次握手(根据上一步请求回来的ip地址	去联系服务器)
	-	第一次握手	由浏览器发给服务器	你能“听见”吗？
	-	第二次握手	由服务器发个浏览器	能听见	你说吧
	-	第三次握手	由浏览器发个服务器	ok 我来说话
-	发送请求(请求报文)
-	得到响应(响应报文)
-	浏览器开始解析html
	-	预解析	将所有外部资源	发请求出去
	-	解析html	生成DOM树
	-	解析CSS		生成CSS树
	-	合并为一个render树
	-	js是否操作了DOM或样式
-	断开TCP连接		四次挥手
	-	第一次挥手	浏览器给服务器	东西接受完了	断开
	-	第二次挥手	服务器发给浏览器	还要东西没接收	等一会	我要验证数据的完整性	好了告诉你
	-	第三次挥手	服务器发给浏览器	接收完了	断开
	-	第四次挥手	浏览器发给服务器	好的	断开
14.	为什么握手要三次	挥手要四次
-	挥手之前 没进行数据的传输	确保握手就可以了
-	挥手之前	正在进行数据的传输	为了确保数据的完整性	必须多经历一次验证
15.	jsonp解决跨域	jsonp不是一种技术	而是智慧的结晶
-	原生jsonp的步骤
	-	提前定义好一个等待被调用的函数
	-	创建一个script节点	createElement
	-	为节点指定src地址	.src
	-	将节点插入页面	appendChild
	-	这些步骤jQuery库可以帮忙做		用一个键值对				dataType:'jsonp'
-	jsonp只适用于get请求
-	js里面的代码
-	let arr = [1,3,5,7,9]
	console.log(`${JSON.stringify(arr)}`)//[1,3,5,7,9]
-	利用script标签发请求不受同源策略的限制	所以不会产生跨域问题
-	套路	动态构建script节点	利用节点的src属性	发出get请求	从而绕开ajax引擎
-	弊端：
	-	只能解决get请求的跨域问题	
	-	后端必须配合前端
	app.get('/test',function(req,res){
		let {callback} = req.query
		let personArr = [{name:'peiqi',age:12},{name:'suxi',age:14}]
		res.send(`$(callback}($(JSON.stringify(personArr)})`)
	})
-	使用jsonp的精简版
-	$.getJSON('http://../test?callback=?',{name:'zhangsan',		age:12},function(data){console.log(data)})
16.	手写Promise
-	lib就是库的意思
-	自定义Promise模块
-	ES5来定义模块
-	(function (window) {
    const PENDING = 'pending'
    const RESOLVED = 'resolved'
    const REJECTED = 'rejected'
    //promise构造函数
    function Promise(excutor) {
        //代表Promise的实例对象
        const self = this
        //初始值是pending	未确定的
        this.status = PENDING
        //用来存储结果数据的属性	初始值是undefined
        this.data = undefined
        self.callbacks = []
        //调用excutor来启动异步任务
        //改变promise状态	改为成功	value
        function resolve(value) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = RESOLVED
            self.data = value
            //异步调用所有缓存的待执行的成功的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有成功的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onResolved(value)
                    })
                })

            }
        }
        //状态改为失败	reason
        function reject(reason) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = REJECTED
            self.data = reason
            //异步调用所有缓存的待执行的失败的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有失败的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onRejected(reason)
                    })
                })

            }
        }
        try {
            excutor(resolve, reject)
        } catch (error) {
            //执行器执行出错	promise变为失败
            reject(error)
        }


    }
    //指定成功/失败回调函数的方法
    //返回一个新的promise对象
    Promise.prototype.then = function (onResolved, onRejected) {
        const self = this
        //reason向下传递
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        //value向下传递
        onResolved = typeof onResolved === 'function' ? onResolved :  value => value
        return new Promise((resolve, reject) => {
            function handle(callback) {
                try {
                    const result = callback(self.data)
                    if (result instanceof Promise) {
                        result.then(
                            value => resolve(value),
                            reason => reject(reason)
                        )//简写result.then(resolve,reject)
                    } else {
                        resolve(result)
                    }
                }
                catch (error) {
                    reject(error)
                }
            }
            if (self.status === RESOLVED) {
                setTimeout(() => {
                    handle(onResolved)
                })

            } else if (self.status === REJECTED) {
                setTimeout(() => {
                    handle(onRejected)
                })
            } else {
                self.callbacks.push({
                    onResolved(value) {
                        handle(onResolved)
                    },
                    onRejected(reason) {
                        handle(onRejected)
                    }
                })
            }
        })
    }
    //指定失败回调函数的方法
    //catch是then 的语法糖
    Promise.prototype.catch = function (onRejected) {
        return this.then(undefined,onRejected)
    }
    //用来产生一个指定value的成功的promise
    Promise.resolve = function (value) {
        return new Promise((resolve,reject)=>{
            if(value instanceof Promise){
                //value是一个promise    结果由value决定
                value.then(resolve,reject)
            }else{
                resolve(value)
            }
        })
    }
    //用来产生一个指定reason的失败的promise
    Promise.reject = function (reason) {
        return new Promise((resolve,reject)=>{
            reject(reason)
        })
    }
    //返回一个promise	只有当数组中的所有promise都成功才成功	否则失败
    Promise.all = function (promises) {
    }
    //返回一个promise	由速度最快的完成的promise来决定
    Promise.resolve = function (promises) {
    }
    window.Promise = Promise
})(window)
17.	宏队列和微队列
setTimeout(() => {
	console.log("0")
},0)
new Promise((resolve,reject) => {
	console.log("1")
	resolve()
}).then(() => {
	console.log("2")//.then放进队列里面去
	new Promise((resolve,reject) => {
		console.log("3")
		resolve()
	}).then(() => {
		console.log("4")
	}).then(() => {
		console.log("5")
	})
}).then(() => {
		console.log("6")
	})
	new Promise((resolve,reject) => {
		console.log("7")
		resolve()
	}).then(() => {
		console.log("8")
	})
	宏队列 0
	微队列	2	8	4
	输出	1	7	2	3	8	4	5	6	0
18.	axios发ajax请求
-	function testGet() {
	axios({
		method:'GET',//默认是get方法
		url:'http://..',
		params:{
			id:2//指定get的query参数,params是对象
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
-	function testPost() {
	axios({
		method:'POST',//默认是get方法
		url:'http://..',
		//post请求用的是data来指定请求体参数,data是对象
		data:{
			id:2,
			title:'atguigu',
			author:'ddd'
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
19.	promise和xhr发送ajax请求
-	function axios({
	url,
	method='GET',
	params={},
	data = {}
})	
{
	//准备query参数	{a:1,b:2}==>a=1&b=2
	let queryStr = ''
	Object.keys(params).forEach(key => {
		queryStr += `${key}=${params[key]}&`
	})
	if(queryStr){//只有指定了params才做
	queryStr = queryStr.substring(0,queryStr.length-1)
	url += '?' + queryStr}
	return new Promise((resolve,reject) => {
		//创建xhr对象
		const xhr = new XMLHttpRequest()
		//绑定监听
		xhr.onreadystatechange = () => {
			//请求成功的时候调用resolve
			//请求失败的时候调用reject
			const {readyState,status,statusText} = xhr
			if(readysState!==4)return 
			if(status >= 200 && status < 300){
				//封装一个代表响应的对象
				const response =　{
					data: JSON.parse(xhr.response),
					status,
					statusText
				}
				//将promise对象改为成功
				resolve(response)
			}else{
				reject(new Error('request error status is '+  status))
			}
		}
		//初始化
		xhr.open(method,url,true)
		//发送请求
		if(method==='POST' || method === 'PUT'){
			xhr.setRequestHeader('Content-Type','application/json;charset=utf-8')
			xhr.send(JSON.stringify(data))
		}else{	
			xhr.send()
		}
	})
}	
20.	axios请求拦截器
	axios('/posts..').then()
-	let cancel//保存取消请求的函数
	//请求拦截器
	axios.interceptors.request.use(config => {
		if(cancel){
			cancel('强制取消')
		}
		config.cancelToken = new axios.CancelToken((c) => {
			cancel = c
		})
		return config//必须返回config
	})
	//添加响应拦截器
	axios.interceptors.response.use{
		response => {
			cancel = null
			return response
		},
		error => {
			if(axios.isCancel(error)){
			console.log('1111 取消请求',error.message)
		}else{
			cancel = null
			alert('请求错误:'+error.message)
		}
		return new Promise(() => {})
		}
	}
	function get1(){
		
	axios('/get..').then(
		response => {
		console.log('1111 onResolved',resposne.data)},
		error => {	
		console.log('1111 请求出错',error.message)
	}
	)
	}
	function cancelReq(){
		if(cancel)
		cancle('强制取消')
	}
21.	axios的instance封装
-	const instance = axios.create({
	baseURL:'http://localhost:3000'
})	
	//添加请求拦截器
	instance.interceptors.request.use((config) => {
		NProgress.start()
//对data参数数据进行处理	转换为urlencoded格式
if(config.data instanceof Object){
	config.data = Qs.stringify(config.data)
}
		return config
	})

	//添加响应拦截器
	instance.interceptors.response.use(
		response => {

			return response
		},
		error => {
			throw error
		}
	)
-	function getPosts(){
	instance.get('/post').then(
		response => {
			const result = response.data
			console.log(result)
		},
		error => {
			alert(error.message)
		}
	)
}
	function addPost(){
		instance.get('/post',{title:'newTitle',author:'newAuthor'}).then(
		response => {
			const result = response.data
			console.log(result)
		},
		error => {
			alert(error.message)
		}
	)
	}
22.	webpack练习
-	文件目录
-	src
	-	css
		-	index.css
		-	iconfont.css
	-	images
	-	font//存字体的
	-	js
		-	index.js
		-	module1.js
		-	module2.js
		-	module3.js
	-	json
		-	test.json
	-	index.html//不引入任何的css和js文件
	-	package.json
	-	webpack.config.js//是任务清单
-	dist//webpack执行之后的生成的文件


-	**module1.js内容**
-	/*
	ES6模块化
	-	暴露	分别暴露	统一暴露	默认暴露
	-	引入	import{}from'./xx/xx' 	import a from './xxx/xxx'
*/
-	export function sum(a,b){
	return a+b
}


-	**module2.js内容**
-	/*
	统一暴露
*/
-	function sub(a,b){
	return a-b
}
	export {sub}


-	**module3.js**
-	/*
	默认暴露
	暴露计算乘除法的两个函数
*/
-	export default{
	 mul(a,b){
	return a*b
},
	 div(a,b){
		return a/b
	}
}


-	**index.js**
-	/*
	汇总js模块
	该文件不同于学习模块化时	汇总js的文件
	该index.js是webpack的**入口文件**
	该文件可以汇总js css 图片	音频	视频	json
*/
-	import '@babel/polyfill'//全部新语法都转换	这时候要按需引入
	import {sum} from './module1'
	import {sub} from './module2'
	import module3 from './module3'
	import a from '../json/test.json'
	//在入口文件中引入样式	不用变量	
	import '../css/index.less'
	import '../css/iconfont.less'
	console.log(sum(1,2))
	console.log(sub(3,4))
	console.log(module3.mul(1,2))
	console.log(module3.div(1,2))
	console.log(a,typeof a)
	let myPromise = new Promise((resolve,reject)=>{
		resolve('haha')
	})
	myPromise.then((data)=>{
		console.log(data)
	})


-	**text.json**
-	/*

*/
-	{
	"name":"peiqi"
	"age":18
}


-	**webpack.config.js配置文件**
-	/**/
-	const {resolve} = require('path')
	const HtmlWebpackPlugin = require('html-webpack-plugin')
	module.exports = {
	entry:['./src/js/index.js','./src/index.html']//入口
	output: {
		path:resolve(__dirname,'../dist'),//输出路径
		filename:'./js/index.js'//输出文件名
		publicPath:'/'//所有资源在引入是的公共路径
	},//输出
	mode:'production',//配置工作模式
	module:{
		rules:[
			//解析less
		{//rules是一个数组	数组中的每一个对象都是一个loader
			test:/\.less$/,//匹配所有的less文件
			use:[
				//'style-loader',//用于在html文档中创建一个style标签	将样式塞进去
				MiniCssExtractPlugin.loader,
				'css-loader',//将less编译后的css转化为CommonJs的一个模块
				'less-loader'//less编译为css	但不生产单独的css文件		在内存里面
				],
		},
		//js语法检查
		{
			test:/\.js$/,//匹配所有的js文件
			exclude:/node_modules/,//除了node_modules文件夹
			enforce:"pre",//提前加载使用
			use:['eslint-loader']
		},
		//js语法转换方法一
		{
			test:/\.js$/,
			exclude:/node_modules/,
			use:{
				loader:"babel-loader",
				options:{
					presets:['@babel/preset-env']
				}
			}
		},
		//js语法转换方法二
		{
			test:/\.js$/,
			exclude:/node_modules/,
			use:{
				loader:"babel-loader",
				options:{
					presets:[['@babel/preset-env',{
						useBuiltIns:'usage',
						corejs:{version:3},
						targets:{
							"chrome":"58",
							"ie":"9"
						}
					}]],
					cacheDirectory:true//开启babel缓存	加快速度
				}
			}
		},
		//使用url-loader处理样式文件中的图片
		{
			test:/\.(png|jpg|gif)$/i,
			use:[
				{
					loader:'url-loader',
					options:{
						limit:8192,//图片会base64处理
						outputPath:'images',//文件输出路径
						publicPath:'images/',
						name:'[hash:5].[ext]'//修改文件名称
					}
				}
			]
		},
		//使用file-loader处理样式文件里的图片
		{
			test:/\.(png|jpg|gif)$/i,
			use:[
				{
					loader:'file-loader',
					options:{
						publicPath:'../dist/images',//决定图片的url路径
						outputPath:'images',//文件输出路径
						name:'[hash:5].[ext]'//修改文件名称
					}
				}
			]
		},
		//解析html里面的标签
		{
			test:'/\.(html)$/',
			use:{
				loader:'html-loader'
			}
		},
		//使用file-loader处理其他资源
		{
			test:/\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/,
		
					loader:'file-loader',
					options:{
						
						outputPath:'media',//文件输出路径
						name:'[hash:5].[ext]'//修改文件名称
					}
				
			
		},
		]
	},//用来解析less文件
	//配置插件
	plugins:[new HtmlWebpackPlugin({
		template:'./src/index.html',
		minify:{//用于压缩的
			
		}
	}),
	new MiniCssExtractPlugin(),//前面没有引入
	new CleanWebpackPlugin() 
	],
	devServer:{//自动的服务器
		open:true,//自动打开浏览器 
		compress:true,//启动gzip压缩	加快浏览器打开速度
		port:3000,//端口号
		hot:true
	},
	devtool:'cheap-module-eval-source-map'
}	


-	index.css文件设置样式


-	package.json文件里面可以设置短命令
-	"script":{
	"start":"webpack-dev-server --open"
}//可以用npm run start 或者	npm start	只有start可以省略

23.	虚拟DOM的key的作用
-	key是虚拟DOM对象的表示	在更新显示的key有重要的作用
-	当状态数据发生变化的时候	React会生成新的虚拟DOM 随后React将之前的旧虚拟DOM	与新的虚拟DOM进行diff比较	
	-	旧的虚拟DOM中找到了相同了key
		-	若虚拟DOM没变	直接使用原来的真实DOM 	不去刷新页面的真实DOM
		-	若虚拟DOM变了	先更新虚拟DOM	随后刷新页面的真实DOM
	-	旧的虚拟DOM没找到相同的key
		-	根据item数据创建新的虚拟DOM	随后渲染真实DOM到页面
-	index作为key的问题
	-	产生没有必要的真实DOM更新
	-	如果DOM界面还有输入类DOM	产生错误的真实DOM更新	界面有问题
-	使用数据的唯一标识作为key
24.	组件之间通信
-	props传递
	-	去点只能一层一层传递	兄弟组件之间传递要借助父组件
	-	一般数据是父组件向子组件
	-	函数数据是子组件向父组件
-	消息订阅发布机制
	-	实现库是pubsub-js
-	redux
	-	集中式管理多个组件共享的状态	
25.	mouse事件	常常用到的是enter leave		不常用到over  out
-	例如一个父子组件	鼠标移动接近父组件的时候触发over	接近父组件里面的子组件的时候触发out	离开子组件的时候再次触发over
26.	组件里面的data配置为什么只能是函数	而不是对象
-	是为了保证对各实例对象的data对象不是共用的	而是各自自己的data对象
27.	call  apply  bind 函数的认识
	function(a,b){
	this.xxx = 3;
	console.log(a,b,this)//this是window
	return a+b//返回值
}
-	console.log(xxx)//xxx是window是属性	可以直接输出
-	全局变量	函数	分别是window的属性	方法
-	所有函数都可以调用call()函数
-	call apply的作用就是调用函数
-	const obj = {m:0}
-	fn.call(obj,1,2)//call函数的变量输入是分别传入的	相当于执行了	obj.fn(1,2)
-	fn.apply(obj,[1,2])//apply函数的参数变量是数组传入的
-	fn.call(undefinded)//undefined  null  就是window
-	fn.bind(obj)(1,2)//bind返回一个新的函数	那么后面可以再加上括号就是正确的	调用新的函数	这可以通过新的函数去执行老的函数	fn调用bind函数	那么fn就变成了老的函数	fn.bind(obj)是新的函数		fn(1,2)再次自身调用是没有作用的	新函数的调用相当于老函数的执行	且this为bind 指定的第一参数的值
-	fn.bind(obj,5)//bind函数执行的时候可以加上参数	就是说可以指定将来将要调用函数的参数
28.	自定义实现 call   apply  bind函数
-	call函数的实现
	-	Function.prototype.call = function(obj,...args){
		<!-- console.log('call()') -->
			//this(...args)//执行了函数		记得传入参数
			//处理obj是undefined  null 的情况
			if(obj===undefined || obj===null){
				obj = window
			}
			//给obj添加一个方法	temFn:this
			obj.tempFn = this
			//调用obj的temFn方法		传入args参数 	
			const result = obj.temFn(...args)
			//删除obj的temFn方法
			delete obj.temFn
			//返回方法的返回值
			return result
		}
-	apply函数的实现		和call函数是一样的
	-	Function.prototype.apply = function(obj,args){
		console.log('call()')}
-	bind函数的实现
	-	Function.prototype.bind = function(obj,...args){
		//返回一个新函数
			return (...args2) =>{
				//调用原来的函数	且指定this为obj	参数列表为args		和   args2组成
				return this.call(obj,...args,...args2)
			}
		}
-	一个函数  方法的this是看具体什么东西调用	是window  或是某个实例化对象
29.	数组去重	
-	Array.from(new Set(array))	//Set函数就执行了数组去重的操作
-	[...new Set(array)]	//也实现了数组去重操作	
30.	数组合并	切片
-	 concat()数组合并	n个数组合并为一个新数组	原始数组不会改变	[[a]]	concat()函数只可以拆掉一层数组	也就是说做连接的时候[[a]]变为了[a]
	-	var new_arr = concat(arr,value1[,value2[,value3]])
-	slice()数组切片	返回一个有begin和end决定的原数组的浅拷贝	原数组不会被改变	例如 arr=[1,2,3,4,6,7,8] slice(arr,1,3)其中1代表起始点下标起始点是包含在结果里面的	3代表结束点下标结束点是不包含在结果里面的	最后的结果是	[2,3]	
	-	var new_arr = slice(array,[begin[,end]])
-	判断是不是数组Array.isArray(value)
31.	数组扁平化	
-	取出嵌套(多维)中的所有元素放到一个新数组里面去
-	[1,[2,3[4,5]]]---->[1,2,3,4,5]
-	实现的方法
	-	方法一   递归  +	reduce()+concat()
		-	export function flatten(array){
			return reduce((array,(pre,item)=>{
				pre.push(!Array.isArray(item)?item:(flatten(item)))//递归层层拆卸	...负责拆分操作
				return pre
			},[])
		}//实际运行的...运算符会出错
	-	方法二	 ... + some() + concat()
		-	export function flatten1(array){
			if(!Array.isArray(item)){
					pre.push(item)
				}else{//contact()递归连接数组元素
				pre = concat(pre,flatten1(item))
				}
				return pre
		},[])}
	-	方法三
		-	function flatten2(array){
			arr = [].concat(...array)//直接就去除了一层数组的嵌套
			while(arr.some(item=>Array.isArray(item))){
				arr = [].concat(...arr)
			}
			return arr
		}
32.	数组的取真	分块
-	compact(array):返回数组中所有真值元素组成的新数组
	-	export default function compact(array){
	return array.filter(item => item)
	}
-	数组分块	chunk
	-	export function chunk(array,size=1){
		const bigArr = []
		let smallArr = []
		//如果是空数组	直接返回空数组
		if(array.length === 0){
			return bigArr
		}
		//处理size异常情况
		//size没有指定
		//if(size<1){size = 1}
		else if(size>array.length){size = array.length}
		array.forEach(item =>{
			//将小数组放到大数组里去	只能放一次
			if(smallArr.length === 0){
				bigArr.push(samllArr)
			}
			//将元素添加到小数组
			smallArr.push(item)
			//限制smallArr的最大长度是size
			if(smallArr.length === size){
				smallArr = []
			}
		})
		return bigArr
	}
33.	数组之间的差异部分	difference
-	difference(arr1,arr2)		得到arr1中arr2没有的数组
-	export function difference(arr1,arr2){
	//处理特殊情况
	if(arr1.length===0){
		return []
	}else if(arr2.length===0){
		return [...arr1]
	}
	//对数组进行过滤
	return filter(arr1,item => arr2.indexOf(item)===-1)
}
-	export function differences(arr1,...arrays){
	//处理特殊情况
	if(arr1.length===0){
		return []
	}else if(arrays.length===0){
		return [...arr1]
	}
	//对数组进行过滤
	return filter(arr1,item => {
		let result = true//假设当前元素在后面的所有数组都不存在
		arrays.forEach(array=>{
			const index = array.indexOf(item)
			if(index!==-1){
				result = false
				break//结束当前for循环	因为要求取得元素是不同的
			}
		})
		return result
	})
}
34.	合并数组	merge
-	export function mergeArray(array,...arrays){
	const result = [...array]//三点运算符就是遍历第一个数组的result
	arrays.forEach(itemArr =>{
		itemArr.forEach(item => {
			if(result.indexOf(item)===-1){
				result.push(item)
			}
		})
	})
	return result
}
35.	数组删除元素	pull(array,...values)	删除数组中元素和values相同的元素	原数组改变了	
-	export function pull(array,...values){
	const result = []
	array.forEach((item,index) => {
		if(values.indexOf(item)!==-1){
		//删除item
		array.splice(index,1)
		//将item添加到result数组	
		result.push(item)
		}
	})
	return result
}
36.	drop(array,count)	过滤掉array左边的count个元素
-	export function drop(array,count=1){
	if(array.length == 0){
		return []
	}
	if(count<1){
		count = 1
	}
	return array.filter((item,index) => index>=count)
}
37.	自定义new 工具函数
-	export function newInstance(Fn,...args){
	//创建一个空对象
	const obj = {}
	//调用Fn函数	且指定this是新创建对象
	const result = Fn.call(obj,...args)
	//如果Fn执行返回的是对象类型	最终结果就是这个对象
	if(result instanceof Object){
		return result
	}
	//让原型对象是空的object对象	且constructor属性为Fn
	//obj.__proto__ = {}
	//Fn函数生成	原型对象 构造函数就已经确定了	下面这句话不用创建{}	效率更高
	//将构造函数的显式原型属性赋值实例对象的隐式原型属性
	obj.__proto__ = Fn.prototype
	obj.__proto__.constructor = Fn
	//返回新建对象
	return obj
}
38.	自定义instanceof工具函数
-	export function myInstanceOf(obj,Type){
	//得到一个原型对象
	let  protoObj = obj.__proto__
	while (protoObj!==null){//存在原型对象
	//如果就是Type的原型对象	直接返回true
		if(protoObj===Type.prototype)
		{	
			return true
		}
		//取出下一个原型对象	并保存
		protoObj = protoObj.__proto__
	}
	//出了循环	说明类型不匹配
	return false
}
39.	对象合并	对象里面有同名属性	是合并	不是覆盖
-	export function mergeObject(...objs){
	const result = {}
	objs.forEach(obj=>{
		Object.keys(obj).forEach(key=>{
			const value = obj[key]
			//result里面没有key属性
			if(!result.hasOwnProperty(key)){
				result[key] = value
			}else{//result里面有key属性
			//对原值和value进行合并生成新的数组
			result[key] = concat([],result[key],value)
		}
		})
	})
	return result
}
40.	实现浅拷贝
-	export function clone1(target){
	if(target instanceof Array){
		//return [...target]
		//return target.slice()
		//return [].concat(target)
		//return Array.from(target)

	}else if(target !== null && typeof target === 'obj'){
		return {...target}
	}else{//如果不是数组或者对象	直接返回
		return target
	}
}
-	export function clone2(target){
	//被处理的目标是数组/对象
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		const cloneTarget = target instanceof Array? [] : {}
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = target[key]
			}
		}
		return target
	}else{
		return target
	}
 }
 41.	实现深拷贝
 -	大众乞丐版
	-	存在问题
	-	函数属性会丢失
	-	循环引用会出错
 -	export function deepClone1(target){
	 return JSON.parse(JSON.stringify(target))
 }
-	JSON数据存不了函数
-	面试基础版
-	解决了函数属性丢失		也就是方法丢失
-	export function deepClone2(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		const cloneTarget = target instanceof Array? [] : {}
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deepClone2(target[key])//对属性值进行递归处理
			}
		}
		return cloneTarget
	}else{
		return target
	}
 }
-	面试加强版
-	解决循环引用出错
-	解决思路
	-	同一个对象/数组只能被克隆一次
	-	创建克隆对象前：
		-	如果克隆对象已经存在	直接返回
	-	创建克隆对象后：
		-	将克隆产生的对象存起来
	-	缓存容器结构
		-	map	==>	key:target	value:cloneTarget	
-	export function deepClone3(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		//map里面存在对应的克隆对象	直接返回
		let cloneTarget = map.get(target)
		if(cloneTarget){//不对同一个对象进行多次clone
			return cloneTarget
		}
		const cloneTarget = target instanceof Array? [] : {}
		//保存到map容器
		map.set(target,cloneTarget)
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deepClone2(target[key],map)//对属性值进行递归处理
			}
		}
		return cloneTarget
	}else{
		return target
	}
 }
 -	面试最强版
 -	优化了数组的遍历	不用for in 而用forEach
 -	export function deeClone4(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		//map里面存在对应的克隆对象	直接返回
		let cloneTarget = map.get(target)
		if(cloneTarget){//不对同一个对象进行多次clone
			return cloneTarget
		}
		if(target instanceof Array){
			cloneTarget = []
			map.set(target,cloneTarget)
			target.forEach((item,index)=>{
				cloneTarget[index] = deeClone4(item,map)
			})
		}else{
			cloneTarget = {}
			map.set(target,cloneTarget)
			for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deeClone4(target[key],map)//对属性值进行递归处理
			}
		}
		}
		
		return cloneTarget
	}else{
		return target
	}
 }
42.	字符串倒序	回文	截取
-	字符串倒序
-	export function	reverseString(str){
	return str.split('').reverse().join('')
}
-	字符串回文
-	export function palidrome(str){
	return str === reverseSring(str)
}
-	字符串截取
-	export function truncate(str,num){
	return str.length > num ? str.substring(0,num) + '...' : str
}
43.	手写继承
-	寄生组合式继承
-	构造函数中用call借用父类型构造函数	得到父类型的属性
-	指定新的原型对象	得到父类型原型对象上面的属性方法
-	寄生处理:去除原型对象上多余的属性就要借用中间者(指路人)
-	function Person(name,age){
	this.name = name
	this.age = age
}
Person.prototype.sayName = function(){
	console.log('my name',this.name)
}
function Student(name,age,price){
	//借用父类型的函数
	//this打电话给person来借用函数	
	Person.call(this,name,age)//相当于this.Person(name,age)
	this.price = price
}
//Student的原型对象指向了Person的实例
Student.prototype = new Person()
//Student构造器出现问题	就重新指向构造器
Student.prototype.constructor = Student
//Student的prototype多了Person的多余的name age属性
-	解决方案是
	-	create是一个工具函数	用来解决要调用Person的方法会解决携带Person上面多余属性的问题
	-	function create(proto){
		function Fn(){}
		Fn.prototype = proto
		return new Fn()
	}
	-	Student的原型对象指向了Fn函数   Fn的原型对象指向了Person的原型对象		那么Student就可以沿着原型链找到Person里面具有的方法	想用的属性	用Student原型对象指向Fn函数的方法去除了Student原型对象直接指向Person原型对象而造成的携带多余参数的问题		相当于找了一个中间者解决多余携带	让中间者指定可以用的东西的方向	要用的时候直接沿着路径去拿要用的东西	而不是一股脑全部携带很多东西		是个很明智的做法
	-	Student.prototype = create(Person,prototype)
44.	数据结构和算法
-	数据结构
	-	狭义
		-	数据的存储方式
	-	广义
		-	数据存储和算法
-	常见的数据结构
	-	数组	栈	队列	链表	树	集合	图	哈希表	堆
	-	这些可以自己写写
-	数组在一块连续的内存里面	这种说法式不完全正确的
-	栈应用	
	-	十进制转换为二进制
-	pop从栈顶取出开始删除	同时返回删除的元素
-	es6实现了集合类型	new set()	里面的元素不可以重复
-	希尔排序	快速排序比较重要	
	-	理解希尔排序	先了解插入排序
	-	计算出一个增量数组(折半)
		-	递减	最后一个必须是1
		-	distance = Math.floor(length/2)
		-	以当前增量对数组进行分组	分成多个小数组	对每个小数组	进行插入排序	每个小数组排序是交替进行的
-	es6语法可以用到		直接交换数组值的大小
	-	[arr[j+1],arr[j]] = [arr[j],arr[j+1]]
-	Math.floor()向下取整
-	Math.ceil()向上取整
-	[] == ![]	返回的是true	右边的[]是true	加上!是false	false和空数组转换为数值之间的比较	0==0	所有返回true
-	NaN和其他任何数值比		返回都是false	
-	任何数组	对象装换位boolean值	都是true 装换位数字的时候	看情况	空的数组	对象就是0
-	不同类型比较会装换为 数值之间的比较