#	面试题
#	数组常用的方法有哪些	map filter-->不改原数组
	push	pop这些方法会直接修改原数组
1.	for in 枚举对象的时候除了可以枚举自身属性之外还会枚举原型的属性
for(var i in obj2){
	console.log(i);
}
hasOwnProperty-->验证是否是自身的属性
2.	var a = 3;
var b = 2;
//不借助第三方变量来交换ab的值
a = a + b;
b = a - b;
a = a - b;
3.	数组去重
ES5数组去重
indexOf()-->含有返回值  否则返回-1
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr(arr){
	let result = [];
	arr.forEach(function(item,index){
		//判断数组中是否包含原数组中的元素
		if(result.indexOf(item) === -1){
			result.push(item);
		}
	})
	return result;
}
ES6数组去重
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr2(arr){
	let set = new Set(arr);
	let result = [];
	for(let item of set){
		result.push(item);
	}-->记住用for of的时候也可以用...运算符
	return result;
}
以上代码可以简化一行代码
let uniqArr = arr => {...new Set(arr)} 
console.log(uniqArr(arr));
-	**数组的常见应用**
	-	产生一个每个元素都比原来大10的数组
		-	const arr = [1,2,3,4,45,5]
			//map函数遍历实现操作
			arr.map((item,index)=>item+10)
	-	得到奇数的和	reduce是一个累加器
		-	reduce() 对于空数组是不会执行回调函数的。
		-	arr.reduce((preTotal,item,index)=>{
			preTotal + (item%2 === 1 ? item : 0)
		},0)
	-	得到值大于8且下标是偶数的元素组成的数组	用filter来过滤条件
		-	arr.filter((item,index)==>{index%2===0 && item>8})
	-	找到一个值大于8且下标是偶数位的元素		find元素
		-	arr.find((item,index)=>{index%2===0 && item>8})
	-	找出一个值大于8且下标是偶数位的元素的下标	findIndex下标
		-	arr.findIndex((item,index)=>{item>8 && index%2===0})
	-	判断下标是偶数的元素是否都是奇数	every()每个元素都满足条件		才返回true
		-	arr.every((item,index)=>{(index%2===0 && item%2===1) || index%2===1})//奇数不做限制	直接为真
	-	判断是否有下标为偶数的元素值为奇数	some()一个满足就返回true
		-	arr.some((item,index)=>{(index%2===0 && item%2===1) || index%2===1})
##	自己定义数组方法
-	**map函数自己定义**
-	Array.prototype.map = function(callback){
	const arr = []
	//遍历当前数组每一个元素	调用callback得到一个结果数据	添加arr
	for(let index = 0;index < this.length;index++){
		const element = this[index]
		const result = callback(element,index)
		arr.push(result)
	}
	return arr
}
-	**reduce自己定义	得到累加结果**
-	Array.prototype.reduce = function(callback,initValue){
	//结果为初始值
	let total = initValue
	for(let index = 0;index < this.length;index++){
		const element = this[index];
		total = callback(total,element,index)
	}
	return total
}
4. 手机号的正则	
常见的手机号正则有 /^1[3456789]\d{9}$/、/^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/。
手机号这东西更新速度还是比较快的，所以不能限制的太死。我这里只作前三位号段的限制
邮箱的正则
^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$
5. 	定义检测数据类型的方法
function checkoutType(target){
	return Object.prototype.toString.call(target).slice(8,-1);
}
6.	实现深拷贝	对象		数组
function checkoutType(target){
	return Object.prototype.toString.call(target).slice(8,-1);
}
function clone(target){
	let result;//最终加工拷贝完的数据
	//判断拷贝的数据是对象	数组	基本数据类型
	let targetType = checkoutType(target);
	if(targetType === 'Array'){
		result = [];
	}else if(targetType === 'Object'){
		result = {};
	}else{
		return target;
	}
	for(let item in target){
		//item：对象(key)	数组(index)
		let value = target[item];
		if(checkoutType(value) === 'Object' || 'Array'){
			result[item] = clone(value);//返回值有东西来接应
		}else{
			result[item] = value;
		}}
	return result;}
7.	a.x = a = {n:2}
-->分解动作
-->操作属性的优先级高于对象本身的赋值
a.x = {n:2}
a = {n:2}
8.	var x =10;
function fn(){
	console.log(x);
}
function show(f){
	var x = 20;
	f()
}
show(fn);//10-->因为fn()和show()函数是平级的那么找变量x的时候就会找到全局的x
9.	var obj = {
	fn2: function(){
		console.log(fn2)//obj是对象	对象没有作用域	那么当前function作用域里面没有fn2	就去全局作用域找	全局没有就直接报错	当然fn2改为this.fn2就可以正常输出了
	}
}
10.	function A(){}
	A.prototype.n = 1
	var b = new A()//这里b已经声明定义好了	那么__proto__的指向也就确定了	那么b.m就是undefined了	虽然后面A的prototype变了但是b的__proto__还是没有变化	A只是一个函数	不是一个对象
	A.prototype = {
		n:2,
		m:3
	}
	var c = new A()
	console.log(b.n,b.m,c.n,c.m)//1 undefined 2 3
11.	函数防抖		函数节流
-	事件频发触发造成的问题	
	-	onresize	mousemove等	触发频率高	造成浏览器性能问题
	-	后台发请求	频繁触发	对服务器造成压力
-	如何限制事件处理函数频繁调用
	-	函数节流
	-	函数防抖
-	函数防抖debounce	用定时器来实现	
	-	延迟要执行的内容	若是延迟时间内	再次触发	重新计时	防止服务器压力过大	百度牛逼没有做防抖	是专业的搜索引擎
-	let id;
	inputNode.addEventListener('keyup',function(){
		let value = inputNode.value;
		if(id)
		clearTimeout(id);
		id = setTimeout(()=>{
			sendAjax(value);
		},200)//目前防抖好的就是200 300
	})
12. 函数节流	throttle		lodash里面的函数_.throttle有可能最后一次会自动调用	可以设置参数最后一次默认不调用	第一次点击立即调用
	-	设定一个特定的时间	让函数在特定时间只执行一次	不会频繁执行
		-	定时器  标识来实现
		let conLog = true;
		document.body.onscroll = function(){
			if(conLog)
			console.log(1);
			conLog = false;
			setTimeout(()=>{
				conLog = true;
			},2000)
		}
	-	事件回调函数的this是发生事件的标签(event)
-	自己写的节流函数的工具函数	指定的时间周期	到点触发事件
	-	 function throttle(callback,delay){
        let pre = 0;//第一次直接调用执行
        return function(event){
            const currentTime = Date.now()
            if(currentTime - pre > delay){
                //时间到了一定的周期就会执行回调函数
                callback(this,event)
                //一个时间点的结束  是另一个时间点的开始
                pre = currentTime
            }
        }
    }
-	自己写的函数防抖	大于延迟时间	多次操作转化为了一次操作 触发防抖
	-	// 函数防抖     多次操作合并为一次操作
    function debounce(callback,delay){
        return function (event){
            //回调函数设置了一个定时器属性  用定时器属性就清除定时器
            if(callback.hasOwnProperty('timeoutId')){
                clearTimeout(callback.timeoutId)
            }
            //函数防抖用到了定时器  setTimeout
            //这个时候callback有了timeoutId的属性   只是会延迟时间执行  那么就实现了多次操作简化为了一次操作
            callback.timeoutId = setTimeout(()=>{
                callback.call(this,event)
                delete callback.timeoutId
            },delay)


        }
    }
-	函数防抖就是延迟大于延迟时间触发	函数节流就是指定时间周期触发
###	函数节流(throttle)场景
-	函数执行一次之后	只有大于执行周期的时候 才会执行第二次	适合多次事件按时间做平均分配触发
-	窗口调整(resize)
-	页面滚动(scroll)
-	DOM元素的拖拽功能实现(mousemove)
-	抢购点击(click)
###	函数防抖场景
-	多次连续快速事件		只做一次相应处理
-	输入框实时搜索联想(keyup/input)

#	补充
-	var定义的变量没有块级作用域
-	创建作用域	有着变量	函数	this指针
-	obj是对象	对象没有作用域
-	使用闭包完了之后记得清除	设置为null
-	但是在函数执行完成时**外层函数没有东西被占用**，outer函数执行的栈内存就被销毁了，所以从确切来说这不算是一个闭包。
-	按照的我理解闭包得符合两个条件：
	1、函数执行完毕，函数内部创建的东西被函数外部引用了，形成不销毁的栈内存
	2、在代码中引用了自由变量
-	把建立空间的声明称为“定义”，把不需要建立存储空间的称为“声明”
-	在预解析时，变量只会声明，而函数既会声明也会定义
-	var fn = 10;                                       
	function fn() {                                    
    console.log('hello world');                               
	}                                                  
	fn();Js引擎预解析，发现fn变量声明
	Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字
	**Js引擎预解析将fn和函数体联系在一起**
	执行第一句代码，fn定义为10
	Js引擎已经对fn和函数体联系，不再执行fn联系操作
	执行fn()，因为fn是变量不是函数，所以抛出访问异常
-	在代码块中使用let定义的变量均为局部变量，let定义之前会发生暂时性死区，如果在let定义之前访问了let定义的变量，那么会发生访问错误
-	问函数和变量谁的优先级高？
答: 函数的优先级高。
-	函数和变量同名的时候
-	编译的时候函数优先级高于变量
-	执行的时候就是看代码的执行顺序问题		赋值问题	谁在后面就是谁
-	基于var或Function在全局上下文中声明的变量(全局变量)会映射到GO(全局对象window)上一份，作为他的属性，接下来一个修改，另一个也会修改。
-	在函数里面步骤：
先形参赋值
在变量提升
-	let声明的变量只在它所在的代码块有效。
-	var
-	const let function class
-	for (var i = 0; i <10; i++) {  
    setTimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列。
         console.log(i);        // 执行此代码时，同步代码for循环已经执行完成
      }, 0);
}
 // 输出结果
//10   共10个 
-	换成let就会依次输出 0 1 2 3...
-	for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
for (let i = 0; i < 3; i++) {
  let i = 'love';
  console.log(i);
}
// love
// love
// love
-	console.log(a) // undefined
		var a = 3;

		// 可以隐式的理解为
		var a;
		console.log(a);
		a = 3;
-	a();
		function a() {
			console.log('执行了')
		}

		// 隐式等于
		function a() {
			console.log('执行了')
		}
		a();
-	一个名字不可既代表函数又代表变量
-	new Person().getAge()//实例.getAge()
-	存放在变量中的函数不需要函数名。他们总是使用变量名调用。
#	js引擎是单线程运行的  那么定时器是为什么
##	阻塞渲染
1.	关于css阻塞		link引入的css会阻塞	因为css解析器是同步的
2.	style标签的样式：
-	得到ip地址	
-	cmd	-->ping www.baidu.com
13.	从用户输入url按下回车	期间经历了什么？
-	DNS解析		拿着字典的大爷(优先走缓存)
	-	拿着一个对应关系的服务器------域名------IP地址
	-	找浏览器DNS缓存解析域名
	-	找本机DNS缓存
	-	找路由器DNS缓存
	-	找运营商DNS缓存(80%DNS查询.到这一步结束)
	-	递归查询(查全球13台根DNS服务器)
-	进行TCP(协议)连接	三次握手(根据上一步请求回来的ip地址	去联系服务器)
	-	第一次握手	由浏览器发给服务器	你能“听见”吗？
	-	第二次握手	由服务器发个浏览器	能听见	你说吧
	-	第三次握手	由浏览器发个服务器	ok 我来说话
-	发送请求(请求报文)
-	得到响应(响应报文)
-	报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。
-	浏览器开始解析html
	-	预解析	将所有外部资源	发请求出去
	-	解析html	生成DOM树
	-	解析CSS		生成CSS树
	-	合并为一个render树
	-	js是否操作了DOM或样式
-	断开TCP连接		四次挥手
	-	第一次挥手	浏览器给服务器	东西接受完了	断开
	-	第二次挥手	服务器发给浏览器	还要东西没接收	等一会	我要验证数据的完整性	好了告诉你
	-	第三次挥手	服务器发给浏览器	接收完了	断开
	-	第四次挥手	浏览器发给服务器	好的	断开
14.	为什么握手要三次	挥手要四次
-	挥手之前 没进行数据的传输	确保握手就可以了
-	挥手之前	正在进行数据的传输	为了确保数据的完整性	必须多经历一次验证
15.	jsonp解决跨域		不是一种技术	而是智慧的结晶
-	jsonp跨域模板
-	$.ajax({
    url: 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
     crossDomain: true,
//      success: function(data) {console.table(JSON.parse(data.data))},
     success: function(res) {console.log(JSON.parse(res.data).chinaAdd);},
    data: {}
});
-	原生jsonp的步骤
	-	提前定义好一个等待被调用的函数
	-	创建一个script节点	createElement
	-	为节点指定src地址	.src
	-	将节点插入页面	appendChild
	-	这些步骤jQuery库可以帮忙做		用一个键值对				dataType:'jsonp'
	-	XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源
	-	function jsonpCallback(result) {  
        //alert(result);  
        for(var i in result) {  
            alert(i+":"+result[i]);//循环输出a:1,b:2,etc.  
        }  
    }  
	//JSONP用到了type src 	createElement
    var JSONP=document.createElement("script");  //创建script表亲啊
    JSONP.type="text/javascript";  //为script标签设置类型属性
    JSONP.src="http://crossdomain.com/services.php?callback=jsonpCallback";  //为script标签添加位置属性
    document.getElementsByTagName("head")[0].appendChild(JSONP);  //给head表亲啊添加JSONP也就是获取的资源
-	jsonp只适用于get请求
-	js里面的代码
-	let arr = [1,3,5,7,9]
	console.log(`${JSON.stringify(arr)}`)//[1,3,5,7,9]
-	利用script标签发请求不受同源策略的限制	所以不会产生跨域问题
-	套路	动态构建script节点	利用节点的src属性	发出get请求	从而绕开ajax引擎
-	弊端：
	-	只能解决get请求的跨域问题	
	-	后端必须配合前端
	app.get('/test',function(req,res){
		let {callback} = req.query
		let personArr = [{name:'peiqi',age:12},{name:'suxi',age:14}]
		res.send(`$(callback)($(JSON.stringify(personArr)})`)
	})
-	使用jsonp的精简版
-	$.getJSON('http://../test?callback=?',{name:'zhangsan',		age:12},function(data){console.log(data)})
16.	手写Promise
-	lib就是库的意思
-	自定义Promise模块
-	ES5来定义模块
-	有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易
-	(function (window) {
    const PENDING = 'pending'
    const RESOLVED = 'resolved'
    const REJECTED = 'rejected'
    //promise构造函数
    function Promise(excutor) {
        //代表Promise的实例对象
        const self = this
        //初始值是pending	未确定的
        this.status = PENDING
        //用来存储结果数据的属性	初始值是undefined
        this.data = undefined
        self.callbacks = []
        //调用excutor来启动异步任务
        //改变promise状态	改为成功	value
        function resolve(value) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = RESOLVED
            self.data = value
            //异步调用所有缓存的待执行的成功的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有成功的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onResolved(value)
                    })
                })

            }
        }
        //状态改为失败	reason
        function reject(reason) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = REJECTED
            self.data = reason
            //异步调用所有缓存的待执行的失败的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有失败的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onRejected(reason)
                    })
                })

            }
        }
        try {
            excutor(resolve, reject)
        } catch (error) {
            //执行器执行出错	promise变为失败
            reject(error)
        }


    }
    //指定成功/失败回调函数的方法
    //返回一个新的promise对象
    Promise.prototype.then = function (onResolved, onRejected) {
        const self = this
        //reason向下传递
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        //value向下传递
        onResolved = typeof onResolved === 'function' ? onResolved :  value => value
        return new Promise((resolve, reject) => {
            function handle(callback) {
                try {
                    const result = callback(self.data)
                    if (result instanceof Promise) {
                        result.then(
                            value => resolve(value),
                            reason => reject(reason)
                        )//简写result.then(resolve,reject)
                    } else {
                        resolve(result)
                    }
                }
                catch (error) {
                    reject(error)
                }
            }
            if (self.status === RESOLVED) {
                setTimeout(() => {
                    handle(onResolved)
                })

            } else if (self.status === REJECTED) {
                setTimeout(() => {
                    handle(onRejected)
                })
            } else {
                self.callbacks.push({
                    onResolved(value) {
                        handle(onResolved)
                    },
                    onRejected(reason) {
                        handle(onRejected)
                    }
                })
            }
        })
    }
    //指定失败回调函数的方法
    //catch是then 的语法糖
    Promise.prototype.catch = function (onRejected) {
        return this.then(undefined,onRejected)
    }
    //用来产生一个指定value的成功的promise
    Promise.resolve = function (value) {
        return new Promise((resolve,reject)=>{
            if(value instanceof Promise){
                //value是一个promise    结果由value决定
                value.then(resolve,reject)
            }else{
                resolve(value)
            }
        })
    }
    //用来产生一个指定reason的失败的promise
    Promise.reject = function (reason) {
        return new Promise((resolve,reject)=>{
            reject(reason)
        })
    }
    //返回一个promise	只有当数组中的所有promise都成功才成功	否则失败
    Promise.all = function (promises) {
    }
    //返回一个promise	由速度最快的完成的promise来决定
    Promise.resolve = function (promises) {
    }
    window.Promise = Promise
})(window)
17.	宏队列和微队列
-	promise是立即执行，创建就执行
setTimeout(() => {
	console.log("0")
},0)
new Promise((resolve,reject) => {
	console.log("1")
	resolve()
}).then(() => {
	console.log("2")//.then放进队列里面去
	new Promise((resolve,reject) => {
		console.log("3")
		resolve()
	}).then(() => {
		console.log("4")
	}).then(() => {
		console.log("5")
	})
}).then(() => {
		console.log("6")
	})
	new Promise((resolve,reject) => {
		console.log("7")
		resolve()
	}).then(() => {
		console.log("8")
	})
	宏队列 0
	微队列	2	8	4
	输出	1	7	2	3	8	4	5	6	0
18.	axios发ajax请求
-	function testGet() {
	axios({
		method:'GET',//默认是get方法
		url:'http://..',
		params:{
			id:2//指定get的query参数,params是对象
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
-	function testPost() {
	axios({
		method:'POST',//默认是get方法
		url:'http://..',
		//post请求用的是data来指定请求体参数,data是对象
		data:{
			id:2,
			title:'atguigu',
			author:'ddd'
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
19.	promise和xhr发送ajax请求
-	function axios({
	url,
	method='GET',
	params={},
	data = {}
})	
{
	//准备query参数	{a:1,b:2}==>a=1&b=2
	let queryStr = ''
	Object.keys(params).forEach(key => {
		queryStr += `${key}=${params[key]}&`
	})
	if(queryStr){//只有指定了params才做
	queryStr = queryStr.substring(0,queryStr.length-1)
	url += '?' + queryStr}
	return new Promise((resolve,reject) => {
		//创建xhr对象
		const xhr = new XMLHttpRequest()
		//绑定监听
		xhr.onreadystatechange = () => {
			//请求成功的时候调用resolve
			//请求失败的时候调用reject
			const {readyState,status,statusText} = xhr
			if(readysState!==4)return 
			if(status >= 200 && status < 300){
				//封装一个代表响应的对象
				const response =　{
					data: JSON.parse(xhr.response),
					status,
					statusText
				}
				//将promise对象改为成功
				resolve(response)
			}else{
				reject(new Error('request error status is '+  status))
			}
		}
		//初始化
		xhr.open(method,url,true)
		//发送请求
		if(method==='POST' || method === 'PUT'){
			xhr.setRequestHeader('Content-Type','application/json;charset=utf-8')
			xhr.send(JSON.stringify(data))
		}else{	
			xhr.send()
		}
	})
}	
20.	axios请求拦截器
-	axios拦截器作用 axios 拦截器分为 请求拦截 和响应拦截两种。 主要作用：就会在每一次请求（响应）发起后，先一步将其拿到，处理里面的数据，比如在请求头中加入一些信息等 
	axios('/posts..').then()
-	let cancel//保存取消请求的函数
	//请求拦截器
	axios.interceptors.request.use(config => {
		if(cancel){
			cancel('强制取消')
		}
		config.cancelToken = new axios.CancelToken((c) => {
			cancel = c
		})
		return config//必须返回config
	})
	//添加响应拦截器
	axios.interceptors.response.use{
		response => {
			cancel = null
			return response
		},
		error => {
			if(axios.isCancel(error)){
			console.log('1111 取消请求',error.message)
		}else{
			cancel = null
			alert('请求错误:'+error.message)
		}
		return new Promise(() => {})
		}
	}
	function get1(){
		
	axios('/get..').then(
		response => {
		console.log('1111 onResolved',resposne.data)},
		error => {	
		console.log('1111 请求出错',error.message)
	}
	)
	}
	function cancelReq(){
		if(cancel)
		cancle('强制取消')
	}
21.	axios的instance封装
-	const instance = axios.create({
	baseURL:'http://localhost:3000'
})	
	//添加请求拦截器
	instance.interceptors.request.use((config) => {
		NProgress.start()
//对data参数数据进行处理	转换为urlencoded格式
if(config.data instanceof Object){
	config.data = Qs.stringify(config.data)
}
		return config
	})

	//添加响应拦截器
	instance.interceptors.response.use(
		response => {

			return response
		},
		error => {
			throw error
		}
	)
-	function getPosts(){
	instance.get('/post').then(
		response => {
			const result = response.data
			console.log(result)
		},
		error => {
			alert(error.message)
		}
	)
}
	function addPost(){
		instance.get('/post',{title:'newTitle',author:'newAuthor'}).then(
		response => {
			const result = response.data
			console.log(result)
		},
		error => {
			alert(error.message)
		}
	)
	}
22.	webpack练习
-	文件目录
-	src
	-	css
		-	index.css
		-	iconfont.css
	-	images
	-	font//存字体的
	-	js
		-	index.js
		-	module1.js
		-	module2.js
		-	module3.js
	-	json
		-	test.json
	-	index.html//不引入任何的css和js文件
	-	package.json
	-	webpack.config.js//是任务清单
-	dist //webpack执行之后的生成的文件


-	**module1.js内容**
-	/*
	ES6模块化
	-	暴露	分别暴露	统一暴露	默认暴露
	-	引入	import{}from'./xx/xx' 	import a from './xxx/xxx'
*/
-	export function sum(a,b){
	return a+b
}


-	**module2.js内容**
-	/*
	统一暴露
*/
-	function sub(a,b){
	return a-b
}
	export {sub}


-	**module3.js**
-	/*
	默认暴露
	暴露计算乘除法的两个函数
*/
-	export default{
	 mul(a,b){
	return a*b
},
	 div(a,b){
		return a/b
	}
}


-	**index.js**
-	/*
	汇总js模块
	该文件不同于学习模块化时	汇总js的文件
	该index.js是webpack的**入口文件**
	该文件可以汇总js css 图片	音频	视频	json
*/
-	import '@babel/polyfill'//全部新语法都转换	这时候要按需引入
	import {sum} from './module1'
	import {sub} from './module2'
	import module3 from './module3'
	import a from '../json/test.json'
	//在入口文件中引入样式	不用变量	
	import '../css/index.less'
	import '../css/iconfont.less'
	console.log(sum(1,2))
	console.log(sub(3,4))
	console.log(module3.mul(1,2))
	console.log(module3.div(1,2))
	console.log(a,typeof a)
	let myPromise = new Promise((resolve,reject)=>{
		resolve('haha')
	})
	myPromise.then((data)=>{
		console.log(data)
	})


-	**text.json**
-	/*

*/
-	{
	"name":"peiqi"
	"age":18
}


-	**webpack.config.js配置文件**
-	/**/
-	const {resolve} = require('path')
	const HtmlWebpackPlugin = require('html-webpack-plugin')
	module.exports = {
	entry:['./src/js/index.js','./src/index.html']//入口
	output: {
		path:resolve(__dirname,'../dist'),//输出路径
		filename:'./js/index.js'//输出文件名
		publicPath:'/'//所有资源在引入是的公共路径
	},//输出
	mode:'production',//配置工作模式
	module:{
		rules:[
			//解析less
		{//rules是一个数组	数组中的每一个对象都是一个loader
			test:/\.less$/,//匹配所有的less文件
			use:[
				//'style-loader',//用于在html文档中创建一个style标签	将样式塞进去
				MiniCssExtractPlugin.loader,
				'css-loader',//将less编译后的css转化为CommonJs的一个模块
				'less-loader'//less编译为css	但不生产单独的css文件		在内存里面
				],
		},
		//js语法检查
		{
			test:/\.js$/,//匹配所有的js文件
			exclude:/node_modules/,//除了node_modules文件夹
			enforce:"pre",//提前加载使用
			use:['eslint-loader']
		},
		//js语法转换方法一
		{
			test:/\.js$/,
			exclude:/node_modules/,
			use:{
				loader:"babel-loader",
				options:{
					presets:['@babel/preset-env']
				}
			}
		},
		//js语法转换方法二
		{
			test:/\.js$/,
			exclude:/node_modules/,
			use:{
				loader:"babel-loader",
				options:{
					presets:[['@babel/preset-env',{
						useBuiltIns:'usage',
						corejs:{version:3},
						targets:{
							"chrome":"58",
							"ie":"9"
						}
					}]],
					cacheDirectory:true//开启babel缓存	加快速度
				}
			}
		},
		//使用url-loader处理样式文件中的图片
		{
			test:/\.(png|jpg|gif)$/i,
			use:[
				{
					loader:'url-loader',
					options:{
						limit:8192,//图片会base64处理
						outputPath:'images',//文件输出路径
						publicPath:'images/',
						name:'[hash:5].[ext]'//修改文件名称
					}
				}
			]
		},
		//使用file-loader处理样式文件里的图片
		{
			test:/\.(png|jpg|gif)$/i,
			use:[
				{
					loader:'file-loader',
					options:{
						publicPath:'../dist/images',//决定图片的url路径
						outputPath:'images',//文件输出路径
						name:'[hash:5].[ext]'//修改文件名称
					}
				}
			]
		},
		//解析html里面的标签
		{
			test:'/\.(html)$/',
			use:{
				loader:'html-loader'
			}
		},
		//使用file-loader处理其他资源
		{
			test:/\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/,
		
					loader:'file-loader',
					options:{
						
						outputPath:'media',//文件输出路径
						name:'[hash:5].[ext]'//修改文件名称
					}
				
			
		},
		]
	},//用来解析less文件
	//配置插件
	plugins:[new HtmlWebpackPlugin({
		template:'./src/index.html',
		minify:{//用于压缩的
			
		}
	}),
	new MiniCssExtractPlugin(),//前面没有引入
	new CleanWebpackPlugin() 
	],
	devServer:{//自动的服务器
		open:true,//自动打开浏览器 
		compress:true,//启动gzip压缩	加快浏览器打开速度
		port:3000,//端口号
		hot:true
	},
	devtool:'cheap-module-eval-source-map'
}	


-	index.css文件设置样式


-	package.json文件里面可以设置短命令
-	"script":{
	"start":"webpack-dev-server --open"
}//可以用npm run start 或者	npm start	只有run可以省略

23.	虚拟DOM的key的作用
-	key是虚拟DOM对象的表示	在更新显示的key有重要的作用
-	当状态数据发生变化的时候	React会生成新的虚拟DOM 随后React将之前的旧虚拟DOM	与新的虚拟DOM进行diff比较	
	-	旧的虚拟DOM中找到了相同了key
		-	若虚拟DOM没变	直接使用原来的真实DOM 	不去刷新页面的真实DOM
		-	若虚拟DOM变了	先更新虚拟DOM	随后刷新页面的真实DOM
	-	旧的虚拟DOM没找到相同的key
		-	根据item数据创建新的虚拟DOM	随后渲染真实DOM到页面
-	index作为key的问题
	-	产生没有必要的真实DOM更新
	-	如果DOM界面还有输入类DOM	产生错误的真实DOM更新	界面有问题
-	使用数据的唯一标识作为key
24.	组件之间通信
-	props传递
	-	去点只能一层一层传递	兄弟组件之间传递要借助父组件
	-	一般数据是父组件向子组件
	-	函数数据是子组件向父组件
-	消息订阅发布机制
	-	实现库是pubsub-js
-	redux
	-	集中式管理多个组件共享的状态	
25.	mouse事件	常常用到的是enter leave		不常用到over  out
-	例如一个父子组件	鼠标移动接近父组件的时候触发over	接近父组件里面的子组件的时候触发out	离开子组件的时候再次触发over
26.	组件里面的data配置为什么只能是函数	而不是对象
-	是为了保证对各实例对象的data对象不是共用的	而是各自自己的data对象
27.	call  apply  bind 函数的认识
	function(a,b){
	this.xxx = 3;
	console.log(a,b,this)//this是window
	return a+b//返回值
}
-	console.log(xxx)//xxx是window是属性	可以直接输出
-	全局变量	函数	分别是window的属性	方法
-	所有函数都可以调用call()函数
-	call apply的作用就是调用函数
-	const obj = {m:0}
-	fn.call(obj,1,2)//call函数的变量输入是分别传入的	相当于执行了	obj.fn(1,2)
-	fn.apply(obj,[1,2])//apply函数的参数变量是数组传入的
-	fn.call(undefinded)//undefined  null  就是window
-	fn.bind(obj)(1,2)//bind返回一个新的函数	那么后面可以再加上括号就是正确的	调用新的函数	这可以通过新的函数去执行老的函数	fn调用bind函数	那么fn就变成了老的函数	fn.bind(obj)是新的函数		fn(1,2)再次自身调用是没有作用的	新函数的调用相当于老函数的执行	且this为bind 指定的第一参数的值
-	fn.bind(obj,5)//bind函数执行的时候可以加上参数	就是说可以指定将来将要调用函数的参数
28.	自定义实现 call   apply  bind函数
-	call函数的实现
	-	Function.prototype.call = function(obj,...args){
		<!-- console.log('call()') -->
			//this(...args)//执行了函数		记得传入参数
			//处理obj是undefined  null 的情况
			if(obj===undefined || obj===null){
				obj = window
			}
			//给obj添加一个方法	temFn:this
			obj.tempFn = this
			//调用obj的temFn方法		传入args参数 	
			const result = obj.temFn(...args)
			//删除obj的temFn方法
			delete obj.temFn
			//返回方法的返回值
			return result
		}
-	apply函数的实现		和call函数是一样的
	-	Function.prototype.apply = function(obj,args){
		console.log('call()')}
-	bind函数的实现
	-	Function.prototype.bind = function(obj,...args){
		//返回一个新函数
			return (...args2) =>{
				//调用原来的函数	且指定this为obj	参数列表为args		和   args2组成
				return this.call(obj,...args,...args2)
			}
		}
-	一个函数  方法的this是看具体什么东西调用	是window  或是某个实例化对象
29.	数组去重	
-	Array.from(new Set(array))	//Set函数就执行了数组去重的操作
-	[...new Set(array)]	//也实现了数组去重操作	
30.	数组合并	切片
-	 concat()数组合并	n个数组合并为一个新数组	原始数组不会改变	[[a]]	concat()函数只可以拆掉一层数组	也就是说做连接的时候[[a]]变为了[a]
	-	var new_arr = concat(arr,value1[,value2[,value3]])
-	slice()数组切片	返回一个有begin和end决定的原数组的浅拷贝	原数组不会被改变	例如 arr=[1,2,3,4,6,7,8] slice(arr,1,3)其中1代表起始点下标起始点是包含在结果里面的	3代表结束点下标结束点是不包含在结果里面的	最后的结果是	[2,3]	
-	-1代表倒数第一个
	-	var new_arr = slice(array,[begin[,end]])
-	判断是不是数组Array.isArray(value)
31.	数组扁平化	
-	取出嵌套(多维)中的所有元素放到一个新数组里面去
-	[1,[2,3[4,5]]]---->[1,2,3,4,5]
-	实现的方法
	-	方法一   递归  +	reduce()+concat()
		-	export function flatten(array){
			return reduce((array,(pre,item)=>{
				pre.push(!Array.isArray(item)?item:(flatten(item)))//递归层层拆卸	...负责拆分操作
				return pre
			},[])
		}//实际运行的...运算符会出错
	-	方法二	 ... + some() + concat()
		-	export function flatten1(array){
			if(!Array.isArray(item)){
					pre.push(item)
				}else{//contact()递归连接数组元素
				pre = concat(pre,flatten1(item))
				}
				return pre
		},[])}
	-	方法三
		-	function flatten2(array){
			arr = [].concat(...array)//直接就去除了一层数组的嵌套
			while(arr.some(item=>Array.isArray(item))){
				arr = [].concat(...arr)
			}
			return arr
		}
32.	数组的取真	分块
-	compact(array):返回数组中所有真值元素组成的新数组
	-	export default function compact(array){
	return array.filter(item => item)
	}
-	数组分块	chunk
	-	export function chunk(array,size=1){
		const bigArr = []
		let smallArr = []
		//如果是空数组	直接返回空数组
		if(array.length === 0){
			return bigArr
		}
		//处理size异常情况
		//size没有指定
		//if(size<1){size = 1}
		else if(size>array.length){size = array.length}
		array.forEach(item =>{
			//将小数组放到大数组里去	只能放一次
			if(smallArr.length === 0){
				bigArr.push(samllArr)
			}
			//将元素添加到小数组
			smallArr.push(item)
			//限制smallArr的最大长度是size
			if(smallArr.length === size){
				smallArr = []
			}
		})
		return bigArr
	}
33.	数组之间的差异部分	difference
-	difference(arr1,arr2)		得到arr1中arr2没有的数组
-	export function difference(arr1,arr2){
	//处理特殊情况
	if(arr1.length===0){
		return []
	}else if(arr2.length===0){
		return [...arr1]
	}
	//对数组进行过滤
	return filter(arr1,item => arr2.indexOf(item)===-1)
}
-	export function differences(arr1,...arrays){
	//处理特殊情况
	if(arr1.length===0){
		return []
	}else if(arrays.length===0){
		return [...arr1]
	}
	//对数组进行过滤
	return filter(arr1,item => {
		let result = true//假设当前元素在后面的所有数组都不存在
		arrays.forEach(array=>{
			const index = array.indexOf(item)
			if(index!==-1){
				result = false
				break//结束当前for循环	因为要求取得元素是不同的
			}
		})
		return result
	})
}
34.	合并数组	merge
-	export function mergeArray(array,...arrays){
	const result = [...array]//三点运算符就是遍历第一个数组的result
	arrays.forEach(itemArr =>{
		itemArr.forEach(item => {
			if(result.indexOf(item)===-1){
				result.push(item)
			}
		})
	})
	return result
}
35.	数组删除元素	pull(array,...values)	删除数组中元素和values相同的元素	原数组改变了	
-	export function pull(array,...values){
	const result = []
	array.forEach((item,index) => {
		if(values.indexOf(item)!==-1){
		//删除item
		array.splice(index,1)
		//将item添加到result数组	
		result.push(item)
		}
	})
	return result
}
36.	drop(array,count)	过滤掉array左边的count个元素
-	export function drop(array,count=1){
	if(array.length == 0){
		return []
	}
	if(count<1){
		count = 1
	}
	return array.filter((item,index) => index>=count)
}
37.	自定义new 工具函数
-	export function newInstance(Fn,...args){
	//创建一个空对象
	const obj = {}
	//调用Fn函数	且指定this是新创建对象
	const result = Fn.call(obj,...args)
	//如果Fn执行返回的是对象类型	最终结果就是这个对象
	if(result instanceof Object){
		return result
	}
	//让原型对象是空的object对象	且constructor属性为Fn
	//obj.__proto__ = {}
	//Fn函数生成	原型对象 构造函数就已经确定了	下面这句话不用创建{}	效率更高
	//将构造函数的显式原型属性赋值实例对象的隐式原型属性
	obj.__proto__ = Fn.prototype
	obj.__proto__.constructor = Fn
	//返回新建对象
	return obj
}
38.	自定义instanceof工具函数
-	export function myInstanceOf(obj,Type){
	//得到一个原型对象
	let  protoObj = obj.__proto__
	while (protoObj!==null){//存在原型对象
	//如果就是Type的原型对象	直接返回true
		if(protoObj===Type.prototype)
		{	
			return true
		}
		//取出下一个原型对象	并保存
		protoObj = protoObj.__proto__
	}
	//出了循环	说明类型不匹配
	return false
}
39.	对象合并	对象里面有同名属性	是合并	不是覆盖
-	export function mergeObject(...objs){
	const result = {}
	objs.forEach(obj=>{
		Object.keys(obj).forEach(key=>{
			const value = obj[key]
			//result里面没有key属性
			if(!result.hasOwnProperty(key)){
				result[key] = value
			}else{//result里面有key属性
			//对原值和value进行合并生成新的数组
			result[key] = concat([],result[key],value)
		}
		})
	})
	return result
}
40.	实现浅拷贝
-	export function clone1(target){
	if(target instanceof Array){
		//return [...target]
		//return target.slice()
		//return [].concat(target)
		//return Array.from(target)

	}else if(target !== null && typeof target === 'obj'){
		return {...target}
	}else{//如果不是数组或者对象	直接返回
		return target
	}
}
-	export function clone2(target){
	//被处理的目标是数组/对象
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		const cloneTarget = target instanceof Array? [] : {}
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = target[key]
			}
		}
		return target
	}else{
		return target
	}
 }
 41.	实现深拷贝
 -	大众乞丐版
	-	存在问题
	-	函数属性会丢失
	-	循环引用会出错
 -	export function deepClone1(target){
	 return JSON.parse(JSON.stringify(target))
 }
-	JSON数据存不了函数
-	面试基础版
-	解决了函数属性丢失		也就是方法丢失
-	export function deepClone2(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		const cloneTarget = target instanceof Array? [] : {}
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deepClone2(target[key])//对属性值进行递归处理
			}
		}
		return cloneTarget
	}else{
		return target
	}
 }
-	面试加强版
-	解决循环引用出错
-	解决思路
	-	同一个对象/数组只能被克隆一次
	-	创建克隆对象前：
		-	如果克隆对象已经存在	直接返回
	-	创建克隆对象后：
		-	将克隆产生的对象存起来
	-	缓存容器结构
		-	map	==>	key:target	value:cloneTarget	
-	export function deepClone3(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		//map里面存在对应的克隆对象	直接返回
		let cloneTarget = map.get(target)
		if(cloneTarget){//不对同一个对象进行多次clone
			return cloneTarget
		}
		const cloneTarget = target instanceof Array? [] : {}
		//保存到map容器
		map.set(target,cloneTarget)
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deepClone2(target[key],map)//对属性值进行递归处理
			}
		}
		return cloneTarget
	}else{
		return target
	}
 }
 -	面试最强版
 -	优化了数组的遍历	不用for in 而用forEach
 -	export function deeClone4(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		//map里面存在对应的克隆对象	直接返回
		let cloneTarget = map.get(target)
		if(cloneTarget){//不对同一个对象进行多次clone
			return cloneTarget
		}
		if(target instanceof Array){
			cloneTarget = []
			map.set(target,cloneTarget)
			target.forEach((item,index)=>{
				cloneTarget[index] = deeClone4(item,map)
			})
		}else{
			cloneTarget = {}
			map.set(target,cloneTarget)
			for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deeClone4(target[key],map)//对属性值进行递归处理
			}
		}
		}
		
		return cloneTarget
	}else{
		return target
	}
 }
42.	字符串倒序	回文	截取
-	字符串倒序
-	export function	reverseString(str){
	return str.split('').reverse().join('')
}
-	字符串回文
-	export function palidrome(str){
	return str === reverseSring(str)
}
-	字符串截取
-	export function truncate(str,num){
	return str.length > num ? str.substring(0,num) + '...' : str
}
43.	手写继承
-	寄生组合式继承
-	构造函数中用call借用父类型构造函数	得到父类型的属性
-	指定新的原型对象	得到父类型原型对象上面的属性方法
-	寄生处理:去除原型对象上多余的属性就要借用中间者(指路人)
-	function Person(name,age){
	this.name = name
	this.age = age
}
Person.prototype.sayName = function(){
	console.log('my name',this.name)
}
function Student(name,age,price){
	//借用父类型的函数
	//this打电话给person来借用函数	
	Person.call(this,name,age)//相当于this.Person(name,age)
	this.price = price
}
//Student的原型对象指向了Person的实例
Student.prototype = new Person()
//Student构造器出现问题	就重新指向构造器
Student.prototype.constructor = Student
//Student的prototype多了Person的多余的name age属性
-	解决方案是
	-	create是一个工具函数	用来解决要调用Person的方法会解决携带Person上面多余属性的问题
	-	function create(proto){
		function Fn(){}
		Fn.prototype = proto
		return new Fn()
	}
	-	Student的原型对象指向了Fn函数   Fn的原型对象指向了Person的原型对象		那么Student就可以沿着原型链找到Person里面具有的方法	想用的属性	用Student原型对象指向Fn函数的方法去除了Student原型对象直接指向Person原型对象而造成的携带多余参数的问题		相当于找了一个**中间者解决多余携带**	让中间者指定可以用的东西的方向	要用的时候直接沿着路径去拿要用的东西	而不是一股脑全部携带很多东西		是个很明智的做法
	-	Student.prototype = create(Person.prototype)
44.	数据结构和算法
-	数据结构
	-	狭义
		-	数据的存储方式
	-	广义
		-	数据存储和算法
-	常见的数据结构
	-	数组	栈	队列	链表	树	集合	图	哈希表	堆
	-	这些可以自己写写
-	数组在一块连续的内存里面	这种说法式不完全正确的
-	栈应用	
	-	十进制转换为二进制
-	pop从栈顶取出开始删除	同时返回删除的元素
-	es6实现了集合类型	new set()	里面的元素不可以重复
-	希尔排序	快速排序比较重要	
	-	理解希尔排序	先了解插入排序
	-	计算出一个增量数组(折半)
		-	递减	最后一个必须是1
		-	distance = Math.floor(length/2)
		-	以当前增量对数组进行分组	分成多个小数组	对每个小数组	进行插入排序	每个小数组排序是交替进行的
-	es6语法可以用到		直接交换数组值的大小
	-	[arr[j+1],arr[j]] = [arr[j],arr[j+1]]
-	Math.floor()向下取整
-	Math.ceil()向上取整
-	[] == ![]	返回的是true	右边的[]是true	加上!是false	false和空数组转换为数值之间的比较	0==0	所有返回true
-	NaN和其他任何数值比		返回都是false	
-	任何数组	对象转换为boolean值	都是true 转换为数字的时候	看情况	空的数组	对象就是0
-	不同类型比较会装换为 数值之间的比较
##	盒模型
-	margin border padding content
##	怪异盒模型
-	 border padding content
##	js算法
-	数组的升序
	-	points.sort(function(a, b){return a - b});		  nums.sort((a, b) => a - b);
-	数组的降序
	-	points.sort(function(a, b){return b - a});
-	new一个新数组解决方法
-	没有排序的数组先排序	好计算
-	Math.max选出大的元素
-	判断数组长度为0的特殊情况
##	append()尾插
-	pop()尾删除
##	两个数组实现一个队列		stack1进队列		stack2出队列
-	var CQueue = function() {
    this.stack1 = []
    this.stack2 = []
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
    this.stack1.push(value)
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
if(this.stack2.length)return stack2.pop()
while(this.stack1.length){
    this.stack2.push(this.stack1.pop())
}
return this.stack2.pop() || -1
};
##	水平居中
	行内元素: text-align: center
	块级元素: margin: 0 auto
	position:absolute +left:50%+ transform:translateX(-50%)	
	display:flex + justify-content: center
-	translateX是相对于元素本身来调整样式
##	垂直居中
	设置line-height 等于height
	position：absolute +top:50%+ transform:translateY(-50%)
	display:flex + align-items: center
	display:table+display:table-cell + vertical-align: middle;
##	rem是全部的长度都相对于根元素<html>元素
-	em
	子元素字体大小的em是相对于父元素字体大小
-	vw/vh
	Viewport Width 和 Viewport Height，视窗的宽度和高度
-	label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验
##	遍历A节点的父节点下的所有子节点
-	var a = document.getElementById('a').parentNode.children
##	页面渲染
-	解析html源码	DOM树
-	解析css源码	CSSOM树
-	DOM + CSSOM	渲染树
-	页面绘制
##	cors
-	支持同源通信	跨域通信	fetch是实现cors通信		跨域资源共享
##	export和export default的区别？
	export default  xxx
	import xxx from './'

	export xxx
	import {xxx} from './'
##	left right 条件的变化  ex例子
##	数组首先判断有无顺序
## splice函数
-	arrayObject.splice(index,howmany,item1,.....,itemX)
-	 index	必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。		删除的位置
	howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。			删除的数量
	item1, ..., itemX	可选。向数组添加的新项目。						添加项目
##	 slice函数
	slice(index1[,index2])
	slice() 方法返回包含从数组对象中的第 index1～index2-1 之间的元素的数组。
##	多层的递归调用不可随便使用
-	成为了递归黑洞	时间损耗严重
##	new Array(n+1)
-	数的初始化
##	数组可以装对象	对象可以装数组	灵活运用
##	排序算法分析
-	不稳定
	-	选择排序	希尔排序	快速排序	堆排序
-	冒泡排序
	-	双重for循环		相邻两两比较	根据想要的排序顺序交换值的位置
-	选择排序
	-	依次找出最小索引	次次完成直到最后的排序完成 
-	插入排序		for + while
	-	 for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];//元素的移动
            preIndex--;//插入的位置变化
        }
        arr[preIndex+1] = current;
    }
-	希尔排序	相对于插入排序而言就是   	多了一个把数据分组
	-	希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列 for(for(for()))
	-	function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while(gap < len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap > 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i < len; i++) {
            temp = arr[i];
            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
-	归并排序
-	快速排序	分治法	基准数--》分区--》重复
-	void quick_sort(int s[], int l, int r)
{
    if (l < r)
    {
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
        int i = l, j = r, x = s[l];
        while (i < j)
        {
            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
                j--;  
            if(i < j) 
                s[i++] = s[j];
            
            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
                i++;  
            if(i < j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - 1); // 递归调用 
        quick_sort(s, i + 1, r);
    }
}
-	堆排序
	-	大顶堆	升序
	-	小顶堆	降序
-	计数排序
-	function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue+1),//数组来装数据
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i < arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;//记录数据的产生的数量
    }

    for (var j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
-	桶排序
-	桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
-	基数排序
-	MSD 从高位开始进行排序
-	LSD 从低位开始进行排序
-	var counter = [];
	function radixSort(arr, maxDigit) {
    var mod = 1;
    var dev = 1;
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
           var bucket = parseInt((arr[j] % mod) / dev);//数据具有怎样的特征
            if(counter[bucket]==null) {	//bucket是低位基数特征	相同低位基数是在同一个数组
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);//放入这个相应特征的数据
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;//一轮的基数排序结束	放入数组里面	接着进行下一轮直到结束
                }
          }
        }
    }
    return arr;
}
##	split(' ')空格分割字符串
##	join('20%')%20连接字符串标志
##	Math.ceil()向上取整	Math.floor()向下取整 Math.round()四舍五入
-	123e5-->12300000
-	pop() 方法用于删除数组的最后一个元素并返回删除的元素。-->let a = arr.pop()		push向数组里面放数据
##	unshift() 方法可把参数指定的元素依次添加到数组的前面，并返回添加元素后的数组长度。该方法必须至少有一个参数。
##	shift() 方法可删除数组第一个元素，并返回删除的元素。
##	sort() 方法用于按某种规则排序数组：当方法的参数为空时，按字典序（即元素的 Unicode 编码从小到大排序顺序）排序数组元素
##	 concat(数组1,…,数组n)
##	reverse() 方法可返回当前数组倒序排序形式
##	join(分隔符)
	join() 方法可将数组内各个元素按参数指定的分隔符连接成一个字符串。参数可以省略，省略参数时，分隔符默认为“逗号”。
##	forEach()
	forEach() 方法用于对数组的每个元素执行一次回调函数。	forEach(()=>{})
##	 filter()
	filter() 方法用于创建一个新的数组，其中的元素是指定数组中所有符合指定函数要求的元素。
-	var names1 = ["张山","张小天","李四","张萌萌","王宁","陈浩"];//原数组
	function checkName(name){ //定义回调函数，判断名字是否姓“张”
		if(name.indexOf("张") != -1){
				return true;
			}else{
				return false;
			}
	}
	var names2 = names1.filter(checkName);//对names1执行回调用函数，返回所有姓张的名字

	names2.forEach(function(item,index){//遍历names2数组中的每个元素
			console.log("names2[" + index + "] = " + item);
	});
##	map() 函数返回一个新数组，其中的元素为原始数组元素调用回调函数处理后的值。
-	var number = [1,2,3];//原数组
	var num=number.map(function(item){//对原数组中的每个元素*2，将值分别存储在num数组中
			return item * 2;
	});
##	传输控制协议（TCP）
-	用户数据报协议（UDP）
-	TCP/IP 和UDP最大的区别就是：TCP/IP是面向连接的，UDP是无连接的。
-	在实际的使用中，TCP主要应用于文件传输精确性相对要求较高且不是很紧急的情景，比如电子邮件、远程登录等,只能是一对一通信。有时在这些应用场景下即使丢失一两个字节也会造成不可挽回的错误，所以这些场景中一般都使用TCP传输协议。由于UDP可以提高传输效率，所以UDP被广泛应用于数据量大且精确性要求不高的数据传输，比如我们平常在网站上观看视频或者听音乐的时候应用的基本上都是UDP传输协议。
-	使用UDP 传输数据，源端和终端不建立连接
##	
-	计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。 指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。 而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。
##	在编译型语言中sum += i部分在循环运行时已经编译成了机器码，机器码将直接运行一千次。
	但是在解释型语言中，执行时会将sum += i转换（编译）一千次。
##	数组本来应该是一个连续的内存分配，但是在Javascript中不是连续分配的，而是类似哈希映射的方式存在的。
##	Javascript中出现了ArrayBuffer，它可以创建连续的内存供编程人员使用。	
##	ES6 Modules 相对于 CommonJS 的优势是什么？
1. 语言层级支持，无需引入第三方库
2. 统一的 API，不用再写 [shim](umdjs/umd · GitHub)
3. 清爽的语法（与 Python 相似），功能却很丰富：
##	使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据
// 扁平数据
[{
  name: '文本1',
  parent: null,
  id: 1,
}, {
  name: '文本2',
  id: 2,
  parent: 1
}, {
  name: '文本3',
  parent: 2,
  id: 3,
}]

// 树状数据
[{
  name: '文本1',
  id: 1,
  children: [{
    name: '文本2',
    id: 2,
    children: [{
      name: '文本3',
      id: 3
    }]
  }]
}]
###	编译程序的工作过程一般也可以划分为五个阶段：词法分析、语法分析、语义分析与中间代码产生、优化、目标代码生成。
##	IR中间代码
-	前端对源程序进行分析并产生中间表示，后端在此基础上生成目标代码。
-	 IR是由LLVM生成的中间代码，作用是优化编译器或VM，使优化后的机器代码执行效率更高，同时避免缓存编译后的二进制代码占用更多的内存。
##	 为什么会有交叉编译
交叉编译是在一个平台上生成另一个平台上的可执行代码。 同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。
之所以要有交叉编译，主要原因是：
Speed： 目标平台的运行速度往往比主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能
Capability： 整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间
Availability： 即使目标平台资源很充足，可以本地编译，但是第一个在目标平台上运行的本地编译器总需要通过交叉编译获得
Flexibility： 一个完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上
##	发布 / 订阅模式和观察者模式的区别是什么？
观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。
##	ioc它不是一种技术，它是一种设计思想。
传统式的对象创建，一般会用new，现在就是交给ioc容器所管理，意味着管理对象权力从调用者移除，反转给IOC容器管理，因此才命名为控制反转。
IOC相当于一个容器，管理所有对象。
##	这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
##	这是一种采用函数式编程的基础部件进行响应式编程的编程范式。
对此FRP提出了三个原则：
单一数据源：一个应用永远只有唯一的数据源。
状态只读：状态是只读的，如果需要更改则发出通知，而不是交给外部进行修改，控制变化。
修改状态应由纯函数完成：因为纯函数没有副作用，所以状态的改变有迹可循。
##	抽象语法树（AST） 	
-	AST螺丝刀：recast
##	 沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源。
##	hash  路由模式的实现主要是基于下面几个特性：
URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
##	history 路由模式的实现主要基于存在下面几个特性：
pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
##	.JavaScript 中的 const 数组可以进行 push 操作吗？为什么？
答：
可以，也可以进行splice()操作。
const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容
##	.JavaScript 中对象的属性描述符有哪些？分别有什么作用？
答：
Configurable(可配置性)
可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true
Enumerable(可枚举性)
可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true
Writable(可写性)
可写性决定是否可以修改属性的值，默认值为true
##	
首先callback不是异步API，它是早年JS异步编程实现的一种手段。
Promise是社区为了解决回调地狱的问题在ES6版本提出的一种解决方案；
Generator也是一种异步编程解决方案，它最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注；
Async/await是 ES7 中提出的新的异步解决方案，async 是 Generator 函数的语法糖，async/await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链）。async/await 不仅仅是 JS 的异步编程的一种方式，其可读性也接近于同步代码，让人更容易理解。
##	 Object.defineProperty(object, propertyname, descriptor)
object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript对象（即用户定义的对象或内置对象）或 DOM 对象。
propertyname 必需。 一个包含属性名称的字符串。
descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。
##	渐进式代表的含义是：没有多做职责之外的事。
你可以使用jsx开发，你也可以写template；你可以使用vue全家桶，你也可以把它做为某个业务的轻量视图，随你，不强求不主张。
##	单工数据传输只支持数据在一个方向上传输;
半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；
全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。
##	Session
客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 **HTTP 无状态特性**，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。
##	Cookies
HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。
##	正向代理时，通常，客户端发送对目标服务器的请求，代理服务器在中间将请求转发给目标服务器，并将结果返回给客户端。
##	反向代理与正向代理恰好相反，代理服务位于服务器端。
对客户端来说，反向代理服务器就好像是目标服务器。反向代理服务器接收客户端发来的请求，然后将其分发到内网的服务器，并将内网服务器返回的结果返回给客户端
##	Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？
答：
可以。
HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。
##	 网关即Gateway，它是连接基于不同通信协议的网络的设备，使文件可以在这些网络之间传输。
##	因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性（具体细节二面再说）。
不过需要注意的是，即便使用 HTTPS 仍可能会被抓包，因为HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。
	-	https加重了服务端的负担，相比于http其需要更多的资源来支撑，同时也降低了用户的访问速度
##	Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。
##	每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。
##	比如 created 钩子可以用来在一个实例被创建之后执行的代码 
##	**因为箭头函数并没有 this**
##	created mounted updated destroyed  beforecreate beforemount beforeupdate beforedestroy
##	通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定
##	v-bind:href="url"  :href="url"
##	v-on:click="doSomething"  @click="doSomething"
##	不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖		computed属性会有缓存来解决多次不必要的计算的问题	computed会有缓存的影响	用到多次计算的时候在用到方法	函数方法会每次都执行	那么可能会有一些不必要的计算 这就是缓存vs方法的不同	
##	计算属性 vs 侦听属性
Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。watch	watch:{}
##	计算属性的 setter
计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：
-	 get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
##	`_.debounce` 是一个通过 Lodash 限制操作频率的函数。
 _.debounce(this.getAnswer, 500)
##	Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可	
##	你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：
	<div v-for="item of items"></div>
##	在 JavaScript 中， 迭代器 是一个对象，它定义一个序列，并在终止时可能返回一个返回值。
##	遍历对象
-	(value, name, index) in object
##	遍历数组
-	(item,index) in arr
##	当它们处于同一节点，v-for 的优先级比 v-if 更高
##	注意这里的 **is="todo-item"** attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 <ul> 元素内**只有 <li>** 元素会被看作有效内容。这样做实现的效果与 <todo-item> 相同，但是可以避开一些潜在的浏览器解析错误。
 `<li is="todo-item"></li>`
##	event.target.tagName
##	有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法	template里面传参是$event
-	warn: function (message, event) {}
##	Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。
.stop
.prevent
.capture
.self
.once
.passive
-	v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。
##	v-on:keyup.enter="submit"
-	<!-- Alt + C -->
<input v-on:keyup.alt.67="clear">
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button v-on:click.ctrl="onClick">A</button>
<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>
<!-- 没有任何系统修饰符被按下的时候才触发 -->
`<button v-on:click.exact="onClick">A</button>`

##	如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：
<input v-model.number="age" type="number">

##	data 必须是一个函数
当我们定义这个 <button-counter> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：
data: {
  count: 0
}
取而代之的是，**一个组件的 data 选项必须是一个函数**，因此每个实例可以维护一份被返回对象的独立的拷贝：
##	ES6 Set()去重
Set。它类似于数组，但是成员的值都是唯一的
通过add()方法向 Set 结构加入成员
-	arr.forEach(item=>{
	set2.add(item)
})
##	事务的四大特性主要是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
-	原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。
-	一致性（Consistency）
官网上事务一致性的概念是：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
-	隔离性（Isolation）
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
-	持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。
##	模板字符串		``
-	const a = 20;
const b = 10;
const c = "JavaScript";
const str = `My age is ${a+b} and I love ${c}`;
##	原始字符串是一个普通字符串，其中不会解释转义字符。我们可以使用模板字符串创建原始字符串。我们可以使用String.raw来获取原始字符串，代码如下：
let s = String.raw `xy\n${ 1 + 1 }z`;
##	post: {
  id: 1,
  title: 'My Journey with Vue'
}
<blog-post v-bind="post"></blog-post>

##	js中symbol对象 es6引入了一种新的基本数据类型symbol，表示独一无二的值，最大的用法是用来定义对象的唯一属性名，
##	clear 只对块级元素生效。block
##	将 <slot> 元素作为承载分发内容的出口。
##	这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。
-	provide: function () {
  return {
    getMap: this.getMap
  }
}
-	inject: ['getMap']
##	当 inline-template 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。
##	另一个定义模板的方式是在一个 <script> 元素中，并为其带上text/x-template 的类型，然后通过一个 id 将模板引用过去。例如：
<script type="text/x-template" id="hello-world-template">
  <p>Hello hello hello</p>
</script>
##	渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来
-	 <div v-once></div>
##	v-show 的功能是条件展示，如果条件为 true 就显示，否则就隐藏。v-show 的显示和隐藏主要是更改 CSS 的 display 属性，并不会重新渲染或删除元素。display:none			
	-	v-show 无论初始值为 true 还是 false 元素都会被渲染，显示和隐藏也只是更改 display。比较适合用在一些需要平凡切换显示和隐藏的场景，例如对话框之类的。
##	v-if 的功能是条件渲染，只有条件为 true 才会渲染。如果 v-if 的初始值为 false ，元素就不会渲染。如果中途改变 v-if 的值为 false ，元素会被删除。
	-	因为 v-if 会重新渲染或删除元素，而且如果初始条件为 false 就不会渲染。比较适合用在一些不需要平凡切换或内容较多的元素。例如不同页面之间切换就比较适合用 v-if。
##	toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。
##	SVG 意为可缩放矢量图形（Scalable Vector Graphics）。
-	SVG 使用 XML 格式定义图像。
##	混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
-	var Component = Vue.extend({
  mixins: [myMixin]
})
-	**混入对象的钩子将在组件自身钩子之前调用。**
-	混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。
	-	Vue.mixin({})
##	自定义指令		Vue.directive('xx',{})	v-xx
-	// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
-	directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
##	自定义的 指令
	-	<div v-demo="{ color: 'white', text: 'hello!' }"></div>
	-	Vue.directive('demo', function (el, binding) {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text)  // => "hello!"
})
	-	binding是数据写指令的时候可以对象传入			传入键值对
##	服务端代码
-	1.node里面express
	-	let express = require('express')
		const app = express()
		app.listen('3000',()=>{
			console.log('server ok')
		})
-	2.原始的http请求
	-	let http = require('http')
		let qs = require('queryString')
		let server = http.createServer(function(req,res){

		})
		server.lesten('3000',(err)=>{
			if(!err){
				console.log('server ok')
			}else{
				console.log('server wrong')
			}

		})
##	VNode 必须唯一
-	组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：
-	render: function (createElement) {
  var myParagraphVNode = createElement('p', 'hi')}
-	createElement		createElement('p','h1')没有满足元素唯一的条件
##	vue 当中的 @click.native
-	.native--侦听组件根元素上的原生事件
	作用： 给组件绑定原生事件
-	@click是我们在vue开发中经常用到的事件绑定，而@实际上是 v-on 的简写，而 v-on 则是对 vue 的事件体系封装之后的 API接口
也就是说，在处理DOM原生事件的场合中需要添加额外的标识符
##	使用组件的流程
-	引入		声明 	使用
##	关注点分离
-	标识 封装	操作关注点的能力	处理复杂性的一个原则	关注点分离就是让程序设计思路清晰	而不是错综复杂能以理解的
##	测试
1.	单元测试
2. 	组件测试
3.	端到端 (E2E，end-to-end) 测试
##	Vue 不能检测以下数组的变动：
当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
当你修改数组的长度时，例如：vm.items.length = newLength
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
##	由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：
-	如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的 property。
##	react vue对比
1.	运行时性能
	-	在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。PureComponent 和 shouldComponentUpdate
	-	在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染 shouldComponentUpdate
##	截取字符串
1.	substr() 方法可在**字符串**中截取从开始下标开始的指定数目的字符。
2.	string.substring(from, to) 方法从 from 位置截取到 to 位置，to 可选，没有设置时默认到末尾。end不支持负数
3.	slice() 方法可从已有的**数组和字符串**中返回选定的元素。
##	HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
-	http传输的数据都是未加密的，也就是明文的
-	网景是网景通信公司（Netscape Communications Corporation）的常用简称。网景通信公司曾经是一家美国的计算机服务公司，以其生产的同名网页浏览器Netscape Navigator而闻名。1998年11月，网景被美国在线（AOL）收购。
-	ssl
	-	SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。
##	osi17层模型
-	应用层：文件传输，常用协议HTTP，snmp,FTP ,

	表示层：数据格式化，代码转换，数据加密，//5层模型多的

	会话层：建立，解除会话	//5层模型多的

	传输层：提供端对端的接口，tcp,udp

	网络层：为数据包选择路由，IP，icmp

	数据链路层：传输有地址的帧

	物理层：二进制的数据形式在物理媒体上传输数据
##	数据库的基础操作
-	查询语句基础结构
	-	select xx,
		from xx
		where xx
-	去重操作（distinct）
	-	select distinct 属性名
		from 关系名
		where 条件
-	更名操作（as）
	-	select 属性 as 属性别名
		from 关系名
		where 条件
-	显示次序（order by）
	-	select 属性
		from 关系名
		where 条件
order by 属性 升序/降序；
-	属性值介于某个范围内
	-	select *
		from instructor2
		where 属性名 between ... and ... ;
-	分组聚集（group by）
	-	select dept_name,id,avg(salary)
		from instructor2
		group by dept_name;
-	having子句（出现group by时使用）
	-	select dept_name,avg(salary) as avg_salary
		from instructor2
		group by dept_name
		having avg(salary)>3000
-	in和 not in 操作符用于枚举集合。
	-	select *
		from instructor2
		where name not in('ai','ye','er');
-	集合的比较
-	some：至少比某一个要大
-	all：比所有的都大。
-	=some等价于in，<>some并不等价于not in。
-	<script type="math/tex" id="MathJax-Element-56"><></script>all等价于not in，=all不等价于in。
-	删除某些元组
	-	delete from instructor
		where dept_name='math';
-	插入一些元组
	-	insert into instructor2
		select id,name,dept_name,18000
		from student
		where dept_name='math';
-	更新元组
	update 关系名
	set 语句
	where 条件；
	update instructor2
	set salary=salary*1.05;
	where salary<7000;

##	单词
-	distinct		清楚的 
-	enumerate		枚举
-	paradise		天堂
-	navigator		航海家	
-	transform		转变
-	transition		过渡
-	cursor			单词
-	matrix			矩阵
-	pointer			指针
-	iterable		可迭代的
-	mutation		突变














##	export		export default暴露方式的对应的引入方式	
export {call} from '../src/array/call'
export {default as Stack} from '../src/da/stack'
##	api网关
-	API 网关负责请求路由、API组合和协议转换。
-	有了API网关后我们就可以将API接口组合起来，通过一次请求（getItemDetail）来获取需要的信息，这样可以极大的改善由于网络延时导致的差用户体验。
##	强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互，
	协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存，
##	应用层协议
-	http超文本传送协议	面向事务的应用层协议		使用了面向连接的tcp作为运输层协议	保证了数据的可靠性
	-	无连接	不安全	每次连接只处理一个请求
	-	无状态	协议对于事务的处理没有记录	服务器不知道客户端的状态
		-	于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
	-	支持C/S模式
-	smtp电子邮件协议	简单邮件传送协议	建立连接	邮件传送	连接释放
-	pop3邮件读取协议	接收电子邮件
-	telnet远程登录协议	实现远程登录功能
-	ftp文本传送协议
-	dns域名解析协议
-	ssh协议
##	网络层协议
-	ip协议式tcp/ip体系里面的网络层协议
	-	TCP/IP模型四层架构从下到上分别是链路层，网络层，传输层，应用层
	-	ip协议的可扩展性	实现大规模 异构网络的互通互联
	-	分割顶层网络应用和底层网络应用的耦合关系	利用两者的独立发展	ip值提供一种无连接	不可靠的数据包传输服务
-	ARP协议		地址解析协议		根据ip地址获取一个物理地址
	-	本机ARP缓存会保留请求过的资源的物理地址		下次请求的时候直接查询ARP缓存来节约资源
-	IGMP协议	互联网组管理协议	是TCP/IP的协议族的一个子协议	
	-	用于IP主机向任何一个直接相邻的路由器报告他们的组成员的情况
-	ICMP协议	英特尔控制报文协议	是TCP/IP协议族的一个子协议
	-	用于在IP主机	路由器之间传递控制信息 
##	BigInt类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数。使用 BigInt，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。BigInt 是通过在整数末尾附加 n 或调用构造函数来创建的。





##	算法题目的总结要点
-	BigInt   数据1000000007n		记得加上n
-	reduce对于空数组是不执行回调函数的
-	 let 和 const 关键字是在 ES6 中才新增的
-	var 声明的变量的作用域只能是全局或者整个函数块的。**走到哪里就会变到哪里**
-	而 let 声明的变量的作用域则是它当前所处代码块，即它的作用域既可以是全局或者整个函数块**变量的层级就是不会主动深入和淡出 最初是当前层级里面寻找响应的数据**
-	const 声明的是一个只读变量，声明之后不允许改变其值
-	关于链表知识的相关总结
-	let newList = new ListNode()//链表的 初始化过程 new ListNode(0)
	-	链表的常规操作是先取得链表的头索引	let head1 = new ListNode()		head1.next = head-->取得了头索引
		-	然后创建傀儡链表	来实现链表的转变的操作		var pre = head1==>pre是傀儡变化链表
	-	let newList1 = newList//链表的赋值 引用
		-	作用是表头索引的存储		重点就是赋值存储的表头不能忘记
		-	后面返回的是整个链表的数据		newList存储的是表头的索引		newList1存储的是链表的最后的数据next  为null
			-	renturn newLsit.next   
	-	链表的赋值
		-	newList.next = L
		-	newList.next = R
	-	链表指向下一个值
		-	newList = newList.next
-	 ***isSubStructure*** ：的主要作用是从当前两个根结点开始判断 Tree2 是否是 Tree1 的子结构，传入参数为 Tree1 中的任意一个非空结点和 Tree2 的根结点。 作用就是将 Tree1 拆分成若干个子树与 Tree2 进行逐个对比。
-	croakFrogs-->有固定的变量可以初始化-->记录数据用来比较--》for let of循环遍历相加记录--》循环一轮记录--》总结数据--》最终的数据特征
-	两个栈的操作完成队列--》this.stack1.push(value)-->stack1进入队列   注意是push 操作--》stack2出队列 	从stack1里面取出数据来进入stack2	  while(stack1.length){stack2.push(stack1.pop())}	//stack1里面的数据全部进入到了队列		stack2开始出队列直接pop()函数出队列	pop()进入pop()出去
-	实现栈的min函数--》    this.min_stack = [Infinity];--》this指针的应用--》函数的嵌套使用Math.min(this.min_Stack[this.min_Stack.length-1],x)选择数据的最小值
##	链表的使用
-	const canShu1 = l1?l1.val:0
-	prev & curr					head  &  tail
-	链表更新的时候记得就是new newNode(val)
-	Math.floor()
-	l1 = l1.next
-	链表指针的应用就是	prev	next	let newList = new ListNode(0,head)-->指向了head的链表的指针
-	链表指针的移动就是		prev = prev.next
-	链表元素的删除操作时
	-	prev.next = prev.next.next		//next指针直接就指向下一个next指针		就忽略了中间的一个指针值
-	链表头节点的保存形式
	-	newHead = head.next	-->head是一个空链表的情况
	-	newHead = head	--->newHead变成了一个傀儡链表
-	指向变化之前		提前保存要变化节点指向的下一个值	再来进行指向的转换		
	-	再用推移法		前继承后		后继承提前保存的数据
-	链表转换为数组		需要设置就是一个值的属性的next为null	所以需要递归遍历	
	-	const ds = (r) => {
				if(r == null)
				return;
			let n = r.next;
			r.next = null;
			res.push(r);
			ds(n);
			}
-	数组转换为链表就是		添加next属性		指向数组里面的下一个数据
	-	res[i].next = res[i+1];

##	object的使用
-	{[]}记录数据量的变化		例如用于字符串中特定字母的数据量
##	Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。
-	charAt(idnex) 方法可返回指定位置的字符。
-	用到了set里面的函数方法	let sbianli = new Set()
-	sbianli.has(s.charAt(index))	sbianli.delete(s.charAt(index))		sbianli.add(s.charAt(index))
-	while循环容易得出**一轮**循环的结果值	记得在循环结束的时候改变循环的条件
-	回文数用到了中间展开方法	回文数的长度分为奇数和偶数
##	数组的使用
-	在声明数组的时候	可以给数组的每一个元素设置为一个空的字符串	
-	用for of 函数遍历字符串			for(const c of s){str+=c}		c是字符串s里面的字符		遍历成功
-	经典		loc += isChange?1:-1		省略了if判断语句	三元运算符的正确使用方法
-	Math.pow(x,y)		x的y次方所得到的数据
-	JavaScript 位运算符		位运算符处理 32 位数。		~~(num)--》num从64位转换为了32位的数据
-	!   ~   |  ^(这是异或符号)异或就是说两者不同才为真					0101 ^ 0001	0100	4
-	charCodeAt() 方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
-	48---》57是unicode编码		str[index].charCodeAt(48)
-	JavaScript中的基本数据类Number是双精度浮点数，JavaScript 的 Number 类型使用 53 位表示小数位，10 位表示指数位，1 位表示符号位。因此指数部分最大值为 2^10=1024。因此对于 Number 的范围，应该是 2^1024， 也就是 1.7976931348623157e+308.
-	某个字符不可连续读取的操作
	-	 if(pre)return 0
        pre = s[index++]
	-	外层包裹了while循环	
-	**运算符表示的是阶乘的意思
-	循环里面的操作可能会导致原始数据的变化		那么就要用到的就是保存原始数据		方便后面的比较运算
-	matrix		arr.length获取行数		arr[0].length获取列数
-	用变量数据的时候先考虑数据**是否存在可用**
-	s.indexOf(x)返回属性出现位置的下标
-	newArray(len)//长度位len 的数组
-	arr.reverse()//翻转数组
-	arr.toString()数组转换为字符串
-	head  			tail 			left(0) 		right(len-1)	
-	for(const [value,symbol] of obj){}//**二维数组**的循环
-	使用map函数就直接就是可以get		set 		var myMap = **new Map()**
-	mySet.get(s[i])--->获取s[i]的value		mySet.set('I',1)		set就是设置一个属性和他的对应的值		get获取一个属性的值
-	数组关键操作----》去重
-	{[]}应用了键值对原理
-	let const var
-	二叉树的结构就是		val 	left right		二叉树转换为了队列		const queue = [root]//二叉树的头节点
	-	queue.length	队列的长度		
	-	忘记了赋值的时候的要点就是		.val属性才可以完成属性的获取和属性的赋值		题目的数据结构就是这样的
	-	活用位运算符的特性 	精简代码&&	|| ！
-	let arr1 = [],arr2 = []		arr2/
-	注意变量动态变化问题	for循环设置的值		循环条件值动态变化是会出现问题的
-	数组的反转函数reverse()		数组里面的元素顺序就发生了颠倒
-	二维数组去重的方法既是
-	const obj={};
//obj对象里面不存在就会添加		首先判断不存在!obj[item.toString()]-->变换位字符串好进行比较 添加的代码是obj[item.toString()]=item		forEach((item,index))   forEach函数的		遍历数组的依次应用
  res.forEach(item=>!obj[item.toString()] && (obj[item.toString()]=item));
  return Object.values(obj);
-	Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组		obj-->arr		{}-->[]
-	0^97结果是97		任何数据的运算结果就是97
-	数据的互补性质		N=m+n		m的下一个元素就是倒数第n个数据
-	pop()函数就是从数组最后一个数据删除并且返回数据		最后数据的长度时0
	-	return stack.length == 0 		是一个栈数据
-	bfs广度优先算法	
	-	可以用来解决走迷宫问题	找到最短路径
-	js的reduce函数
	-	 reduce() 对于空数组是不会执行回调函数的。
	-	reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
	-	array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
		-	initialValue就是传递给函数的初始值
		-	total是返回值
		-	currentValue是当前值
-	位运算符用错误		条件的明晰
-	slice(m,n)函数	截取的字符串长度就是m-n		计算字符串的长度的时候用到
#	树的操作
-	##	A树B树的前序遍历
-	var isSameTree = function(a,b){
	 if(a.val !== b.val){
        return false
    }
    return isSameTree(a.left,b.left)&&isSameTree(a.right,b.right)}//要求A树B树完全一样
-	**isSubStructure**(A.left,B)//A左子树开始查找B是否为其子树
-	判断为空条件的时候			root!-->return null
-	递归代码
	-	function(root){const left = a(root.right)	return root}//递归返回的是树的节点
-	二叉树的变化规则就是	适应2的指数级别的增长		指数级别的增长就是用**函数完成相应的动作**	
	-	头函数产生相应的两个相关的递归函数的数据
-	位运算符就是'>>'避免了js除法产生小数的问题
-	Array.fill(value, start, end)
		我们知道，Array.fill()方法可以替换或填充数组里的值。
		参数value为替换值，不可缺省。
		start表示开始替换的位置。
		end表示替换结束的位置。
		如果只有value，则默认替换全部值。
-	js二维数组的初始化
-	let arr = new Array(m).fill(0).map(()=>new Array(n).fill(0))
-	二维数组的数据赋值的操作const [m,n]=[0,nums.length-1]











##	href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。
	src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，
##	写 CSS 样式的时候，恐怕最头疼的就是各个浏览器下的兼容性问题，即 CSS hack，不同的浏览器对 CSS 的解析结果是不同的，因此会导致相同的 CSS 输出的页面效果不同，这就需要 CSS hack来解决浏览器局部的兼容性问题。
-	IE 条件注释 Hack：
	-	比如针对所有IE：<!–[if IE]><!–您的代码–><![endif]–>
##	prompt()方法用于显示一个带有提示信息，并且用户可以输入的对话框。
-	语法糖
	-	for循环就是一个语法糖
	-	语法糖的作用是让程序更加简洁，有更高的可读性。
##  axios请求拦截器
-   axios.interceptors.request.use(config=>
{
    config.headers.Authoriztion = window.sessionStorafe.getItem('token')
    return config
})
##	urlencoded
-	将字符串以url的形式进行编码
-	ASCII  -->    16进制     -->     %加上代码
-	ASCII 码一共规定了128个字符的编码	
-	将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式。
-	中ASCII码是-10544，对应的16进制是D6D0，那么urlencode编码结果是:%D6%D0
##	[].concat(...array)//直接就去除了一层数组的嵌套		concat()函数可以取出外层的嵌套
-	indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
##	 slice可操作数组和字符串，但substring和substr只能操作字符串，splice只能操作数组。
-	splice()函数的返回值是删除的元素
##	typeof
	typeof 'hello';  // 'string'
	typeof new String('hello');  // 'object'
##	浏览器端：
		cookie
		WebStorage(localStorage、sessionStorage)
		userData
		indexedDB
		服务器端：
		session
##	将题目 ["0x1", "0x2", "0x3"].map(parseInt) 分解一下，即为：[parseInt("0x1", 0), parseInt("0x2", 1), parseInt("0x3", 2)]，这里用到的点是：
parseInt 接收两个参数：(str, radix)
如果 radix = 0/undefined，或者 radix 未指定，则 parseInt 根据字符串前缀来判断转换进制
如果 radix < 2 且 radix != 0，或者 radix > 36，则 parseInt 返回 NaN
##	Sass 的安装需要 Ruby 环境，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less代码输出 css 到浏览器
##	JSON.parse() 方法用来解析JSON字符串，构造由**字符串描述的JavaScript值或对象**
##	JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串
-	行内元素和浮动元素发生重叠，边框、背景会显示在浮动元素之下，内容会显示在浮动元素之上
-	hover -> focus -> active
	悬停 -> 聚焦 -> 响应
##	0.2-0.1=0.1的原因是0.2是0.1的2倍，二进制乘2或者除2，左移或右移一位就行，所以0.2-0.1=0.1，但是0.8不是0.6的倍数，所以0.8-0.6！=0.2。
-	首先转换位二进制来运算就是	左移补零“<<”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。
-	右移补符号位	“>>”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。
-	“>>>”运算符执行无符号右移位运算 	无符号右移与有符号右移运算的结果是相同的。整数的三位运算符的计算和右移计算式一样的
-	对于负数来说，**无符号右移将使用 0**来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。
-	去除小数后面的操作可以是
	-	Math.floor()向下取整
	-	7/3 | 0		-->结果是2		

##	1 + - + + + - + 1 
-	1 + 0-0 +0 +0 + 0- 0+ 1
##	块级元素：块级元素对应display:block。
	行内元素：行内元素对应display:inline。
##	常见块级元素有：h1,h2,h3,h4,h5,h6,p,div,dl,dt,hr,ol,ul,li,form,pre,table,td,th；
	常见内联元素有：em,strong,span,button,input,label,code,select,img,textarea
##	带有 target="_blank" 的 a 标签被认为是有安全风险的，因为点击它后打开的新标签页面可以通过 window.opener.location = 来将来源页面跳转到钓鱼页面，不过给该 a 标签增加下面哪些属性就能阻止这一行为？	
-	rel='noopener'
-	rel='noreferrer'
##	对于一个向后台获取数据已经产生结果的promise:p1，再次调用p1.then，不会去重新发起请求获取数据
##	C 语言中没有闭包的概念
##	可能触发回流的css属性
##	浏览器使用流式布局模型 (Flow Based Layout)。
-	回流必将引起重绘，重绘不一定会引起回流。
-	当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
##	包含了主机名到IP 地址的映射关系的文件是
	/etc/hosts
##	浏览器可以构建http请求	但是不会解析http请求
##	http/2
-	解决了浏览器线头阻塞问题
##	SPA是客户端渲染的
##	transform
-	只对受控于盒模型的	元素有效
-	触发 GPU 硬件加速
-	可以通过matrix函数整合多种变形效果
##	sync是同步
##	UTF8中文3个字节，英文1个字节
##	let line = readline()
-	readline()直接读取一行的数据
-	().()
##	一维数组
-	var arr = readline().split(' ')
-	readline().split(' ')//字符串转换为了数组
##	二维数组
-	var arr[1] = readline().split(' ')
##	document.createElement('div')
-	onkeyup	--> keyCode --> event --> className --> appendChild --> onclick --> removeChild --> this.parentNode
-	text-align:center
##	JSON.parse(JSON.stringify(obj))
-	这种实现拷贝的方法就是不会拷贝obj的方法		属性是会被拷贝的
##	vue的nextTick函数
-	vue里面数据的改变不会直接在dom上面异步更新	而是将数据的改变记录在一个队列里面	然后一次性更新队列	然后就是更新DOM
-	nextTick函数就是更新DOM之后要执行的函数			vm.$el.msg
##	如何判断array   object
-	isArray()
	-	Array.isArray(a)//判断a是不是数组
-	var a = []
	-	a.constructor === Array//通过实例对象的构造函数判断是数组还是对象
-	instanceof
	-	a instanceof Array
	-	a instanceof Object
##	Symbol函数接受一个可选参数，可以添加一段文本描述即将创建的Symbol，这段属描述不可用于属性访问，但是建议每次创建Symbol时都添加一段描述，便于阅读代码和调试Symbol程序。
-	Symbol的描述被存储在内部的[[Description]]属性中，只有调用Symbol的toString()方法时才可以读取这个属性。在执行console.log的时候隐式的调用了toString()方法。
-	所有使用可计算属性名的地方，都可以使用Symbol。
##	Symbol共享体系
-	如果想创建一个可共享的Symbol，要使用Symbol.for()方法。它只接受一个参数，也就是即将创建的Symbol的字符串标识符，这个参数同样也被用作Symbol的描述：
	let uid = Symbol.for('uid');
	let object = {};
	object[ uid ] = '12345';
	console.log(object[uid]); //12345
	console.log(uid); //Symbol(uid)
-	还有一个与Symbol共享有关的特性：可以使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键
-	String()函数调用了uid.toString()方法，返回字符串类型的Symbol描述内容，但是，如果将Symbol与一个字符串拼接会导致程序抛出错误：
-	由于其他类型没有与Symbol逻辑等价的值，所以不能将Symbol强制转换为字符串或是数字类型
-	Symbol的辨识方法
Symbol是原始值，且ES6同时扩展了typeof操作符，支持返回“Symbol”，所以可以用typeof来检测变量是否为Symbol类型
##	function fun(n, o) {
  console.log(o);
  return {
    fun: function (m) {
      return fun(m, n);
    }
  };
}
-	闭包的应用返回会保存数据
##	三点运算符的应用
克隆数组：const arr = [...arr1]
合并数组：const arr = [...arr1, ...arr2]
拼接数组：arr.push(...arr1)
转换字符串为数组：[..."hello"]
-	Unicode 只是一个符号集
-	互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式
-	对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
-	对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。
##	可见，const定义的基本数据类型的变量确实不能修改，那引用数据类型呢？
-	对象是引用类型的，P中保存的仅是对象的指针，这就意味着，const仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的
##	js查询对象的属性
-	通过调用Object.keys()方法，获取对象上已定义(可枚举)的属性和方法
var keys= Object.keys(testObj);
　console.log(keys); // 输出 keys ["name", "age", "action"]
-	Object.getOwnPropertyNames():方法返回一个指定对象所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。
当然除了以上两个外，还有最原始的 for...in 循环(估计是平时循环用的多了，反倒是这个不怎么用!)
var keys =[];
　　for(var i in testObj){
    　　keys.push(i);
　　}
　　console.log(keys);   // keys ["name", "age", "action"]
##	以往的MVC模式是单向绑定，即Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新
##	MVVM模式
MVVM模式就是Model–View–ViewModel模式。它实现了View的变动，自动反映在 ViewModel，反之亦然。对于双向绑定的理解，就是用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。再说细点，就是在单向绑定的基础上给可输入元素input、textare等添加了change(input)事件,(change事件触发，View的状态就被更新了)来动态修改model。
-	实现数据的双向绑定：
（1）实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。
（2）实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，watcher可以收到属性的变化通知并执行相应的函数，从而更新视图。
（3）实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model，v-on等指令），如果节点存在v-model，v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者（Watcher）。
##	父组件一定在所有子组件结束mounted钩子之后，才会进入mounted钩子
-	父组件created钩子结束后，依次执行子组件的created钩子
#	面经
##	pwa-->progressive web app	渐进式web项目		一个pwa是一个网页
##	https
	-	需要ca证书	费用更高		ca是证书的签发机构
