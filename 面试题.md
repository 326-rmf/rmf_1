#	面试题
#	数组常用的方法有哪些	map filter-->不改原数组
	push	pop这些方法会直接修改原数组
1.	for in 枚举对象的时候除了可以枚举自身属性之外还会枚举原型的属性
for(var i in obj2){
	console.log(i);
}
hasOwnProperty-->验证是否是自身的属性
2.	var a = 3;
var b = 2;
//不借助第三方变量来交换ab的值
a = a + b;
b = a - b;
a = a - b;
3.	数组去重
ES5数组去重
indexOf()-->含有返回值  否则返回-1
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr(arr){
	let result = [];
	arr.forEach(function(item,index){
		//判断数组中是否包含原数组中的元素
		if(result.indexOf(item) === -1){
			result.push(item);
		}
	})
	return result;
}
ES6数组去重
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr2(arr){
	let set = new Set(arr);
	let result = [];
	for(let item of set){
		result.push(item);
	}-->记住用for of的时候也可以用...运算符
	return result;
}
以上代码可以简化一行代码
let uniqArr = arr => {...new Set(arr)} 
console.log(uniqArr(arr));
4. 手机号的正则		邮箱的正则
5. 	定义检测数据类型的方法
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
6.	实现深拷贝	对象		数组
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
function clone(target){
	let result;//最终加工拷贝完的数据
	//判断拷贝的数据是对象	数组	基本数据类型
	let targetType = checkoutType(target);
	if(targetType === 'Array'){
		result = [];
	}else if(targetType === 'Object'){
		result = {};
	}else{
		return target;
	}
	for(let item in target){
		//item：对象(key)	数组(index)
		let value = target[item];
		if(checkoutType(value) === 'Object' || 'Array'){
			result[item] = clone(value);//返回值有东西来接应
		}else{
			result[item] = value;
		}}
	return result;}
7.	a.x = a = {n:2}
-->分解动作
-->操作属性的优先级高于对象本身的赋值
a.x = {n:2}
a = {n:2}
8.	var x =10;
function fn(){
	console.log(x);
}
function show(f){
	var x = 20;
	f()
}
show(fn);//10-->因为fn()和show()函数是平级的那么找变量x的时候就会找到全局的x
9.	var obj = {
	fn2: function(){
		console.log(fn2)//obj是对象	对象没有作用域	那么当前function作用域里面没有fn2	就去全局作用域找	全局没有就直接报错	当然fn2改为this.fn2就可以正常输出了
	}
}
10.	function A(){}
	A.prototype.n = 1
	var b = new A()//这里b已经声明定义好了	那么__proto__的指向也就确定了	那么b.m就是undefined了	虽然后面A的prototype变了但是b的__proto__还是没有变化	A只是一个函数	不是一个对象
	A.prototype = {
		n:2,
		m:3
	}
	var c = new A()
	console.log(b.n,b.m,c.n,c.m)//1 undefined 2 3
11.	函数防抖		函数节流
-	函数防抖debounce	用定时器来实现
	-	延迟要执行的内容	若是延迟时间内	再次触发	重新计时	防止服务器压力过大	百度牛逼没有做防抖	是专业的搜索引擎
-	let id;
	inputNode.addEventListener('keyup',function(){
		let value = inputNode.value;
		if(id)
		clearTimeout(id);
		id = setTimeout(()=>{
			sendAjax(value);
		},200)//目前防抖好的就是200 300
	})
12. 函数节流	throttle
	-	设定一个特定的时间	让函数在特定时间只执行一次	不会频繁执行
		-	定时器  标识来实现
		let conLog = true;
		document.body.onscroll = function(){
			if(conLog)
			console.log(1);
			conLog = false;
			setTimeout(()=>{
				conLog = true;
			},2000)
		}
#	补充
-	var定义的变量没有块级作用域
-	创建作用域	有着变量	函数	this指针
-	obj是对象	对象没有作用域
-	使用闭包完了之后记得清除	设置为null
-	把建立空间的声明成为“定义”，把不需要建立存储空间的成为“声明”
-	在预解析时，变量只会声明，而函数既会声明也会定义
-	var fn = 10;                                       
	function fn() {                                    
    console.log('hello world');                               
	}                                                  
	fn();Js引擎预解析，发现fn变量声明
	Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字
	**Js引擎预解析将fn和函数体联系在一起**
	执行第一句代码，fn定义为10
	Js引擎已经对fn和函数体联系，不再执行fn联系操作
	执行fn()，因为fn是变量不是函数，所以抛出访问异常
-	在代码块中使用let定义的变量均为局部变量，let定义之前会发生暂时性死区，如果在let定义之前访问了let定义的变量，那么会发生访问错误
-	一个名字不可既代表函数又代表变量
-	new Person().getAge()//实例.getAge()
-	存放在变量中的函数不需要函数名。他们总是使用变量名调用。
#	js引擎是单线程运行的  那么定时器是为什么
##	阻塞渲染
1.	关于css阻塞		link引入的css会阻塞	因为css解析器是同步的
2.	style标签的样式：
-	得到ip地址	
-	cmd	-->ping www.baidu.com
13.	从用户输入url按下回车	期间经历了什么？
-	DNS解析		拿着字典的大爷(优先走缓存)
	-	拿着一个对应关系的服务器------域名------IP地址
	-	找浏览器DNS缓存解析域名
	-	找本机DNS缓存
	-	找路由器DNS缓存
	-	找运营商DNS缓存(80%DNS查询.到这一步结束)
	-	递归查询(查全球13台根DNS服务器)
-	进行TCP(协议)连接	三次握手(根据上一步请求回来的ip地址	去联系服务器)
	-	第一次握手	由浏览器发给服务器	你能“听见”吗？
	-	第二次握手	由服务器发个浏览器	能听见	你说吧
	-	第三次握手	由浏览器发个服务器	ok 我来说话
-	发送请求(请求报文)
-	得到响应(响应报文)
-	浏览器开始解析html
	-	预解析	将所有外部资源	发请求出去
	-	解析html	生成DOM树
	-	解析CSS		生成CSS树
	-	合并为一个render树
	-	js是否操作了DOM或样式
-	断开TCP连接		四次挥手
	-	第一次挥手	浏览器给服务器	东西接受完了	断开
	-	第二次挥手	服务器发给浏览器	还要东西没接收	等一会	我要验证数据的完整性	好了告诉你
	-	第三次挥手	服务器发给浏览器	接收完了	断开
	-	第四次挥手	浏览器发给服务器	好的	断开
14.	为什么握手要三次	挥手要四次
-	挥手之前 没进行数据的传输	确保握手就可以了
-	挥手之前	正在进行数据的传输	为了确保数据的完整性	必须多经历一次验证
15.	jsonp解决跨域	jsonp不是一种技术	而是智慧的结晶
-	原生jsonp的步骤
	-	提前定义好一个等待被调用的函数
	-	创建一个script节点	createElement
	-	为节点指定src地址	.src
	-	将节点插入页面	appendChild
	-	这些步骤jQuery库可以帮忙做		用一个键值对				dataType:'jsonp'
-	js里面的代码
-	let arr = [1,3,5,7,9]
	console.log(`${JSON.stringify(arr)}`)//[1,3,5,7,9]
-	利用script标签发请求不受同源策略的限制	所以不会产生跨域问题
-	套路	动态构建script节点	利用节点的src属性	发出get请求	从而绕开ajax引擎
-	弊端：
	-	只能解决get请求的跨域问题	
	-	后端必须配合前端
	app.get('/test',function(req,res){
		let {callback} = req.query
		let personArr = [{name:'peiqi',age:12},{name:'suxi',age:14}]
		res.send(`$(callback}($(JSON.stringify(personArr)})`)
	})
-	使用jsonp的精简版
-	$.getJSON('http://../test?callback=?',{name:'zhangsan',		age:12},function(data){console.log(data)})
16.	手写Promise
-	lib就是库的意思
-	自定义Promise模块
-	ES5来定义模块
-	(function (window) {
    const PENDING = 'pending'
    const RESOLVED = 'resolved'
    const REJECTED = 'rejected'
    //promise构造函数
    function Promise(excutor) {
        //代表Promise的实例对象
        const self = this
        //初始值是pending	未确定的
        this.status = PENDING
        //用来存储结果数据的属性	初始值是undefined
        this.data = undefined
        self.callbacks = []
        //调用excutor来启动异步任务
        //改变promise状态	改为成功	value
        function resolve(value) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = RESOLVED
            self.data = value
            //异步调用所有缓存的待执行的成功的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有成功的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onResolved(value)
                    })
                })

            }
        }
        //状态改为失败	reason
        function reject(reason) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = REJECTED
            self.data = reason
            //异步调用所有缓存的待执行的失败的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有失败的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onRejected(reason)
                    })
                })

            }
        }
        try {
            excutor(resolve, reject)
        } catch (error) {
            //执行器执行出错	promise变为失败
            reject(error)
        }


    }
    //指定成功/失败回调函数的方法
    //返回一个新的promise对象
    Promise.prototype.then = function (onResolved, onRejected) {
        const self = this
        //reason向下传递
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        //value向下传递
        onResolved = typeof onResolved === 'function' ? onResolved :  value => value
        return new Promise((resolve, reject) => {
            function handle(callback) {
                try {
                    const result = callback(self.data)
                    if (result instanceof Promise) {
                        result.then(
                            value => resolve(value),
                            reason => reject(reason)
                        )//简写result.then(resolve,reject)
                    } else {
                        resolve(result)
                    }
                }
                catch (error) {
                    reject(error)
                }
            }
            if (self.status === RESOLVED) {
                setTimeout(() => {
                    handle(onResolved)
                })

            } else if (self.status === REJECTED) {
                setTimeout(() => {
                    handle(onRejected)
                })
            } else {
                self.callbacks.push({
                    onResolved(value) {
                        handle(onResolved)
                    },
                    onRejected(reason) {
                        handle(onRejected)
                    }
                })
            }
        })
    }
    //指定失败回调函数的方法
    //catch是then 的语法糖
    Promise.prototype.catch = function (onRejected) {
        return this.then(undefined,onRejected)
    }
    //用来产生一个指定value的成功的promise
    Promise.resolve = function (value) {
        return new Promise((resolve,reject)=>{
            if(value instanceof Promise){
                //value是一个promise    结果由value决定
                value.then(resolve,reject)
            }else{
                resolve(value)
            }
        })
    }
    //用来产生一个指定reason的失败的promise
    Promise.reject = function (reason) {
        return new Promise((resolve,reject)=>{
            reject(reason)
        })
    }
    //返回一个promise	只有当数组中的所有promise都成功才成功	否则失败
    Promise.all = function (promises) {
    }
    //返回一个promise	由速度最快的完成的promise来决定
    Promise.resolve = function (promises) {
    }
    window.Promise = Promise
})(window)
17.	宏队列和微队列
setTimeout(() => {
	console.log("0")
},0)
new Promise((resolve,reject) => {
	console.log("1")
	resolve()
}).then(() => {
	console.log("2")//.then放进队列里面去
	new Promise((resolve,reject) => {
		console.log("3")
		resolve()
	}).then(() => {
		console.log("4")
	}).then(() => {
		console.log("5")
	})
}).then(() => {
		console.log("6")
	})
	new Promise((resolve,reject) => {
		console.log("7")
		resolve()
	}).then(() => {
		console.log("8")
	})
	宏队列 0
	微队列	2	8	4
	输出	1	7	2	3	8	4	5	6	0
18.	axios发ajax请求
-	function testGet() {
	axios({
		method:'GET',//默认是get方法
		url:'http://..',
		params:{
			id:2//指定get的query参数,params是对象
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
-	function testPost() {
	axios({
		method:'POST',//默认是get方法
		url:'http://..',
		//post请求用的是data来指定请求体参数,data是对象
		data:{
			id:2,
			title:'atguigu',
			author:'ddd'
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
19.	promise和xhr发送ajax请求
-	function axios({
	url,
	method='GET',
	params={},
	data = {}
})	
{
	//准备query参数	{a:1,b:2}==>a=1&b=2
	let queryStr = ''
	Object.keys(params).forEach(key => {
		queryStr += `${key}=${params[key]}&`
	})
	if(queryStr){//只有指定了params才做
	queryStr = queryStr.substring(0,queryStr.length-1)
	url += '?' + queryStr}
	return new Promise((resolve,reject) => {
		//创建xhr对象
		const xhr = new XMLHttpRequest()
		//绑定监听
		xhr.onreadystatechange = () => {
			//请求成功的时候调用resolve
			//请求失败的时候调用reject
			const {readyState,status,statusText} = xhr
			if(readysState!==4)return 
			if(status >= 200 && status < 300){
				//封装一个代表响应的对象
				const response =　{
					data: JSON.parse(xhr.response),
					status,
					statusText
				}
				//将promise对象改为成功
				resolve(response)
			}else{
				reject(new Error('request error status is '+  status))
			}
		}
		//初始化
		xhr.open(method,url,true)
		//发送请求
		if(method==='POST' || method === 'PUT'){
			xhr.setRequestHeader('Content-Type','application/json;charset=utf-8')
			xhr.send(JSON.stringify(data))
		}else{	
			xhr.send()
		}
	})
}	