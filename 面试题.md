#	面试题
#	数组常用的方法有哪些	map filter-->不改原数组
	push	pop这些方法会直接修改原数组
1.	for in 枚举对象的时候除了可以枚举自身属性之外还会枚举原型的属性
for(var i in obj2){
	console.log(i);
}
hasOwnProperty-->验证是否是自身的属性
2.	var a = 3;
var b = 2;
//不借助第三方变量来交换ab的值
a = a + b;
b = a - b;
a = a - b;
3.	数组去重
ES5数组去重
indexOf()-->含有返回值  否则返回-1
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr(arr){
	let result = [];
	arr.forEach(function(item,index){
		//判断数组中是否包含原数组中的元素
		if(result.indexOf(item) === -1){
			result.push(item);
		}
	})
	return result;
}
ES6数组去重
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr2(arr){
	let set = new Set(arr);
	let result = [];
	for(let item of set){
		result.push(item);
	}-->记住用for of的时候也可以用...运算符
	return result;
}
以上代码可以简化一行代码
let uniqArr = arr => {...new Set(arr)} 
console.log(uniqArr(arr));
-	**数组的常见应用**
	-	产生一个每个元素都比原来大10的数组
		-	const arr = [1,2,3,4,45,5]
			//map函数遍历实现操作
			arr.map((item,index)=>item+10)
	-	得到奇数的和	reduce是一个累加器
		-	reduce() 对于空数组是不会执行回调函数的。
		-	arr.reduce((preTotal,item,index)=>{
			preTotal + (item%2 === 1 ? item : 0)
		},0)
	-	得到值大于8且下标是偶数的元素组成的数组	用filter来过滤条件
		-	arr.filter((item,index)==>{index%2===0 && item>8})
	-	找到一个值大于8且下标是偶数位的元素		find元素
		-	arr.find((item,index)=>{index%2===0 && item>8})
	-	找出一个值大于8且下标是偶数位的元素的下标	findIndex下标
		-	arr.findIndex((item,index)=>{item>8 && index%2===0})
	-	判断下标是偶数的元素是否都是奇数	every()每个元素都满足条件		才返回true
		-	arr.every((item,index)=>{(index%2===0 && item%2===1) || index%2===1})//奇数不做限制	直接为真
	-	判断是否有下标为偶数的元素值为奇数	some()一个满足就返回true
		-	arr.some((item,index)=>{(index%2===0 && item%2===1) || index%2===1})
##	自己定义数组方法
-	**map函数自己定义**
-	Array.prototype.map = function(callback){
	const arr = []
	//遍历当前数组每一个元素	调用callback得到一个结果数据	添加arr
	for(let index = 0;index < this.length;index++){
		const element = this[index]
		const result = callback(element,index)
		arr.push(result)
	}
	return arr
}
-	**reduce自己定义	得到累加结果**
-	Array.prototype.reduce = function(callback,initValue){
	//结果为初始值
	let total = initValue
	for(let index = 0;index < this.length;index++){
		const element = this[index];
		total = callback(total,element,index)
	}
	return total
}
4. 手机号的正则	
常见的手机号正则有 /^1[3456789]\d{9}$/、/^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/。
手机号这东西更新速度还是比较快的，所以不能限制的太死。我这里只作前三位号段的限制
邮箱的正则
^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$
5. 	定义检测数据类型的方法
function checkoutType(target){
	return Object.prototype.toString.call(target).slice(8,-1);
}
6.	实现深拷贝	对象		数组
function checkoutType(target){
	return Object.prototype.toString.call(target).slice(8,-1);
}
function clone(target){
	let result;//最终加工拷贝完的数据
	//判断拷贝的数据是对象	数组	基本数据类型
	let targetType = checkoutType(target);
	if(targetType === 'Array'){
		result = [];
	}else if(targetType === 'Object'){
		result = {};
	}else{
		return target;
	}
	for(let item in target){
		//item：对象(key)	数组(index)
		let value = target[item];
		if(checkoutType(value) === 'Object' || 'Array'){
			result[item] = clone(value);//返回值有东西来接应
		}else{
			result[item] = value;
		}}
	return result;}
7.	a.x = a = {n:2}
-->分解动作
-->操作属性的优先级高于对象本身的赋值
a.x = {n:2}
a = {n:2}
8.	var x =10;
function fn(){
	console.log(x);
}
function show(f){
	var x = 20;
	f()
}
show(fn);//10-->因为fn()和show()函数是平级的那么找变量x的时候就会找到全局的x
9.	var obj = {
	fn2: function(){
		console.log(fn2)//obj是对象	对象没有作用域	那么当前function作用域里面没有fn2	就去全局作用域找	全局没有就直接报错	当然fn2改为this.fn2就可以正常输出了
	}
}
10.	function A(){}
	A.prototype.n = 1
	var b = new A()//这里b已经声明定义好了	那么__proto__的指向也就确定了	那么b.m就是undefined了	虽然后面A的prototype变了但是b的__proto__还是没有变化	A只是一个函数	不是一个对象
	A.prototype = {
		n:2,
		m:3
	}
	var c = new A()
	console.log(b.n,b.m,c.n,c.m)//1 undefined 2 3
11.	函数防抖		函数节流
-	事件频发触发造成的问题	
	-	onresize	mousemove等	触发频率高	造成浏览器性能问题
	-	后台发请求	频繁触发	对服务器造成压力
-	如何限制事件处理函数频繁调用
	-	函数节流
	-	函数防抖
-	函数防抖debounce	用定时器来实现	
	-	延迟要执行的内容	若是延迟时间内	再次触发	重新计时	防止服务器压力过大	百度牛逼没有做防抖	是专业的搜索引擎
-	let id;
	inputNode.addEventListener('keyup',function(){
		let value = inputNode.value;
		if(id)
		clearTimeout(id);
		id = setTimeout(()=>{
			sendAjax(value);
		},200)//目前防抖好的就是200 300
	})
12. 函数节流	throttle		lodash里面的函数_.throttle有可能最后一次会自动调用	可以设置参数最后一次默认不调用	第一次点击立即调用
	-	设定一个特定的时间	让函数在特定时间只执行一次	不会频繁执行
		-	定时器  标识来实现
		let conLog = true;
		document.body.onscroll = function(){
			if(conLog)
			console.log(1);
			conLog = false;
			setTimeout(()=>{
				conLog = true;
			},2000)
		}
	-	事件回调函数的this是发生事件的标签(event)
-	自己写的节流函数的工具函数	指定的时间周期	到点触发事件
	-	 function throttle(callback,delay){
        let pre = 0;//第一次直接调用执行
        return function(event){
            const currentTime = Date.now()
            if(currentTime - pre > delay){
                //时间到了一定的周期就会执行回调函数
                callback(this,event)
                //一个时间点的结束  是另一个时间点的开始
                pre = currentTime
            }
        }
    }
-	自己写的函数防抖	大于延迟时间	多次操作转化为了一次操作 触发防抖
	-	// 函数防抖     多次操作合并为一次操作
    function debounce(callback,delay){
        return function (event){
            //回调函数设置了一个定时器属性  用定时器属性就清除定时器
            if(callback.hasOwnProperty('timeoutId')){
                clearTimeout(callback.timeoutId)
            }
            //函数防抖用到了定时器  setTimeout
            //这个时候callback有了timeoutId的属性   只是会延迟时间执行  那么就实现了多次操作简化为了一次操作
            callback.timeoutId = setTimeout(()=>{
                callback.call(this,event)
                delete callback.timeoutId
            },delay)


        }
    }
-	函数防抖就是延迟大于延迟时间触发	函数节流就是指定时间周期触发
###	函数节流(throttle)场景
-	函数执行一次之后	只有大于执行周期的时候 才会执行第二次	适合多次事件按时间做平均分配触发
-	窗口调整(resize)
-	页面滚动(scroll)
-	DOM元素的拖拽功能实现(mousemove)
-	抢购点击(click)
###	函数防抖场景
-	多次连续快速事件		只做一次相应处理
-	输入框实时搜索联想(keyup/input)

#	补充
-	var定义的变量没有块级作用域
-	创建作用域	有着变量	函数	this指针
-	obj是对象	对象没有作用域
-	使用闭包完了之后记得清除	设置为null
-	把建立空间的声明称为“定义”，把不需要建立存储空间的称为“声明”
-	在预解析时，变量只会声明，而函数既会声明也会定义
-	var fn = 10;                                       
	function fn() {                                    
    console.log('hello world');                               
	}                                                  
	fn();Js引擎预解析，发现fn变量声明
	Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字
	**Js引擎预解析将fn和函数体联系在一起**
	执行第一句代码，fn定义为10
	Js引擎已经对fn和函数体联系，不再执行fn联系操作
	执行fn()，因为fn是变量不是函数，所以抛出访问异常
-	在代码块中使用let定义的变量均为局部变量，let定义之前会发生暂时性死区，如果在let定义之前访问了let定义的变量，那么会发生访问错误
-	一个名字不可既代表函数又代表变量
-	new Person().getAge()//实例.getAge()
-	存放在变量中的函数不需要函数名。他们总是使用变量名调用。
#	js引擎是单线程运行的  那么定时器是为什么
##	阻塞渲染
1.	关于css阻塞		link引入的css会阻塞	因为css解析器是同步的
2.	style标签的样式：
-	得到ip地址	
-	cmd	-->ping www.baidu.com
13.	从用户输入url按下回车	期间经历了什么？
-	DNS解析		拿着字典的大爷(优先走缓存)
	-	拿着一个对应关系的服务器------域名------IP地址
	-	找浏览器DNS缓存解析域名
	-	找本机DNS缓存
	-	找路由器DNS缓存
	-	找运营商DNS缓存(80%DNS查询.到这一步结束)
	-	递归查询(查全球13台根DNS服务器)
-	进行TCP(协议)连接	三次握手(根据上一步请求回来的ip地址	去联系服务器)
	-	第一次握手	由浏览器发给服务器	你能“听见”吗？
	-	第二次握手	由服务器发个浏览器	能听见	你说吧
	-	第三次握手	由浏览器发个服务器	ok 我来说话
-	发送请求(请求报文)
-	得到响应(响应报文)
-	报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。
-	浏览器开始解析html
	-	预解析	将所有外部资源	发请求出去
	-	解析html	生成DOM树
	-	解析CSS		生成CSS树
	-	合并为一个render树
	-	js是否操作了DOM或样式
-	断开TCP连接		四次挥手
	-	第一次挥手	浏览器给服务器	东西接受完了	断开
	-	第二次挥手	服务器发给浏览器	还要东西没接收	等一会	我要验证数据的完整性	好了告诉你
	-	第三次挥手	服务器发给浏览器	接收完了	断开
	-	第四次挥手	浏览器发给服务器	好的	断开
14.	为什么握手要三次	挥手要四次
-	挥手之前 没进行数据的传输	确保握手就可以了
-	挥手之前	正在进行数据的传输	为了确保数据的完整性	必须多经历一次验证
15.	jsonp解决跨域		不是一种技术	而是智慧的结晶
-	jsonp跨域模板
-	$.ajax({
    url: 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
     crossDomain: true,
//      success: function(data) {console.table(JSON.parse(data.data))},
     success: function(res) {console.log(JSON.parse(res.data).chinaAdd);},
    data: {}
});
-	原生jsonp的步骤
	-	提前定义好一个等待被调用的函数
	-	创建一个script节点	createElement
	-	为节点指定src地址	.src
	-	将节点插入页面	appendChild
	-	这些步骤jQuery库可以帮忙做		用一个键值对				dataType:'jsonp'
-	jsonp只适用于get请求
-	js里面的代码
-	let arr = [1,3,5,7,9]
	console.log(`${JSON.stringify(arr)}`)//[1,3,5,7,9]
-	利用script标签发请求不受同源策略的限制	所以不会产生跨域问题
-	套路	动态构建script节点	利用节点的src属性	发出get请求	从而绕开ajax引擎
-	弊端：
	-	只能解决get请求的跨域问题	
	-	后端必须配合前端
	app.get('/test',function(req,res){
		let {callback} = req.query
		let personArr = [{name:'peiqi',age:12},{name:'suxi',age:14}]
		res.send(`$(callback)($(JSON.stringify(personArr)})`)
	})
-	使用jsonp的精简版
-	$.getJSON('http://../test?callback=?',{name:'zhangsan',		age:12},function(data){console.log(data)})
16.	手写Promise
-	lib就是库的意思
-	自定义Promise模块
-	ES5来定义模块
-	(function (window) {
    const PENDING = 'pending'
    const RESOLVED = 'resolved'
    const REJECTED = 'rejected'
    //promise构造函数
    function Promise(excutor) {
        //代表Promise的实例对象
        const self = this
        //初始值是pending	未确定的
        this.status = PENDING
        //用来存储结果数据的属性	初始值是undefined
        this.data = undefined
        self.callbacks = []
        //调用excutor来启动异步任务
        //改变promise状态	改为成功	value
        function resolve(value) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = RESOLVED
            self.data = value
            //异步调用所有缓存的待执行的成功的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有成功的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onResolved(value)
                    })
                })

            }
        }
        //状态改为失败	reason
        function reject(reason) {
            //如果当前不是pending 直接结束
            if (self.status !== PENDING) return
            self.status = REJECTED
            self.data = reason
            //异步调用所有缓存的待执行的失败的回调函数
            if (self.callbacks.length > 0) {
                //启动一个定时器	执行所有失败的回调
                setTimeout(() => {
                    self.callbacks.forEach(cbsObj => {
                        cbsObj.onRejected(reason)
                    })
                })

            }
        }
        try {
            excutor(resolve, reject)
        } catch (error) {
            //执行器执行出错	promise变为失败
            reject(error)
        }


    }
    //指定成功/失败回调函数的方法
    //返回一个新的promise对象
    Promise.prototype.then = function (onResolved, onRejected) {
        const self = this
        //reason向下传递
        onRejected = typeof onRejected === 'function' ? onRejected : reason => {throw reason}
        //value向下传递
        onResolved = typeof onResolved === 'function' ? onResolved :  value => value
        return new Promise((resolve, reject) => {
            function handle(callback) {
                try {
                    const result = callback(self.data)
                    if (result instanceof Promise) {
                        result.then(
                            value => resolve(value),
                            reason => reject(reason)
                        )//简写result.then(resolve,reject)
                    } else {
                        resolve(result)
                    }
                }
                catch (error) {
                    reject(error)
                }
            }
            if (self.status === RESOLVED) {
                setTimeout(() => {
                    handle(onResolved)
                })

            } else if (self.status === REJECTED) {
                setTimeout(() => {
                    handle(onRejected)
                })
            } else {
                self.callbacks.push({
                    onResolved(value) {
                        handle(onResolved)
                    },
                    onRejected(reason) {
                        handle(onRejected)
                    }
                })
            }
        })
    }
    //指定失败回调函数的方法
    //catch是then 的语法糖
    Promise.prototype.catch = function (onRejected) {
        return this.then(undefined,onRejected)
    }
    //用来产生一个指定value的成功的promise
    Promise.resolve = function (value) {
        return new Promise((resolve,reject)=>{
            if(value instanceof Promise){
                //value是一个promise    结果由value决定
                value.then(resolve,reject)
            }else{
                resolve(value)
            }
        })
    }
    //用来产生一个指定reason的失败的promise
    Promise.reject = function (reason) {
        return new Promise((resolve,reject)=>{
            reject(reason)
        })
    }
    //返回一个promise	只有当数组中的所有promise都成功才成功	否则失败
    Promise.all = function (promises) {
    }
    //返回一个promise	由速度最快的完成的promise来决定
    Promise.resolve = function (promises) {
    }
    window.Promise = Promise
})(window)
17.	宏队列和微队列
-	promise是立即执行，创建就执行
setTimeout(() => {
	console.log("0")
},0)
new Promise((resolve,reject) => {
	console.log("1")
	resolve()
}).then(() => {
	console.log("2")//.then放进队列里面去
	new Promise((resolve,reject) => {
		console.log("3")
		resolve()
	}).then(() => {
		console.log("4")
	}).then(() => {
		console.log("5")
	})
}).then(() => {
		console.log("6")
	})
	new Promise((resolve,reject) => {
		console.log("7")
		resolve()
	}).then(() => {
		console.log("8")
	})
	宏队列 0
	微队列	2	8	4
	输出	1	7	2	3	8	4	5	6	0
18.	axios发ajax请求
-	function testGet() {
	axios({
		method:'GET',//默认是get方法
		url:'http://..',
		params:{
			id:2//指定get的query参数,params是对象
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
-	function testPost() {
	axios({
		method:'POST',//默认是get方法
		url:'http://..',
		//post请求用的是data来指定请求体参数,data是对象
		data:{
			id:2,
			title:'atguigu',
			author:'ddd'
		}
	}).then(
		response => {
			console.log(response.data,..)
		},
		error => {
			alert(error.message)
		}
	)
}
19.	promise和xhr发送ajax请求
-	function axios({
	url,
	method='GET',
	params={},
	data = {}
})	
{
	//准备query参数	{a:1,b:2}==>a=1&b=2
	let queryStr = ''
	Object.keys(params).forEach(key => {
		queryStr += `${key}=${params[key]}&`
	})
	if(queryStr){//只有指定了params才做
	queryStr = queryStr.substring(0,queryStr.length-1)
	url += '?' + queryStr}
	return new Promise((resolve,reject) => {
		//创建xhr对象
		const xhr = new XMLHttpRequest()
		//绑定监听
		xhr.onreadystatechange = () => {
			//请求成功的时候调用resolve
			//请求失败的时候调用reject
			const {readyState,status,statusText} = xhr
			if(readysState!==4)return 
			if(status >= 200 && status < 300){
				//封装一个代表响应的对象
				const response =　{
					data: JSON.parse(xhr.response),
					status,
					statusText
				}
				//将promise对象改为成功
				resolve(response)
			}else{
				reject(new Error('request error status is '+  status))
			}
		}
		//初始化
		xhr.open(method,url,true)
		//发送请求
		if(method==='POST' || method === 'PUT'){
			xhr.setRequestHeader('Content-Type','application/json;charset=utf-8')
			xhr.send(JSON.stringify(data))
		}else{	
			xhr.send()
		}
	})
}	
20.	axios请求拦截器
-	axios拦截器作用 axios 拦截器分为 请求拦截 和响应拦截两种。 主要作用：就会在每一次请求（响应）发起后，先一步将其拿到，处理里面的数据，比如在请求头中加入一些信息等 
	axios('/posts..').then()
-	let cancel//保存取消请求的函数
	//请求拦截器
	axios.interceptors.request.use(config => {
		if(cancel){
			cancel('强制取消')
		}
		config.cancelToken = new axios.CancelToken((c) => {
			cancel = c
		})
		return config//必须返回config
	})
	//添加响应拦截器
	axios.interceptors.response.use{
		response => {
			cancel = null
			return response
		},
		error => {
			if(axios.isCancel(error)){
			console.log('1111 取消请求',error.message)
		}else{
			cancel = null
			alert('请求错误:'+error.message)
		}
		return new Promise(() => {})
		}
	}
	function get1(){
		
	axios('/get..').then(
		response => {
		console.log('1111 onResolved',resposne.data)},
		error => {	
		console.log('1111 请求出错',error.message)
	}
	)
	}
	function cancelReq(){
		if(cancel)
		cancle('强制取消')
	}
21.	axios的instance封装
-	const instance = axios.create({
	baseURL:'http://localhost:3000'
})	
	//添加请求拦截器
	instance.interceptors.request.use((config) => {
		NProgress.start()
//对data参数数据进行处理	转换为urlencoded格式
if(config.data instanceof Object){
	config.data = Qs.stringify(config.data)
}
		return config
	})

	//添加响应拦截器
	instance.interceptors.response.use(
		response => {

			return response
		},
		error => {
			throw error
		}
	)
-	function getPosts(){
	instance.get('/post').then(
		response => {
			const result = response.data
			console.log(result)
		},
		error => {
			alert(error.message)
		}
	)
}
	function addPost(){
		instance.get('/post',{title:'newTitle',author:'newAuthor'}).then(
		response => {
			const result = response.data
			console.log(result)
		},
		error => {
			alert(error.message)
		}
	)
	}
22.	webpack练习
-	文件目录
-	src
	-	css
		-	index.css
		-	iconfont.css
	-	images
	-	font//存字体的
	-	js
		-	index.js
		-	module1.js
		-	module2.js
		-	module3.js
	-	json
		-	test.json
	-	index.html//不引入任何的css和js文件
	-	package.json
	-	webpack.config.js//是任务清单
-	dist //webpack执行之后的生成的文件


-	**module1.js内容**
-	/*
	ES6模块化
	-	暴露	分别暴露	统一暴露	默认暴露
	-	引入	import{}from'./xx/xx' 	import a from './xxx/xxx'
*/
-	export function sum(a,b){
	return a+b
}


-	**module2.js内容**
-	/*
	统一暴露
*/
-	function sub(a,b){
	return a-b
}
	export {sub}


-	**module3.js**
-	/*
	默认暴露
	暴露计算乘除法的两个函数
*/
-	export default{
	 mul(a,b){
	return a*b
},
	 div(a,b){
		return a/b
	}
}


-	**index.js**
-	/*
	汇总js模块
	该文件不同于学习模块化时	汇总js的文件
	该index.js是webpack的**入口文件**
	该文件可以汇总js css 图片	音频	视频	json
*/
-	import '@babel/polyfill'//全部新语法都转换	这时候要按需引入
	import {sum} from './module1'
	import {sub} from './module2'
	import module3 from './module3'
	import a from '../json/test.json'
	//在入口文件中引入样式	不用变量	
	import '../css/index.less'
	import '../css/iconfont.less'
	console.log(sum(1,2))
	console.log(sub(3,4))
	console.log(module3.mul(1,2))
	console.log(module3.div(1,2))
	console.log(a,typeof a)
	let myPromise = new Promise((resolve,reject)=>{
		resolve('haha')
	})
	myPromise.then((data)=>{
		console.log(data)
	})


-	**text.json**
-	/*

*/
-	{
	"name":"peiqi"
	"age":18
}


-	**webpack.config.js配置文件**
-	/**/
-	const {resolve} = require('path')
	const HtmlWebpackPlugin = require('html-webpack-plugin')
	module.exports = {
	entry:['./src/js/index.js','./src/index.html']//入口
	output: {
		path:resolve(__dirname,'../dist'),//输出路径
		filename:'./js/index.js'//输出文件名
		publicPath:'/'//所有资源在引入是的公共路径
	},//输出
	mode:'production',//配置工作模式
	module:{
		rules:[
			//解析less
		{//rules是一个数组	数组中的每一个对象都是一个loader
			test:/\.less$/,//匹配所有的less文件
			use:[
				//'style-loader',//用于在html文档中创建一个style标签	将样式塞进去
				MiniCssExtractPlugin.loader,
				'css-loader',//将less编译后的css转化为CommonJs的一个模块
				'less-loader'//less编译为css	但不生产单独的css文件		在内存里面
				],
		},
		//js语法检查
		{
			test:/\.js$/,//匹配所有的js文件
			exclude:/node_modules/,//除了node_modules文件夹
			enforce:"pre",//提前加载使用
			use:['eslint-loader']
		},
		//js语法转换方法一
		{
			test:/\.js$/,
			exclude:/node_modules/,
			use:{
				loader:"babel-loader",
				options:{
					presets:['@babel/preset-env']
				}
			}
		},
		//js语法转换方法二
		{
			test:/\.js$/,
			exclude:/node_modules/,
			use:{
				loader:"babel-loader",
				options:{
					presets:[['@babel/preset-env',{
						useBuiltIns:'usage',
						corejs:{version:3},
						targets:{
							"chrome":"58",
							"ie":"9"
						}
					}]],
					cacheDirectory:true//开启babel缓存	加快速度
				}
			}
		},
		//使用url-loader处理样式文件中的图片
		{
			test:/\.(png|jpg|gif)$/i,
			use:[
				{
					loader:'url-loader',
					options:{
						limit:8192,//图片会base64处理
						outputPath:'images',//文件输出路径
						publicPath:'images/',
						name:'[hash:5].[ext]'//修改文件名称
					}
				}
			]
		},
		//使用file-loader处理样式文件里的图片
		{
			test:/\.(png|jpg|gif)$/i,
			use:[
				{
					loader:'file-loader',
					options:{
						publicPath:'../dist/images',//决定图片的url路径
						outputPath:'images',//文件输出路径
						name:'[hash:5].[ext]'//修改文件名称
					}
				}
			]
		},
		//解析html里面的标签
		{
			test:'/\.(html)$/',
			use:{
				loader:'html-loader'
			}
		},
		//使用file-loader处理其他资源
		{
			test:/\.(eot|svg|woff|woff2|ttf|mp3|mp4|avi)$/,
		
					loader:'file-loader',
					options:{
						
						outputPath:'media',//文件输出路径
						name:'[hash:5].[ext]'//修改文件名称
					}
				
			
		},
		]
	},//用来解析less文件
	//配置插件
	plugins:[new HtmlWebpackPlugin({
		template:'./src/index.html',
		minify:{//用于压缩的
			
		}
	}),
	new MiniCssExtractPlugin(),//前面没有引入
	new CleanWebpackPlugin() 
	],
	devServer:{//自动的服务器
		open:true,//自动打开浏览器 
		compress:true,//启动gzip压缩	加快浏览器打开速度
		port:3000,//端口号
		hot:true
	},
	devtool:'cheap-module-eval-source-map'
}	


-	index.css文件设置样式


-	package.json文件里面可以设置短命令
-	"script":{
	"start":"webpack-dev-server --open"
}//可以用npm run start 或者	npm start	只有run可以省略

23.	虚拟DOM的key的作用
-	key是虚拟DOM对象的表示	在更新显示的key有重要的作用
-	当状态数据发生变化的时候	React会生成新的虚拟DOM 随后React将之前的旧虚拟DOM	与新的虚拟DOM进行diff比较	
	-	旧的虚拟DOM中找到了相同了key
		-	若虚拟DOM没变	直接使用原来的真实DOM 	不去刷新页面的真实DOM
		-	若虚拟DOM变了	先更新虚拟DOM	随后刷新页面的真实DOM
	-	旧的虚拟DOM没找到相同的key
		-	根据item数据创建新的虚拟DOM	随后渲染真实DOM到页面
-	index作为key的问题
	-	产生没有必要的真实DOM更新
	-	如果DOM界面还有输入类DOM	产生错误的真实DOM更新	界面有问题
-	使用数据的唯一标识作为key
24.	组件之间通信
-	props传递
	-	去点只能一层一层传递	兄弟组件之间传递要借助父组件
	-	一般数据是父组件向子组件
	-	函数数据是子组件向父组件
-	消息订阅发布机制
	-	实现库是pubsub-js
-	redux
	-	集中式管理多个组件共享的状态	
25.	mouse事件	常常用到的是enter leave		不常用到over  out
-	例如一个父子组件	鼠标移动接近父组件的时候触发over	接近父组件里面的子组件的时候触发out	离开子组件的时候再次触发over
26.	组件里面的data配置为什么只能是函数	而不是对象
-	是为了保证对各实例对象的data对象不是共用的	而是各自自己的data对象
27.	call  apply  bind 函数的认识
	function(a,b){
	this.xxx = 3;
	console.log(a,b,this)//this是window
	return a+b//返回值
}
-	console.log(xxx)//xxx是window是属性	可以直接输出
-	全局变量	函数	分别是window的属性	方法
-	所有函数都可以调用call()函数
-	call apply的作用就是调用函数
-	const obj = {m:0}
-	fn.call(obj,1,2)//call函数的变量输入是分别传入的	相当于执行了	obj.fn(1,2)
-	fn.apply(obj,[1,2])//apply函数的参数变量是数组传入的
-	fn.call(undefinded)//undefined  null  就是window
-	fn.bind(obj)(1,2)//bind返回一个新的函数	那么后面可以再加上括号就是正确的	调用新的函数	这可以通过新的函数去执行老的函数	fn调用bind函数	那么fn就变成了老的函数	fn.bind(obj)是新的函数		fn(1,2)再次自身调用是没有作用的	新函数的调用相当于老函数的执行	且this为bind 指定的第一参数的值
-	fn.bind(obj,5)//bind函数执行的时候可以加上参数	就是说可以指定将来将要调用函数的参数
28.	自定义实现 call   apply  bind函数
-	call函数的实现
	-	Function.prototype.call = function(obj,...args){
		<!-- console.log('call()') -->
			//this(...args)//执行了函数		记得传入参数
			//处理obj是undefined  null 的情况
			if(obj===undefined || obj===null){
				obj = window
			}
			//给obj添加一个方法	temFn:this
			obj.tempFn = this
			//调用obj的temFn方法		传入args参数 	
			const result = obj.temFn(...args)
			//删除obj的temFn方法
			delete obj.temFn
			//返回方法的返回值
			return result
		}
-	apply函数的实现		和call函数是一样的
	-	Function.prototype.apply = function(obj,args){
		console.log('call()')}
-	bind函数的实现
	-	Function.prototype.bind = function(obj,...args){
		//返回一个新函数
			return (...args2) =>{
				//调用原来的函数	且指定this为obj	参数列表为args		和   args2组成
				return this.call(obj,...args,...args2)
			}
		}
-	一个函数  方法的this是看具体什么东西调用	是window  或是某个实例化对象
29.	数组去重	
-	Array.from(new Set(array))	//Set函数就执行了数组去重的操作
-	[...new Set(array)]	//也实现了数组去重操作	
30.	数组合并	切片
-	 concat()数组合并	n个数组合并为一个新数组	原始数组不会改变	[[a]]	concat()函数只可以拆掉一层数组	也就是说做连接的时候[[a]]变为了[a]
	-	var new_arr = concat(arr,value1[,value2[,value3]])
-	slice()数组切片	返回一个有begin和end决定的原数组的浅拷贝	原数组不会被改变	例如 arr=[1,2,3,4,6,7,8] slice(arr,1,3)其中1代表起始点下标起始点是包含在结果里面的	3代表结束点下标结束点是不包含在结果里面的	最后的结果是	[2,3]	
-	-1代表倒数第一个
	-	var new_arr = slice(array,[begin[,end]])
-	判断是不是数组Array.isArray(value)
31.	数组扁平化	
-	取出嵌套(多维)中的所有元素放到一个新数组里面去
-	[1,[2,3[4,5]]]---->[1,2,3,4,5]
-	实现的方法
	-	方法一   递归  +	reduce()+concat()
		-	export function flatten(array){
			return reduce((array,(pre,item)=>{
				pre.push(!Array.isArray(item)?item:(flatten(item)))//递归层层拆卸	...负责拆分操作
				return pre
			},[])
		}//实际运行的...运算符会出错
	-	方法二	 ... + some() + concat()
		-	export function flatten1(array){
			if(!Array.isArray(item)){
					pre.push(item)
				}else{//contact()递归连接数组元素
				pre = concat(pre,flatten1(item))
				}
				return pre
		},[])}
	-	方法三
		-	function flatten2(array){
			arr = [].concat(...array)//直接就去除了一层数组的嵌套
			while(arr.some(item=>Array.isArray(item))){
				arr = [].concat(...arr)
			}
			return arr
		}
32.	数组的取真	分块
-	compact(array):返回数组中所有真值元素组成的新数组
	-	export default function compact(array){
	return array.filter(item => item)
	}
-	数组分块	chunk
	-	export function chunk(array,size=1){
		const bigArr = []
		let smallArr = []
		//如果是空数组	直接返回空数组
		if(array.length === 0){
			return bigArr
		}
		//处理size异常情况
		//size没有指定
		//if(size<1){size = 1}
		else if(size>array.length){size = array.length}
		array.forEach(item =>{
			//将小数组放到大数组里去	只能放一次
			if(smallArr.length === 0){
				bigArr.push(samllArr)
			}
			//将元素添加到小数组
			smallArr.push(item)
			//限制smallArr的最大长度是size
			if(smallArr.length === size){
				smallArr = []
			}
		})
		return bigArr
	}
33.	数组之间的差异部分	difference
-	difference(arr1,arr2)		得到arr1中arr2没有的数组
-	export function difference(arr1,arr2){
	//处理特殊情况
	if(arr1.length===0){
		return []
	}else if(arr2.length===0){
		return [...arr1]
	}
	//对数组进行过滤
	return filter(arr1,item => arr2.indexOf(item)===-1)
}
-	export function differences(arr1,...arrays){
	//处理特殊情况
	if(arr1.length===0){
		return []
	}else if(arrays.length===0){
		return [...arr1]
	}
	//对数组进行过滤
	return filter(arr1,item => {
		let result = true//假设当前元素在后面的所有数组都不存在
		arrays.forEach(array=>{
			const index = array.indexOf(item)
			if(index!==-1){
				result = false
				break//结束当前for循环	因为要求取得元素是不同的
			}
		})
		return result
	})
}
34.	合并数组	merge
-	export function mergeArray(array,...arrays){
	const result = [...array]//三点运算符就是遍历第一个数组的result
	arrays.forEach(itemArr =>{
		itemArr.forEach(item => {
			if(result.indexOf(item)===-1){
				result.push(item)
			}
		})
	})
	return result
}
35.	数组删除元素	pull(array,...values)	删除数组中元素和values相同的元素	原数组改变了	
-	export function pull(array,...values){
	const result = []
	array.forEach((item,index) => {
		if(values.indexOf(item)!==-1){
		//删除item
		array.splice(index,1)
		//将item添加到result数组	
		result.push(item)
		}
	})
	return result
}
36.	drop(array,count)	过滤掉array左边的count个元素
-	export function drop(array,count=1){
	if(array.length == 0){
		return []
	}
	if(count<1){
		count = 1
	}
	return array.filter((item,index) => index>=count)
}
37.	自定义new 工具函数
-	export function newInstance(Fn,...args){
	//创建一个空对象
	const obj = {}
	//调用Fn函数	且指定this是新创建对象
	const result = Fn.call(obj,...args)
	//如果Fn执行返回的是对象类型	最终结果就是这个对象
	if(result instanceof Object){
		return result
	}
	//让原型对象是空的object对象	且constructor属性为Fn
	//obj.__proto__ = {}
	//Fn函数生成	原型对象 构造函数就已经确定了	下面这句话不用创建{}	效率更高
	//将构造函数的显式原型属性赋值实例对象的隐式原型属性
	obj.__proto__ = Fn.prototype
	obj.__proto__.constructor = Fn
	//返回新建对象
	return obj
}
38.	自定义instanceof工具函数
-	export function myInstanceOf(obj,Type){
	//得到一个原型对象
	let  protoObj = obj.__proto__
	while (protoObj!==null){//存在原型对象
	//如果就是Type的原型对象	直接返回true
		if(protoObj===Type.prototype)
		{	
			return true
		}
		//取出下一个原型对象	并保存
		protoObj = protoObj.__proto__
	}
	//出了循环	说明类型不匹配
	return false
}
39.	对象合并	对象里面有同名属性	是合并	不是覆盖
-	export function mergeObject(...objs){
	const result = {}
	objs.forEach(obj=>{
		Object.keys(obj).forEach(key=>{
			const value = obj[key]
			//result里面没有key属性
			if(!result.hasOwnProperty(key)){
				result[key] = value
			}else{//result里面有key属性
			//对原值和value进行合并生成新的数组
			result[key] = concat([],result[key],value)
		}
		})
	})
	return result
}
40.	实现浅拷贝
-	export function clone1(target){
	if(target instanceof Array){
		//return [...target]
		//return target.slice()
		//return [].concat(target)
		//return Array.from(target)

	}else if(target !== null && typeof target === 'obj'){
		return {...target}
	}else{//如果不是数组或者对象	直接返回
		return target
	}
}
-	export function clone2(target){
	//被处理的目标是数组/对象
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		const cloneTarget = target instanceof Array? [] : {}
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = target[key]
			}
		}
		return target
	}else{
		return target
	}
 }
 41.	实现深拷贝
 -	大众乞丐版
	-	存在问题
	-	函数属性会丢失
	-	循环引用会出错
 -	export function deepClone1(target){
	 return JSON.parse(JSON.stringify(target))
 }
-	JSON数据存不了函数
-	面试基础版
-	解决了函数属性丢失		也就是方法丢失
-	export function deepClone2(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		const cloneTarget = target instanceof Array? [] : {}
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deepClone2(target[key])//对属性值进行递归处理
			}
		}
		return cloneTarget
	}else{
		return target
	}
 }
-	面试加强版
-	解决循环引用出错
-	解决思路
	-	同一个对象/数组只能被克隆一次
	-	创建克隆对象前：
		-	如果克隆对象已经存在	直接返回
	-	创建克隆对象后：
		-	将克隆产生的对象存起来
	-	缓存容器结构
		-	map	==>	key:target	value:cloneTarget	
-	export function deepClone3(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		//map里面存在对应的克隆对象	直接返回
		let cloneTarget = map.get(target)
		if(cloneTarget){//不对同一个对象进行多次clone
			return cloneTarget
		}
		const cloneTarget = target instanceof Array? [] : {}
		//保存到map容器
		map.set(target,cloneTarget)
		for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deepClone2(target[key],map)//对属性值进行递归处理
			}
		}
		return cloneTarget
	}else{
		return target
	}
 }
 -	面试最强版
 -	优化了数组的遍历	不用for in 而用forEach
 -	export function deeClone4(target){
	if(target instanceof Array || (target!==null && typeof target === 'object')){
		//map里面存在对应的克隆对象	直接返回
		let cloneTarget = map.get(target)
		if(cloneTarget){//不对同一个对象进行多次clone
			return cloneTarget
		}
		if(target instanceof Array){
			cloneTarget = []
			map.set(target,cloneTarget)
			target.forEach((item,index)=>{
				cloneTarget[index] = deeClone4(item,map)
			})
		}else{
			cloneTarget = {}
			map.set(target,cloneTarget)
			for(const key in target){
			if(target.hasOwnProperty(key)){
				cloneTarget[key] = deeClone4(target[key],map)//对属性值进行递归处理
			}
		}
		}
		
		return cloneTarget
	}else{
		return target
	}
 }
42.	字符串倒序	回文	截取
-	字符串倒序
-	export function	reverseString(str){
	return str.split('').reverse().join('')
}
-	字符串回文
-	export function palidrome(str){
	return str === reverseSring(str)
}
-	字符串截取
-	export function truncate(str,num){
	return str.length > num ? str.substring(0,num) + '...' : str
}
43.	手写继承
-	寄生组合式继承
-	构造函数中用call借用父类型构造函数	得到父类型的属性
-	指定新的原型对象	得到父类型原型对象上面的属性方法
-	寄生处理:去除原型对象上多余的属性就要借用中间者(指路人)
-	function Person(name,age){
	this.name = name
	this.age = age
}
Person.prototype.sayName = function(){
	console.log('my name',this.name)
}
function Student(name,age,price){
	//借用父类型的函数
	//this打电话给person来借用函数	
	Person.call(this,name,age)//相当于this.Person(name,age)
	this.price = price
}
//Student的原型对象指向了Person的实例
Student.prototype = new Person()
//Student构造器出现问题	就重新指向构造器
Student.prototype.constructor = Student
//Student的prototype多了Person的多余的name age属性
-	解决方案是
	-	create是一个工具函数	用来解决要调用Person的方法会解决携带Person上面多余属性的问题
	-	function create(proto){
		function Fn(){}
		Fn.prototype = proto
		return new Fn()
	}
	-	Student的原型对象指向了Fn函数   Fn的原型对象指向了Person的原型对象		那么Student就可以沿着原型链找到Person里面具有的方法	想用的属性	用Student原型对象指向Fn函数的方法去除了Student原型对象直接指向Person原型对象而造成的携带多余参数的问题		相当于找了一个**中间者解决多余携带**	让中间者指定可以用的东西的方向	要用的时候直接沿着路径去拿要用的东西	而不是一股脑全部携带很多东西		是个很明智的做法
	-	Student.prototype = create(Person.prototype)
44.	数据结构和算法
-	数据结构
	-	狭义
		-	数据的存储方式
	-	广义
		-	数据存储和算法
-	常见的数据结构
	-	数组	栈	队列	链表	树	集合	图	哈希表	堆
	-	这些可以自己写写
-	数组在一块连续的内存里面	这种说法式不完全正确的
-	栈应用	
	-	十进制转换为二进制
-	pop从栈顶取出开始删除	同时返回删除的元素
-	es6实现了集合类型	new set()	里面的元素不可以重复
-	希尔排序	快速排序比较重要	
	-	理解希尔排序	先了解插入排序
	-	计算出一个增量数组(折半)
		-	递减	最后一个必须是1
		-	distance = Math.floor(length/2)
		-	以当前增量对数组进行分组	分成多个小数组	对每个小数组	进行插入排序	每个小数组排序是交替进行的
-	es6语法可以用到		直接交换数组值的大小
	-	[arr[j+1],arr[j]] = [arr[j],arr[j+1]]
-	Math.floor()向下取整
-	Math.ceil()向上取整
-	[] == ![]	返回的是true	右边的[]是true	加上!是false	false和空数组转换为数值之间的比较	0==0	所有返回true
-	NaN和其他任何数值比		返回都是false	
-	任何数组	对象转换为boolean值	都是true 转换为数字的时候	看情况	空的数组	对象就是0
-	不同类型比较会装换为 数值之间的比较
##	盒模型
-	margin border padding content
##	js算法
-	数组的升序
	-	points.sort(function(a, b){return a - b});		  nums.sort((a, b) => a - b);
-	数组的降序
	-	points.sort(function(a, b){return b - a});
-	new一个新数组解决方法
-	没有排序的数组先排序	好计算
-	Math.max选出大的元素
##	append()尾插
-	pop()尾删除
##	两个数组实现一个队列		stack1进队列		stack2出队列
-	var CQueue = function() {
    this.stack1 = []
    this.stack2 = []
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
    this.stack1.push(value)
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
if(this.stack2.length)return stack2.pop()
while(this.stack1.length){
    this.stack2.push(this.stack1.pop())
}
return this.stack2.pop() || -1
};
##	水平居中
	行内元素: text-align: center
	块级元素: margin: 0 auto
	position:absolute +left:50%+ transform:translateX(-50%)	
	display:flex + justify-content: center
-	translateX是相对于元素本身来调整样式
##	垂直居中
	设置line-height 等于height
	position：absolute +top:50%+ transform:translateY(-50%)
	display:flex + align-items: center
	display:table+display:table-cell + vertical-align: middle;
##	rem是全部的长度都相对于根元素<html>元素
-	em
	子元素字体大小的em是相对于父元素字体大小
-	vw/vh
	Viewport Width 和 Viewport Height，视窗的宽度和高度
-	label标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验
##	遍历A节点的父节点下的所有子节点
-	var a = document.getElementById('a').parentNode.children
##	页面渲染
-	解析html源码	DOM树
-	解析css源码	CSSOM树
-	DOM + CSSOM	渲染树
-	页面绘制
##	cors
-	支持同源通信	跨域通信	fetch是实现cors通信		跨域资源共享
##	export和export default的区别？
	export default  xxx
	import xxx from './'

	export xxx
	import {xxx} from './'
##	left right 条件的变化  ex例子
##	数组首先判断有无顺序
## splice函数
-	arrayObject.splice(index,howmany,item1,.....,itemX)
-	 index	必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。		删除的位置
	howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。			删除的数量
	item1, ..., itemX	可选。向数组添加的新项目。						添加项目
##	 slice函数
	slice(index1[,index2])
	slice() 方法返回包含从数组对象中的第 index1～index2-1 之间的元素的数组。
##	多层的递归调用不可随便使用
-	成为了递归黑洞	时间损耗严重
##	new Array(n+1)
-	数的初始化
##	数组可以装对象	对象可以装数组	灵活运用
##	排序算法分析
-	不稳定
	-	选择排序	希尔排序	快速排序	堆排序
-	冒泡排序
	-	双重for循环		相邻两两比较	根据想要的排序顺序交换值的位置
-	选择排序
	-	依次找出最小索引	次次完成直到最后的排序完成 
-	插入排序		for + while
	-	 for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];//元素的移动
            preIndex--;//插入的位置变化
        }
        arr[preIndex+1] = current;
    }
-	希尔排序	相对于插入排序而言就是   	多了一个把数据分组
	-	希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列 for(for(for()))
	-	function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    while(gap < len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap > 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i < len; i++) {
            temp = arr[i];
            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    return arr;
}
-	归并排序
-	快速排序	分治法	基准数--》分区--》重复
-	void quick_sort(int s[], int l, int r)
{
    if (l < r)
    {
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
        int i = l, j = r, x = s[l];
        while (i < j)
        {
            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
                j--;  
            if(i < j) 
                s[i++] = s[j];
            
            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
                i++;  
            if(i < j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - 1); // 递归调用 
        quick_sort(s, i + 1, r);
    }
}
-	堆排序
	-	大顶堆	升序
	-	小顶堆	降序
-	计数排序
-	function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue+1),//数组来装数据
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;

    for (var i = 0; i < arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;//记录数据的产生的数量
    }

    for (var j = 0; j < bucketLen; j++) {
        while(bucket[j] > 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }

    return arr;
}
-	桶排序
-	桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
-	基数排序
-	MSD 从高位开始进行排序
-	LSD 从低位开始进行排序
-	var counter = [];
	function radixSort(arr, maxDigit) {
    var mod = 1;
    var dev = 1;
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
           var bucket = parseInt((arr[j] % mod) / dev);//数据具有怎样的特征
            if(counter[bucket]==null) {	//bucket是低位基数特征	相同低位基数是在同一个数组
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);//放入这个相应特征的数据
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;//一轮的基数排序结束	放入数组里面	接着进行下一轮直到结束
                }
          }
        }
    }
    return arr;
}
##	split(' ')空格分割字符串
##	join('20%')%20连接字符串标志
##	Math.ceil()向上取整	Math.floor()向下取整 Math.round()四舍五入
-	123e5-->12300000
-	pop() 方法用于删除数组的最后一个元素并返回删除的元素。-->let a = arr.pop()		push向数组里面放数据
##	unshift() 方法可把参数指定的元素依次添加到数组的前面，并返回添加元素后的数组长度。该方法必须至少有一个参数。
##	shift() 方法可删除数组第一个元素，并返回删除的元素。
##	sort() 方法用于按某种规则排序数组：当方法的参数为空时，按字典序（即元素的 Unicode 编码从小到大排序顺序）排序数组元素
##	 concat(数组1,…,数组n)
##	reverse() 方法可返回当前数组倒序排序形式
##	join(分隔符)
	join() 方法可将数组内各个元素按参数指定的分隔符连接成一个字符串。参数可以省略，省略参数时，分隔符默认为“逗号”。
##	forEach()
	forEach() 方法用于对数组的每个元素执行一次回调函数。	forEach(()=>{})
##	 filter()
	filter() 方法用于创建一个新的数组，其中的元素是指定数组中所有符合指定函数要求的元素。
-	var names1 = ["张山","张小天","李四","张萌萌","王宁","陈浩"];//原数组
	function checkName(name){ //定义回调函数，判断名字是否姓“张”
		if(name.indexOf("张") != -1){
				return true;
			}else{
				return false;
			}
	}
	var names2 = names1.filter(checkName);//对names1执行回调用函数，返回所有姓张的名字

	names2.forEach(function(item,index){//遍历names2数组中的每个元素
			console.log("names2[" + index + "] = " + item);
	});
##	map() 函数返回一个新数组，其中的元素为原始数组元素调用回调函数处理后的值。
-	var number = [1,2,3];//原数组
	var num=number.map(function(item){//对原数组中的每个元素*2，将值分别存储在num数组中
			return item * 2;
	});
##	传输控制协议（TCP）
-	用户数据报协议（UDP）
-	TCP/IP 和UDP最大的区别就是：TCP/IP是面向连接的，UDP是无连接的。
-	在实际的使用中，TCP主要应用于文件传输精确性相对要求较高且不是很紧急的情景，比如电子邮件、远程登录等,只能是一对一通信。有时在这些应用场景下即使丢失一两个字节也会造成不可挽回的错误，所以这些场景中一般都使用TCP传输协议。由于UDP可以提高传输效率，所以UDP被广泛应用于数据量大且精确性要求不高的数据传输，比如我们平常在网站上观看视频或者听音乐的时候应用的基本上都是UDP传输协议。
##	
-	计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。 指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。 而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。
##	在编译型语言中sum += i部分在循环运行时已经编译成了机器码，机器码将直接运行一千次。
	但是在解释型语言中，执行时会将sum += i转换（编译）一千次。
##	数组本来应该是一个连续的内存分配，但是在Javascript中不是连续分配的，而是类似哈希映射的方式存在的。
##	Javascript中出现了ArrayBuffer，它可以创建连续的内存供编程人员使用。	
##	ES6 Modules 相对于 CommonJS 的优势是什么？
1. 语言层级支持，无需引入第三方库
2. 统一的 API，不用再写 [shim](umdjs/umd · GitHub)
3. 清爽的语法（与 Python 相似），功能却很丰富：
##	使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据
// 扁平数据
[{
  name: '文本1',
  parent: null,
  id: 1,
}, {
  name: '文本2',
  id: 2,
  parent: 1
}, {
  name: '文本3',
  parent: 2,
  id: 3,
}]

// 树状数据
[{
  name: '文本1',
  id: 1,
  children: [{
    name: '文本2',
    id: 2,
    children: [{
      name: '文本3',
      id: 3
    }]
  }]
}]
###	编译程序的工作过程一般也可以划分为五个阶段：词法分析、语法分析、语义分析与中间代码产生、优化、目标代码生成。
##	IR中间代码
-	前端对源程序进行分析并产生中间表示，后端在此基础上生成目标代码。
-	 IR是由LLVM生成的中间代码，作用是优化编译器或VM，使优化后的机器代码执行效率更高，同时避免缓存编译后的二进制代码占用更多的内存。
##	 为什么会有交叉编译
交叉编译是在一个平台上生成另一个平台上的可执行代码。 同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。
之所以要有交叉编译，主要原因是：
Speed： 目标平台的运行速度往往比主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能
Capability： 整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间
Availability： 即使目标平台资源很充足，可以本地编译，但是第一个在目标平台上运行的本地编译器总需要通过交叉编译获得
Flexibility： 一个完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上
##	发布 / 订阅模式和观察者模式的区别是什么？
观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。
##	ioc它不是一种技术，它是一种设计思想。
传统式的对象创建，一般会用new，现在就是交给ioc容器所管理，意味着管理对象权力从调用者移除，反转给IOC容器管理，因此才命名为控制反转。
IOC相当于一个容器，管理所有对象。
##	这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。
##	这是一种采用函数式编程的基础部件进行响应式编程的编程范式。
对此FRP提出了三个原则：
单一数据源：一个应用永远只有唯一的数据源。
状态只读：状态是只读的，如果需要更改则发出通知，而不是交给外部进行修改，控制变化。
修改状态应由纯函数完成：因为纯函数没有副作用，所以状态的改变有迹可循。
##	抽象语法树（AST） 	
-	AST螺丝刀：recast
##	 沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源。
##	hash  路由模式的实现主要是基于下面几个特性：
URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；
##	history 路由模式的实现主要基于存在下面几个特性：
pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；
history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
##	.JavaScript 中的 const 数组可以进行 push 操作吗？为什么？
答：
可以，也可以进行splice()操作。
const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容
##	.JavaScript 中对象的属性描述符有哪些？分别有什么作用？
答：
Configurable(可配置性)
可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true
Enumerable(可枚举性)
可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true
Writable(可写性)
可写性决定是否可以修改属性的值，默认值为true
##	
首先callback不是异步API，它是早年JS异步编程实现的一种手段。
Promise是社区为了解决回调地狱的问题在ES6版本提出的一种解决方案；
Generator也是一种异步编程解决方案，它最大的特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注；
Async/await是 ES7 中提出的新的异步解决方案，async 是 Generator 函数的语法糖，async/await 的优点是代码清晰（不像使用 Promise 的时候需要写很多 then 的方法链）。async/await 不仅仅是 JS 的异步编程的一种方式，其可读性也接近于同步代码，让人更容易理解。
##	 Object.defineProperty(object, propertyname, descriptor)
object 必需。 要在其上添加或修改属性的对象。 这可能是一个本机 JavaScript对象（即用户定义的对象或内置对象）或 DOM 对象。
propertyname 必需。 一个包含属性名称的字符串。
descriptor 必需。 属性描述符。 它可以针对数据属性或访问器属性。
##	渐进式代表的含义是：没有多做职责之外的事。
你可以使用jsx开发，你也可以写template；你可以使用vue全家桶，你也可以把它做为某个业务的轻量视图，随你，不强求不主张。
##	单工数据传输只支持数据在一个方向上传输;
半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；
全双工数据通信允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。
##	Session
客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 **HTTP 无状态特性**，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。
##	Cookies
HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。
##	正向代理时，通常，客户端发送对目标服务器的请求，代理服务器在中间将请求转发给目标服务器，并将结果返回给客户端。
##	反向代理与正向代理恰好相反，代理服务位于服务器端。
对客户端来说，反向代理服务器就好像是目标服务器。反向代理服务器接收客户端发来的请求，然后将其分发到内网的服务器，并将内网服务器返回的结果返回给客户端
##	Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？
答：
可以。
HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。
##	 网关即Gateway，它是连接基于不同通信协议的网络的设备，使文件可以在这些网络之间传输。
##	因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性（具体细节二面再说）。
不过需要注意的是，即便使用 HTTPS 仍可能会被抓包，因为HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。
	-	https加重了服务端的负担，相比于http其需要更多的资源来支撑，同时也降低了用户的访问速度
##	Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。
##	每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。
##	比如 created 钩子可以用来在一个实例被创建之后执行的代码 
##	**因为箭头函数并没有 this**
##	created mounted updated destroyed  beforecreate beforemount beforeupdate beforedestroy
##	通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定
##	v-bind:href="url"  :href="url"
##	v-on:click="doSomething"  @click="doSomething"
##	不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖		computed属性会有缓存来解决多次不必要的计算的问题	computed会有缓存的影响	用到多次计算的时候在用到方法	函数方法会每次都执行	那么可能会有一些不必要的计算 这就是缓存vs方法的不同	
##	计算属性 vs 侦听属性
Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。watch	watch:{}
##	计算属性的 setter
计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：
-	 get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
##	`_.debounce` 是一个通过 Lodash 限制操作频率的函数。
 _.debounce(this.getAnswer, 500)
##	Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可	
##	你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：
	<div v-for="item of items"></div>
##	在 JavaScript 中， 迭代器 是一个对象，它定义一个序列，并在终止时可能返回一个返回值。
##	遍历对象
-	(value, name, index) in object
##	遍历数组
-	(item,index) in arr
##	当它们处于同一节点，v-for 的优先级比 v-if 更高
##	注意这里的 **is="todo-item"** attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 <ul> 元素内**只有 <li>** 元素会被看作有效内容。这样做实现的效果与 <todo-item> 相同，但是可以避开一些潜在的浏览器解析错误。
 `<li is="todo-item"></li>`
##	event.target.tagName
##	有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法	template里面传参是$event
-	warn: function (message, event) {}
##	Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。
.stop
.prevent
.capture
.self
.once
.passive
-	v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。
##	v-on:keyup.enter="submit"
-	<!-- Alt + C -->
<input v-on:keyup.alt.67="clear">
<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->
<button v-on:click.ctrl="onClick">A</button>
<!-- 有且只有 Ctrl 被按下的时候才触发 -->
<button v-on:click.ctrl.exact="onCtrlClick">A</button>
<!-- 没有任何系统修饰符被按下的时候才触发 -->
`<button v-on:click.exact="onClick">A</button>`

##	如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：
<input v-model.number="age" type="number">

##	data 必须是一个函数
当我们定义这个 <button-counter> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：
data: {
  count: 0
}
取而代之的是，**一个组件的 data 选项必须是一个函数**，因此每个实例可以维护一份被返回对象的独立的拷贝：
##	ES6 Set()去重
Set。它类似于数组，但是成员的值都是唯一的
通过add()方法向 Set 结构加入成员
-	arr.forEach(item=>{
	set2.add(item)
})
##	事务的四大特性主要是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
-	原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。
-	一致性（Consistency）
官网上事务一致性的概念是：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
-	隔离性（Isolation）
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
-	持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。
##	模板字符串		``
-	const a = 20;
const b = 10;
const c = "JavaScript";
const str = `My age is ${a+b} and I love ${c}`;
##	原始字符串是一个普通字符串，其中不会解释转义字符。我们可以使用模板字符串创建原始字符串。我们可以使用String.raw来获取原始字符串，代码如下：
let s = String.raw `xy\n${ 1 + 1 }z`;
##	post: {
  id: 1,
  title: 'My Journey with Vue'
}
<blog-post v-bind="post"></blog-post>

##	js中symbol对象 es6引入了一种新的基本数据类型symbol，表示独一无二的值，最大的用法是用来定义对象的唯一属性名，
##	clear 只对块级元素生效。block
##	将 <slot> 元素作为承载分发内容的出口。
##	这也是依赖注入的用武之地，它用到了两个新的实例选项：provide 和 inject。
-	provide: function () {
  return {
    getMap: this.getMap
  }
}
-	inject: ['getMap']
##	当 inline-template 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。
##	另一个定义模板的方式是在一个 <script> 元素中，并为其带上text/x-template 的类型，然后通过一个 id 将模板引用过去。例如：
<script type="text/x-template" id="hello-world-template">
  <p>Hello hello hello</p>
</script>
##	渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来
-	 <div v-once></div>
##	v-show 的功能是条件展示，如果条件为 true 就显示，否则就隐藏。v-show 的显示和隐藏主要是更改 CSS 的 display 属性，并不会重新渲染或删除元素。display:none			
	-	v-show 无论初始值为 true 还是 false 元素都会被渲染，显示和隐藏也只是更改 display。比较适合用在一些需要平凡切换显示和隐藏的场景，例如对话框之类的。
##	v-if 的功能是条件渲染，只有条件为 true 才会渲染。如果 v-if 的初始值为 false ，元素就不会渲染。如果中途改变 v-if 的值为 false ，元素会被删除。
	-	因为 v-if 会重新渲染或删除元素，而且如果初始条件为 false 就不会渲染。比较适合用在一些不需要平凡切换或内容较多的元素。例如不同页面之间切换就比较适合用 v-if。
##	toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。
##	SVG 意为可缩放矢量图形（Scalable Vector Graphics）。
-	SVG 使用 XML 格式定义图像。
##	混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。
-	var Component = Vue.extend({
  mixins: [myMixin]
})
-	**混入对象的钩子将在组件自身钩子之前调用。**
-	混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。
	-	Vue.mixin({})
##	自定义指令		Vue.directive('xx',{})	v-xx
-	// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
-	directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
##	自定义的 指令
	-	<div v-demo="{ color: 'white', text: 'hello!' }"></div>
	-	Vue.directive('demo', function (el, binding) {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text)  // => "hello!"
})
	-	binding是数据写指令的时候可以对象传入			传入键值对
##	服务端代码
-	1.node里面express
	-	let express = require('express')
		const app = express()
		app.listen('3000',()=>{
			console.log('server ok')
		})
-	2.原始的http请求
	-	let http = require('http')
		let qs = require('queryString')
		let server = http.createServer(function(req,res){

		})
		server.lesten('3000',(err)=>{
			if(!err){
				console.log('server ok')
			}else{
				console.log('server wrong')
			}

		})
##	VNode 必须唯一
-	组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：
-	render: function (createElement) {
  var myParagraphVNode = createElement('p', 'hi')}
-	createElement		createElement('p','h1')没有满足元素唯一的条件
##	vue 当中的 @click.native
-	.native--侦听组件根元素上的原生事件
	作用： 给组件绑定原生事件
-	@click是我们在vue开发中经常用到的事件绑定，而@实际上是 v-on 的简写，而 v-on 则是对 vue 的事件体系封装之后的 API接口
也就是说，在处理DOM原生事件的场合中需要添加额外的标识符
##	使用组件的流程
-	引入		声明 	使用
##	关注点分离
-	标识 封装	操作关注点的能力	处理复杂性的一个原则	关注点分离就是让程序设计思路清晰	而不是错综复杂能以理解的
##	测试
1.	单元测试
2. 	组件测试
3.	端到端 (E2E，end-to-end) 测试
##	Vue 不能检测以下数组的变动：
当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
当你修改数组的长度时，例如：vm.items.length = newLength
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
##	由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：
-	如果你未在 data 选项中声明 message，Vue 将警告你渲染函数正在试图访问不存在的 property。
##	react vue对比
1.	运行时性能
	-	在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。PureComponent 和 shouldComponentUpdate
	-	在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染 shouldComponentUpdate
##	截取字符串
1.	substr() 方法可在**字符串**中截取从开始下标开始的指定数目的字符。
2.	string.substring(from, to) 方法从 from 位置截取到 to 位置，to 可选，没有设置时默认到末尾。end不支持负数
3.	slice() 方法可从已有的**数组和字符串**中返回选定的元素。
##	HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
-	http传输的数据都是未加密的，也就是明文的
-	网景是网景通信公司（Netscape Communications Corporation）的常用简称。网景通信公司曾经是一家美国的计算机服务公司，以其生产的同名网页浏览器Netscape Navigator而闻名。1998年11月，网景被美国在线（AOL）收购。
-	ssl
	-	SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。
##	osi17层模型
-	应用层：文件传输，常用协议HTTP，snmp,FTP ,

	表示层：数据格式化，代码转换，数据加密，//5层模型多的

	会话层：建立，解除会话	//5层模型多的

	传输层：提供端对端的接口，tcp,udp

	网络层：为数据包选择路由，IP，icmp

	数据链路层：传输有地址的帧

	物理层：二进制的数据形式在物理媒体上传输数据
##	数据库的基础操作
-	查询语句基础结构
	-	select xx,
		from xx
		where xx
-	去重操作（distinct）
	-	select distinct 属性名
		from 关系名
		where 条件
-	更名操作（as）
	-	select 属性 as 属性别名
		from 关系名
		where 条件
-	显示次序（order by）
	-	select 属性
		from 关系名
		where 条件
order by 属性 升序/降序；
-	属性值介于某个范围内
	-	select *
		from instructor2
		where 属性名 between ... and ... ;
-	分组聚集（group by）
	-	select dept_name,id,avg(salary)
		from instructor2
		group by dept_name;
-	having子句（出现group by时使用）
	-	select dept_name,avg(salary) as avg_salary
		from instructor2
		group by dept_name
		having avg(salary)>3000
-	in和 not in 操作符用于枚举集合。
	-	select *
		from instructor2
		where name not in('ai','ye','er');
-	集合的比较
-	some：至少比某一个要大
-	all：比所有的都大。
-	=some等价于in，<>some并不等价于not in。
-	<script type="math/tex" id="MathJax-Element-56"><></script>all等价于not in，=all不等价于in。
-	删除某些元组
	-	delete from instructor
		where dept_name='math';
-	插入一些元组
	-	insert into instructor2
		select id,name,dept_name,18000
		from student
		where dept_name='math';
-	更新元组
	update 关系名
	set 语句
	where 条件；
	update instructor2
	set salary=salary*1.05;
	where salary<7000;

##	单词
-	distinct		清楚的 
-	enumerate		枚举
-	paradise		天堂



##	export		export default暴露方式的对应的引入方式	
export {call} from '../src/array/call'
export {default as Stack} from '../src/da/stack'
##	api网关
-	API 网关负责请求路由、API组合和协议转换。
-	有了API网关后我们就可以将API接口组合起来，通过一次请求（getItemDetail）来获取需要的信息，这样可以极大的改善由于网络延时导致的差用户体验。
##	强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互，
	协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存，
##	应用层协议
-	http超文本传送协议	面向事务的应用层协议		使用了面向连接的tcp作为运输层协议	保证了数据的可靠性
	-	无连接	不安全	每次连接只处理一个请求
	-	无状态	协议对于事务的处理没有记录	服务器不知道客户端的状态
		-	于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 Cookie，而另一个则是 Session。
	-	支持C/S模式
-	smtp电子邮件协议	简单邮件传送协议	建立连接	邮件传送	连接释放
-	pop3邮件读取协议	接收电子邮件
-	telnet远程登录协议	实现远程登录功能
-	ftp文本传送协议
-	dns域名解析协议
##	网络层协议
-	ip协议式tcp/ip体系里面的网络层协议
	-	TCP/IP模型四层架构从下到上分别是链路层，网络层，传输层，应用层
	-	ip协议的可扩展性	实现大规模 异构网络的互通互联
	-	分割顶层网络应用和底层网络应用的耦合关系	利用两者的独立发展	ip值提供一种无连接	不可靠的数据包传输服务
-	ARP协议		地址解析协议		根据ip地址获取一个物理地址
	-	本机ARP缓存会保留请求过的资源的物理地址		下次请求的时候直接查询ARP缓存来节约资源
-	IGMP协议	互联网组管理协议	是TCP/IP的协议族的一个子协议	
	-	用于IP主机向任何一个直接相邻的路由器报告他们的组成员的情况
-	ICMP协议	英特尔控制报文协议	是TCP/IP协议族的一个子协议
	-	用于在IP主机	路由器之间传递控制信息 
##	BigInt类型是 JavaScript 中的一个基础的数值类型，可以用任意精度表示整数。使用 BigInt，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。BigInt 是通过在整数末尾附加 n 或调用构造函数来创建的。





##	算法题目的总结要点
-	BigInt   数据1000000007n		记得加上n
-	reduce对于空数组是不执行回调函数的
-	 let 和 const 关键字是在 ES6 中才新增的
-	var 声明的变量的作用域只能是全局或者整个函数块的。**走到哪里就会变到哪里**
-	而 let 声明的变量的作用域则是它当前所处代码块，即它的作用域既可以是全局或者整个函数块**变量的层级就是不会主动深入和淡出 最初是当前层级里面寻找响应的数据**
-	const 声明的是一个只读变量，声明之后不允许改变其值
-	关于链表知识的相关总结
-	let newList = new ListNode()//链表的 初始化过程 
	-	let newList1 = newList//链表的赋值 引用
		-	作用是表头索引的存储		重点就是赋值存储的表头不能忘记
		-	后面返回的是整个链表的数据		newList存储的是表头的索引		newList1存储的是链表的最后的数据next  为null
			-	renturn newLsit.next   
	-	链表的赋值
		-	newList.next = L
		-	newList.next = R
	-	链表指向下一个值
		-	newList = newList.next
-	 ***isSubStructure*** ：的主要作用是从当前两个根结点开始判断 Tree2 是否是 Tree1 的子结构，传入参数为 Tree1 中的任意一个非空结点和 Tree2 的根结点。 作用就是将 Tree1 拆分成若干个子树与 Tree2 进行逐个对比。
##	href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。
	src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，
##	写 CSS 样式的时候，恐怕最头疼的就是各个浏览器下的兼容性问题，即 CSS hack，不同的浏览器对 CSS 的解析结果是不同的，因此会导致相同的 CSS 输出的页面效果不同，这就需要 CSS hack来解决浏览器局部的兼容性问题。
-	IE 条件注释 Hack：
	-	比如针对所有IE：<!–[if IE]><!–您的代码–><![endif]–>
##	prompt()方法用于显示一个带有提示信息，并且用户可以输入的对话框。
-	语法糖
	-	for循环就是一个语法糖
	-	语法糖的作用是让程序更加简洁，有更高的可读性。
##  axios请求拦截器
-   axios.interceptors.request.use(config=>
{
    config.headers.Authoriztion = window.sessionStorafe.getItem('token')
    return config
})
##	urlencoded
-	将字符串以url的形式进行编码
-	ASCII  -->    16     -->     %加上代码
-	将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式。
-	中ASCII码是-10544，对应的16进制是D6D0，那么urlencode编码结果是:%D6%D0
##	[].concat(...array)//直接就去除了一层数组的嵌套		concat()函数可以取出外层的嵌套
-	indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
##	 slice可操作数组和字符串，但substring和substr只能操作字符串，splice只能操作数组。



