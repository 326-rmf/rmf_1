#	面试题
#	数组常用的方法有哪些	map filter-->不改原数组
	push	pop这些方法会直接修改原数组
1.	for in 枚举对象的时候除了可以枚举自身属性之外还会枚举原型的属性
for(var i in obj2){
	console.log(i);
}
hasOwnProperty-->验证是否是自身的属性
2.	var a = 3;
var b = 2;
//不借助第三方变量来交换ab的值
a = a + b;
b = a - b;
a = a - b;
3.	数组去重
ES5数组去重
indexOf()-->含有返回值  否则返回-1
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr(arr){
	let result = [];
	arr.forEach(function(item,index){
		//判断数组中是否包含原数组中的元素
		if(result.indexOf(item) === -1){
			result.push(item);
		}
	})
	return result;
}
ES6数组去重
let arr = [1,2,3,4,5,6,1,2,3];
function uniqArr2(arr){
	let set = new Set(arr);
	let result = [];
	for(let item of set){
		result.push(item);
	}-->记住用for of的时候也可以用...运算符
	return result;
}
以上代码可以简化一行代码
let uniqArr = arr => {...new Set(arr)} 
console.log(uniqArr(arr));
4. 手机号的正则		邮箱的正则
5. 	定义检测数据类型的方法
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
6.	实现深拷贝	对象		数组
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
function clone(target){
	let result;//最终加工拷贝完的数据
	//判断拷贝的数据是对象	数组	基本数据类型
	let targetType = checkoutType(target);
	if(targetType === 'Array'){
		result = [];
	}else if(targetType === 'Object'){
		result = {};
	}else{
		return target;
	}
	for(let item in target){
		//item：对象(key)	数组(index)
		let value = target[item];
		if(checkoutType(value) === 'Object' || 'Array'){
			result[item] = clone(value);//返回值有东西来接应
		}else{
			result[item] = value;
		}}
	return result;}
7.	a.x = a = {n:2}
-->分解动作
-->操作属性的优先级高于对象本身的赋值
a.x = {n:2}
a = {n:2}
8.	var x =10;
function fn(){
	console.log(x);
}
function show(f){
	var x = 20;
	f()
}
show(fn);//10-->因为fn()和show()函数是平级的那么找变量x的时候就会找到全局的x
9.	var obj = {
	fn2: function(){
		console.log(fn2)//obj是对象	对象没有作用域	那么当前function作用域里面没有fn2	就去全局作用域找	全局没有就直接报错	当然fn2改为this.fn2就可以正常输出了
	}
}
10.	function A(){}
	A.prototype.n = 1
	var b = new A()//这里b已经声明定义好了	那么__proto__的指向也就确定了	那么b.m就是undefined了	虽然后面A的prototype变了但是b的__proto__还是没有变化	A只是一个函数	不是一个对象
	A.prototype = {
		n:2,
		m:3
	}
	var c = new A()
	console.log(b.n,b.m,c.n,c.m)//1 undefined 2 3
#	补充
-	var定义的变量没有块级作用域
-	创建作用域	有着变量	函数	this指针
-	obj是对象	对象没有作用域
-	使用闭包完了之后记得清除	设置为null
-	把建立空间的声明成为“定义”，把不需要建立存储空间的成为“声明”
-	在预解析时，变量只会声明，而函数既会声明也会定义
-	var fn = 10;                                       
	function fn() {                                    
    console.log('hello world');                               
	}                                                  
	fn();Js引擎预解析，发现fn变量声明
	Js引擎预解析，发现fn函数声明，因为fn名字已经存在，js引擎不再记录函数名字
	**Js引擎预解析将fn和函数体联系在一起**
	执行第一句代码，fn定义为10
	Js引擎已经对fn和函数体联系，不再执行fn联系操作
	执行fn()，因为fn是变量不是函数，所以抛出访问异常
-	在代码块中使用let定义的变量均为局部变量，let定义之前会发生暂时性死区，如果在let定义之前访问了let定义的变量，那么会发生访问错误
-	一个名字不可既代表函数又代表变量
-	new Person().getAge()//实例.getAge()
-	存放在变量中的函数不需要函数名。他们总是使用变量名调用。
#	js引擎是单线程运行的  那么定时器是为什么
##	阻塞渲染
1.	关于css阻塞		link引入的css会阻塞	因为css解析器是同步的
2.	style标签的样式：
	-	
