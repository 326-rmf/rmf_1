practice:
one:
Person p1 = new Woman();
Man m3 = (Man)p1;//编译过 运行不过
Person 是 Man and Woman 的父类
但是Man and Woman 之间没关系
Woman p2 = (Woman)p1;才可
Person p4 =  new Person();
Man m4 = (Man)p4;
Man m5 = new Woman();
String str = new Date();
A a = b;
public void method(Person e){//多态
e.getInfo();
}
if(e instanceof ..){
}
public class GeometricObject{

public double findArea(){

}

}
public class Circle extend GeometricObject{
private double radius;
public MyCircle(){
}

}
public class GeometricTest{
public staic void main(StringGeometricTest[] args){

public void displayGeometricObject(GeometricObject o){
o.findArea();

}
boolean isEquals =  test.equalsArea(c1,c2);
MyRectangle rect = new MyRectangle(rect);
return radius;

//291

GeometricTest test =  new 
}
public boolean equalsArea(){
return o1.findArea() == o2.findArea();

}
}
class Base1{
public void add(int a,int... arr){
System.out.println();
}
}
public class ObjecTest{
public static void main(String[] args){
Order order = new Order();

}
}
class Order{}
order.getClass().getSuperclass();
//293
-------------------------------------------------
，、
== 和 equals 的区别
即使运算符和方法的区别
int i = 10;
int n = 10;
char型数据 只能是一个字符 
例如char a = 97 
不了说a 是97 而是  对应的字母a
alt + shift +s 来快速构造类的get and set 方法
比较引用型变量 是比较地址值
new 则重新开辟地址

equals 方法的使用
只能适用于引用数据类型
A a = new A();
A b = new A();
a.equals(b);//false
Object 类中的的equals 比较地址值
String a = new String();
Strign b = new String();
a.equals(b);//true
由于String ,Date,File,包装类都重写类Object 
类中的equals 方法，重写后比较的是实体类容
是否相等。
自定义的类重写通常重写equals 方法
为了比较实体内容
重定义类:public boolean equals(Object obj){
Customer cust = (Customer)obj;
return this.age == xust.age && this.name.equals(xust.name);
}
自定义的类，通常在Source 下调出来equals 方法
x.equals(null);//永远是false;
public boolean equals(Object onj){
if(this == obj){
return true;//地址
}
if(obj instanceof order){
Order order = (Order)obj;
return this.orderId == order.orderId
}
class MyDate{
private int day;
private int month; 
}
public boolean equals(Object obj){
if(this == obj){
return true;}

if(obj instanceof MyDate){
MyDate myDate = (MyDate)obj;
return this.day == myDate.day && this.month == myDate.month &&
this.year == myDate.year;
}}
Object 中toString 方法的使用
Customer cust1 =  new Customer();
cust.toString();//输出地址值
getclass().getName()+"@"+Integer.toHexString();
String str = new String();
输出的str 不是地址值
因为String Date File  包装类都重写了Object 类中的toString 方法
public String toString(){
return "Customer [name = ""]";}//这是重写
public class GeometricObject{
protected String color;
protected 

}
public class Circle extends GeometricObject{
private double radius;
public Circle(){
super();
radius = 1.0;
}
public double findArea(){

}
public boolean equals(Object obj){
if(this == obj){
return true;}
if(obj instanceof Circle){
Circle   c = (Circle)obj;
return this.radius == 

}
public class CircleTest{
Circle circle1 = new Circle(2,3);
Circle circle2 = new Circle();
circle1.getColor().equals(circle2.getColor()));
circle.equals(circle2);
circle.toString();
public class JUnitTest{
//JUnit 单元测试
//创建Java类 
}
public class JUnitest{
int num = 10;
@Test//导入Test
public void testEquals(){
String  s1 = "mm";
String s2 = "mm";
System.out.println(s1.equals(s2));
//run as JUnit Test
Object obj = new String("GG");
Date date = (Date)obj;
public void show(){
num = 20;
System.out.println("show()...");
}
@Test
public void testToString(){
String s2 = "";
public class PersonTest{
@Test
public void test(){
}}}}
wrapper//包装类
Byte Short Integer Long Float Double Boolean Character
这些都是包装类
这不是基本数据类型
private final int a;

基本数据类型 包装类和String 类型的转换
public void WrapperTest{
@Test 
public void test1(){
int num1  =10;
System.out.println();
 Integer in1 = new Integer(num1);
此时可以用in2.toString();
Boolean b1 = new Boolean(true);
Boolean b2 = new Boolean("true123");//可以输出true
//由于Boolean 被优化过
Prder order = new Order();
order.ismale;//false;
order.isFemale;//null由于是 类了
}
class Order{
boolean isMale;
Boolean isFemale;
}
public class wrapperTest{
@Test
public void test1(){
int num1 = 10;
System.out.println();
Float f1 = new Float(12.3f);
Float f2 = new Float("");
}}
class Order {
boolean isMale;//是基本数据类型
Boolean isFemale;//是包装类null
}
public void test2(){
Integer in1 = new Integer(12);
int i1 = in1.intValue();
Float f1 =new Float(12.3);
float f2 = f1.floatValue();
}
public void test3(){
int num1 =10;
method(num1);
int num2 = 10;
Integer in1 = num2;//自动装箱
int num3 = in1;//自动拆箱
//不用构造器

}
public void method(Object obj){
System.out.println(obj);
}
public void test4(){
int num1 =10;
String str1 = num1+"";//基本数据类型转换为String
可以调用valueOf(xxx xx);
float f1 = 12.3f;
String str2 = String.valueOf(f1);
//方式二来调用方法转换为String 类型
Double d1 = new Double(12.4);
String str3 = String.valueOf(d1);
String 转换为基本数据类型
String str = "123";
int num1 = (int)str;//不可以
Integer in1 = (Integer)str;
//不可以强制类型转换
//没子父类关系
int num1 = Integer.parseInt(str1);//可以将String 转换为基本数据类型
String str2 = "true";
Boolean.parseBoolean(str2);
//307
public class InterviewTest{
public void test1(){
Object o1 = true?new Integer(1) : new Double(2.0);
}
public void test2(){
Object o2;
if(true)
o2 = new Integer(1);
else
o2 =  new Double(2.0);
----------------------------------------------------
三元运算符 true?new Integer(1) : new Double(2.0);//整体类型要提升为double 
则o1 结果为1.0
public class ScooreTest{
Scanner scan =  new Scanner(System.in);
Vector v = new Vector();
for(;;){
int score = scan.nextInt();
if(score<0){
break;
}
Integer inScore = new Integer(score);
v.addElement(inScore);
if(maxScore < score){
maxScore = score;
}
------------------
jdk5.0之后的操作
v.addElement(score);
//自动装箱
for(int i = 0;i < v.size();i++){
Object obj = v.elementAT(i);
}
//为了ClassCastException异常
instanceOf来判断
if(p instanceOf Man){
}
public boolean equals(Object obj){
if(obj == this){
return true;
}

if(obj instanceof User){
User u = (User)obj;
return this.age == u.age && this.name.equals(u.name);
}
return false;}}}
int Integer 
char Character
自动装箱 自动拆箱
Integer i = 10;
-->String valueOf(xxx);
-->基本数据类型 包装类 xx.parsexx();
向上转型:多态
class Order{
}
封装性就是四种权限的修饰的体现
int[] arr = new int[]{1,2,3};
public void test2(){
Person p  =new Person();}
public boolean equals(Object obj){
if(this == obj)
return true;
if(obj == null)
return false;
if(getClass() != obj.getClass())
return false;
Person other = (Person) obj;
if(age != other.age)
return false;
if(name == null){
if(other.name != null)
return false;
}else if(!name.equals(other.name))
return false;
return true;
String s  ="abc";
s = null;
print and toString();
这时toString();会出现错误
public class StaticTest{
public static void main(String[] args){
Chinese c1 = new Chinese();
c1.name = "xiaoming";
c1.age = 40;
Chinese c2 = new Chinese();
c2.name = "malong";
c2.age = 30;
c1.nation = "CHN";

}
}
class Chinese{
String name;
int age;
static String nation;//static 修饰的是静态变量
//静态属性  和    非静态属性
//静态属性是共享的

 }
public class StaticTest{

}
class Chinese{}
//317
static 方法
class Chinese{
String name;
int age;
public static void show(){


}//
//可以Chinese.show();

public void info(){
System.out.println(""age:)+age;
public void walk(){}}}
//工具类中的方法来静态化  这样就可以不要new 对象了
class Circle{
private double radius;
private int id;

public Circle(){
id = init++;
total++;
}
private static int total;
private static int init = 1001;

publicc double findArea(){
return 3.14 * radius *radius;}}
public Circle(double radius){
this.radius = radius;
}
public class Account{
private int id;
private String pwd;
private double balance;

private static double interestRate;
private static double minMoney = 1.0;
private stat8ic int init = 1001;
public Account{
id = init++;
}
Account acct1 = new Account();
//加密
//322
单例设计模式的饿汉式实现
public class SingletonTest{



}
class Bank{
private Bank(){

}//私有化构造器
//内部创建类的对象
private Bank instance = new Bank();
//提供公共的方法返回类的对象
public static Bank getInstance(){
return instance;
}
//单例设计模式的懒汉式
class Order{
private Order(){}
}
private static Order instance = null;
public static Order getInstance(){
if(instance == null){
instance = new Order();
}
return instance;
}}
饿汉式 vs 懒汉式
//328
public class BlockTest{
public static void main(String[] args){
String desc = Person.desc;
person p1 = new Person();
}
}
class Person{
String name;
int age
static String desc = "one person";
//代码块就是一对大括号
//代码块的作用 用来初始化类，对象
//代码块如果有修饰的化只能是static 
static{
System.out.println("");

}
静态代码块内部可以有输出语句,静态代码块优先于非静态代码块
随着类的加载并且执行，通常自动执行，而且只执行一次
非静态代码块是随着对象的创建而执行，没创建一个对象就执行一次
可以对对象的属性进行初始化
静态代码块随着类的加载而执行
静态 代码块内只可调用静态代码
代码块相当于多了一个初始化变量的方式】
{
age = 1;
}
}
public class OrderTest{
Order order = new Order();

}
class Order{
int orderId = 3;
{
orderId = 4;
}}
final关键字
final可以修饰类  方法  变量
final 类不可被继承.是最后的
public class FinalTest{


}
final class FinalA{
//最后的类不可被继承

}
class B extends FinalA{
//报错
}
String 类为何是final类   因为他是完整的
final 修饰方法  方法不可以被重写
class AA{
public final void show(){}//不可以被重写
}
class BB extends AA{}
Object 中的getClass();//获取当前对象的所属类
native 是调用底层的东西
final来修饰变量   此时变量变为了常量

int num = 19;
num = num + 10;
final int width  = 10;
public void dowidth(){
width = 20;
}
final int WIDTH = 0;
final int LEFT ;
public FinalTest(){
//代码块中初始化   或者构造器当中初始化
}
{
LEFT = 1;
}
//普通方法当中不可以赋值fianl常量  因为方法在对象生产的生命周期之后
//final 常量可以在构造器当中赋值
final 修饰局部变量
public void  show(){
final int NUM = 10;
NUM = 20;

}
public void show(final int NUM){
//局部变量,形参可以被赋值   之后不可被修改
}
final 修饰形参是，表明此常量不可被修改了
//final 通常和 static 一起来修饰
static final 一起来修饰属性    方法
static final 修饰属性是全局常量
方法是不可被重写
例如static final PI = 3.1415926;
public class Something{

}
private default pritected public 
static final abstract native
--------------------------
abstract可以修饰 类   方法   
public class AbstractTest{
Person p  = new Person(;
p1.eat();
//抽象类不可被实例化   既是不可创建对象
}
 abstract class Person{
String name;
int age;
public Person(){}

}
class Student extends Person{

}
abstract 类   虽然不可实例化   但是还是有构造器
因为子类要调用   子类实例化时候要用到
abstract  
public abstract void eat();
//这是抽象方法     没有方法体    抽象类当中可以没有抽象方法
抽象类被非抽象类继承的时候
必须重写当中的抽象方法   必须全部都重写   方可实例化
class Creattrue{

}
public class AbstractTest1{


} 
abstract 不可用来修饰私有方法  静态方法
public abstract class Emloyee{
private String name;
private int id;
private double salary;
public abstract void work();

}
public class Manager extends Employee{
private double bonus;
public void work()
{}
//抽象类可以用多态
//抽象类的匿名子类
Person p  =new Person(){
//重写了抽象类Person 中的抽象方法
//这是创建了匿名子类的对象p
}
//匿名只为省事
class SubTemplate extends Template{
pbulic void code(){
for(int i= 

}


SubTemplate t = new SubTemplate();
abstract class Template{

}
public void spendTime{

}
}
public class Employee{
private String name;
private int number;
private MyDate birthday;

public abstract void earnings();
public String toString(){
return "";
}
}
public class MyDate{
private int year;
private int month;
private int day;
public String toDateString(){
return "";
}
}
public class SalariedEmployee extends Employee{
public ..{}
private double  monthlysalary;
public double  earings(){
return monthlySalary;
public String toString(){
return "name"+name}
}
}
public class HourlyEmployee extends Employee{
super();
public double earnings(){
return wage * hour;}
}
public class PayrollSystem{
Employee[] emps = new Employee[2];
emps[0] = new SalariedEmployee();
Scanner scanner = new Scanner(System.out);
if(month == emp[i].getBirth()){}
Calendar calendar = Calendar.getInstance();
}int month = Calendat.get(Calendar.MONTH);
System.out.println("monthly");
interface 接口//接口可以达到多重继承的效果
//接口和类是并列的
public class InterfaceTest{
Flyable.MAX_SPEED;
}
interface Flyable{
public static final int MAX_SPEED = 7900；
public abstract void fly();
void stop();}public static final
public static final int MIN_SPEED = 1;
//接口当中不可以有构造器   就是说接口不可实例化
class Plane implments Flyable{
//此类实现接口当中的全部方法之后才可以实例化}
public void fly(){}
class Kite implements Flyable{
public void fly(){
}}
先继承extends 后实现implements
可以多实现     
interface AA{}
interface B{}
interface C{}
interface AA extends B,C{}
抽象类和接口有哪些 异同
public class USBTest{
Computer = new Computer();
com.transferData(usb);
Flash flash = new Flash();
com.
}
interface USB{
void  start();
void stop();}
class Computer{
public void transferDate(USB usb){
usb.starrt();
sub.stop();}}
//353
//接口就是规范
<meta name=""  content="">
public class NetWorkTest{
new 
}
interface NetWork{
Server server = new Server();
ProxyServer proxyServer = new ProxyServer(server);
proxyServer.browse();
public void browse();
}
class Sever implements NetWork{
}
class ProxySever implements NetWork{
private NetWork work;
public ProxySever(NetWork work){
}}
接口的应用:代理模式
class CarFactory{
}
class A{int x = 0;}
class B{int x = 1;}
class C extends B implements A{
public void pX(){
syso  super.x;
and 
调用接口里面的变量   接口名.变量名}
public static void main(String[] args){
new C().pX();}}//草率则编译不通过
public interface CompareObject{
public int compareTo(object o);
}
public class Circle{
private double radius;}
public intcompareTo(Objeect o){
if(this == o){
return 0;}
if}
throw new RuntimeException("wrong");
CompareableCircle c1 = new CompareableCircle();
public default void mthod(){}
public static void method1(){}
接口当中有的静态方法 和  默认方法
只可以通过接口来调其中的静态方法
Collection
但是可以用类的对象来调用其 默认方法
public class SuperClass{
//357}
class SubClass extends SuperClass implements CompareA{
public void method2(){
}}
public class CompareB{}
内部类的分类

成员内部类   和   局部内部类

public class InnerClassTest{}
class Person{
String name;
int age;
public void show(){
syso}
static class Dog{int age;
}//成员内部类
class Bird{String name;
public Bird(){}}
public void method(){
class AA{

}
}

成员内部类
作为外部类的成员    
类内可以定义属性  方法   构造器等
调用外部类的成员
可以使用final 
final class Bird{
}}
Person.this.eat();
//调用外部类的属性
//Dog作为静态的成员内部类
Person.Dog dog = new Person.Dog();
dog.show();
//创建Bird非静态成员内部类
Person p = new Person();
Person.Bird bird = p.new Bird();
bird.sing();
public void display(String name){
syso;
}
Person.this.name;
bird.display("show");
public void method(){
class AA{}
}
public Comparable getComparable(){
class MyComparable implements Comparable{
public int 
}
类不能实例化   提供子类来实例化   继承性
}
抽象方法    是定义了功能的标准   子类来实现
抽象类可以实现接口   可以继承Object类
abstract A{
public abstract void m();//抽象类中的声明}
main(){A a = new A(){
public void m(){
syso}}}
class A(){
String name;
public void eat(){}}
main(){
A a = new A(){
public void eat(){
syso}}}
A.B b = new A.B();
A a = new A();
A.B b= a.new B();
//365
abstract class A{
public abstract double findArea();
}
class B extends A{
private double radius;
public double findArea(){
return;}}
IO流 当中的InputStream   OutputStream
//366
//368
public class InnerTest{
public void method(){
final int num = 10;//当局部内部类要用时候定义成final，因为是规定
class AA{
public void show(){
num = 20;
syso}}}}
public void onCreate(){}
button.setOnClikListener(new View.OnClickListener(){
public }
public class ExceptionTest{
@Test
public void test5(){
Scanner scanner = new Scanner(System.in);}}
ArithmeticException
public class Ex{
public void test(){
File file = new File("File.txt");
FileInputStream fis = new FileInputStream(file);}}
抛出异常
throws 
抓异常
public class ExceptionTest1{
public void test1(){
String str = "123";
str = "abc";
try{
int num = Integer.parseInt(str);
}catch(NumberFormatException e}{
syso}
catch(){syso}
}
try{
//可能出现异常的代码
}catch(异常类型1 变量名1){//处理异常的方式}
finall{}
//373
try{
int num = Integer.parseInt(str);
syso;}catch(){Number}
字符类异常
public void test1(){
try{
int a = 10;
int b = 0;
syso}catch(ArithmeticException e){
}catch(Exception e){
}finally{
syso;}}
finally 是看=可选的
finally 中声明 的是必定执行的代码
public int method{
try{
int[] arr = new int[10];
syso;
}catch(){
}finally{
Syso;//执行  }}
finally{
try{{
fis.close();
}catch(IOException e){
e.printStackTrace();}}
File file = new File();
fis = new FileInputStream(file);
 public 
开发中如何选择try-catch-finally
and throws
执行的方法a中，先后有调用另外几个方法，这几个方法是递进关系执行的
，那么这几个方法就用throws 抛异常,而执行的方法a就用try-catch-finally
public class StudentTest{Student s = new Student();
s.regist(-2);
}
class Student{
private int id;
public void regist(int id){
if(id > 0){
this.id = id;
}
else{
//手动抛出异常
throw new RuntimeException("data wrong");//这是运行时异常
throw new Exception("wrong");
}}}
compare(){
if(}p
public class MyException extends RuntimeException
{//自定义异常   要继承异常类
static final long serialVersionUID = -75555555555555L;
//标识全局常量
public MyException(){
}
public MyException(String msg){
super(msg);}
}throw new MyException("wrong");
margin外边距
 padding 内边距
list-style: none;//去掉列表前面的小点
background:pink;
<h1><p>
transition:all linear 3s 0s
ul:hover{background:red;
border-radius:50%;}
//382
public class EcmDef{
public static void main(String[] args){
try{int i = Integer.parseInt(args[0]);
int j = Integer.parseInt(args[1]);
int result = ecm(i,j);
syso("");}catch(NumberFormatException e){
syso("");}
catch(ArrayIndexOutOfBoundsException e){
syso("");}
catch(ArithmeticException){
syso("");}
catch(EcDef e){
syso(e.getMessage());
}finally{}
}
public int ecm(int i,int j){
if(i<0 || j<0)throws EcDef{
throw new EcDef("分子分母为负数了");
}
return i/j;}}
public class EcDef extends Exception{
static final long serialVersionUID = -556655555122561L;//这个版本号
public EcDef(){}
public EcDef(String msg){
super(msg);
}}
throws and catch and throw 
final finally finalize
throw and throws Collection  and Collections
String and StringBuffer StringBuilder
ArrayList LinkedList HashMap and LinkedHashMap
overwrite and override
结构不想似的:
抽象类  and 接口
sleep()   and   wait();
throws  抛出异常类型

在程序执行中,除了自动抛出异常的情况之外，我们还可以
手动抛出异常类的对象
throw   and   throws
抛出一个异常类的对象，生成异常对象的过程
throws  属于异常处理的一种方式，声明在方法内
class Student{
private int id;
public void regist(int id) throws Exception{
if(id > 0){
this..id = id;
}else{
throw new MyException("..");//手动抛出异常}}}
自定义异常类
1.继承于现有的异常结构，RuntimeException Exception
2.serialVersionUID
3.提供重载的构造器
public class MyException extends Exception{
static final long serialVersonUID = -555555555555;
//提供了一个全局常量
public MyException(){
}
public MyException(String msg){
super(msg);
000000000000000000000
}}
Object类  数组  相同类型数据的保存
集合   and    数组
fuzhulianxi  理解
zhexieleirongoop
多线程oo异常处理
FileNotFoundExceptiontry-catch-finally
dialog   Internet  wrong  lend   log
user 
开发团队的人员调度软件
og是一种新的HTTP头部标记，即Open Graph Protocol：

The Open Graph Protocol enables any web page to become a rich object in a social graph.

　　即这种协议可以让网页成为一个“富媒体对象”。
ps切图
1.快速导出为png
2.shift(选择多张图片 而不是ctrl) + ctrl+e 合并图层
切片工具-----》文件----》导出为web格式
relative   
             这个属性没有脱离文档流，设置position:relative 之后，会相对于自己正常的位置来移动，relative标识相对于自己位置
absolute
             这个属性脱离了文档流，设置position:absolute 之后，会相对于自己的第一个父元素来移动位置，absolute标识相对于父元素位置
var xhr = new XMLHttpRequset();
xhr.open('GET','http://localhost:');
xhr.send();
xhr.onreadystatechange = function(){
if(xhr.readyState == 4}{
console.log(xhr.responseText);}
不直接使用a 标签  而是(li + a)标签的做法来实现
一浮动全浮动
导航栏用li   +   a 来做
导航栏可以不用给宽度   将来可以继续添加文字  padding 来撑开盒子
border-bottom:2px solid blue;
color:#000
<div
a标签是行内元素   ,没有高度
&lt 是小于符号
&gt是大于符号
ctrl + shift 左键拖住  批量复制粘贴   html5
text-align：center   //水平居中
line-height: (等于height)   //垂直居中
box-shadow属性向框添加一个或者多个阴影
box-shadow :水平阴影   垂直阴影   模糊距离   阴影尺寸  颜色
example: box-shadow: 0 4px 3px 3px rgba(0,0,0,0.1);
一个父元素里面有许多个子元素    直接设置父元素行高就可以继承传递实现垂直居中
li标签可以用padding 来挤开距离
a标签  竖直分割线可以用边框来决定border-left  and   border-right
父级没有定位或者没有父级则子级的absolute会根据浏览器来放置
absolute会以最近一级的有定位的父元素来放置
相对定位会占领位置  但是绝对定位不会占领位置   子绝父相就是说父级用相对定位来
占领位置  子级用绝对定位来在父级里面随意摆放并且不占领位置
li > img    加了箭头符号就表示li标签的亲儿子img  li标签当中的em标签中的img 标签
不是亲儿子   因为隔了一个em标签
sticky粘性定位   兼容性特别差   IE完全不支持 占领位置   固定位置
static静态定位
是否脱标    移动位置
定位的叠放次序  定位之间的叠放次序
z-index 正整数   负整数  auto   数值大  越靠上
z-index   auto    and   z-index    数值越大级别越大
标准流   absolute不占领位置后来者居上
z-index  官大一级气死人
absolute   绝对定位  不可margin: 0 auto 来居中
float   浮动元素不会压住标准流的文字
绝对定位 会压住下面的标准流的所有文字
浮动最初发明的目的是文字围绕图片效果
并集选择器   
省去公共相同的代码
先左后右  先上后下
标准流   and      浮动
display   none 隐藏之后   位置也会被占用
visibility   hidden 隐藏之后的  位置继续占有
hidden   and  visible
overflow   文字溢出部分   visible   hidden   scroll    auto
.类名+tab 键       生成div class是类名
精灵技术: 
         为了有效减少服务器接收和发送请求的次数，提高页面的加载速度。
精灵技术主要针对于背景图片的使用，就是把多个小的图片整合到一张大图片上
background:(截取图片到左上角原点 的距离)负数
new Vue({
el:'#',
data:{
searchVal:'',
list:[]},
methods:{
searchFood:function(){
$.ajax({
url:
type:
success:function(res){
var body = JSON.parse(res.body);
_this.list = body.reault.list;
console.log()}})}}})
npm install    //环境的安装
npm run serve     //服务器启动
npm install --save-dev element ui element       //安装element    记得在main.js 当中来引入包
input   //双向绑定
创建项目步骤：
npm install -g @vue/cli
vue add element
vue add router
关闭终端   再次开启npm run serve
echarts
npm install --save-dev echarts
引入相应的页面引入echarts   import..
用到跳转要记得在空间上写出router
background: -webkit-linear-gradient(top, hsla(124, 98%, 50%, 0.6), hsla(56, 91%, 50%, 0.0), black) no-repeat;
背景颜色渐变功能。
transparent设置 透明颜色
display:block;margin:0 auto;//实现水平居中
border-width:0px;outline:none;//边框透明并且点击之后没有边框


//385