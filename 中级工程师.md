## css	c/s    更新，客户要更新  客户端
**函数在于三要素	功能 参数	返回值**
b/s   更新,客户不更新    服务器端   b是浏览器   s是服务器
需求分析
网页   结构  表现   行为
<title>小米官网</title>
注释习惯要养成
注释不可以嵌套使用
API application program interface
<!DOCTYPE html>文档声明
<html lang="zh">//lang属性来指定语言
zh是中文   en是英文
<meta charset="UTF-8">自结束标签   设置网页的基本信息
byte字节   bit位
h标签1-6  一般只用h1-->h3
<hr/>分割线
&nbsp空格
&gt 大于
&lt 小于
&copy 版权符号
&#Unicode  编码表
win + s  搜索框
meta标签设置网页的元数据   一般用来告诉浏览器如何解析网页
							--》name设置属性的名字
							-->content设置属性的内容
							--》description用于告诉搜索引擎网页的主要内容
em标签   强调
p标签不放任何块元素
./相对路径指的是当前文件夹所在目录的路径
jpeg(jpg)不支持透明效果
png支持透明   较于其他格式png更好  当然还要考虑透明  图像大小   颜色丰富度等因素
webp   专门为网页设计的一种图片格式   但是兼容性差  特别是ie
base64 用来将图片转换为字符串   直接在页面加载时候就可以用   提升速度
iframe  src  引入外部网页   iframe不会被爬虫解析
<embed src="" type=""> //照顾ie8的音频文件格式
<audio>音频标签</audio>
<iframe src="">引入视频</iframe>//引入外部资源难用
target="_blank"  直接跳转新的页面
http-equiv:设置http协议的响应头
<meta name="description" contents="...">
<meta name="keywords" contents="...">
<nav>导航栏标签</nav>
<section>表示区块</section>
块元素表示占一行
q标签表示引用
内联元素不会独占一行
blockquote长引用
./当前目录
../上级目录
ol有序列表   ul无序列表   列表项很常用
<dl>表<dt>表项<dd>表项描述</dd></dt></dl>
css  (层叠样式表)
stylesheet样式表     css   js  html 实现分离会  加快页面加载速度
div.box{}//设置class为box 的div
div.box*10  + tab   //这样会直接创建10个div  class为box
ctrl+e   //选中相同的名字
选择器:
div span{}
.boxq span{}
div p span{}
span + p{}兄弟元素
span ~ p{}选择后面的所有p兄弟元素
div>p+tab //就生成了div 里面有个 p
div *{}
伪类选择器，用来表示元素的一些特殊状态或者位置  伪类选择器前有冒号:
div p:first-child{}//div的第一个子元素必须并且是p 才成立 
div p:first-of-type{}//div的p类型中的第一个
p:nth-child{}
odd 奇数   even  偶数
:only-child{}//只有一个的子元素
div:empty{}//div是空的来选择 		匹配空元素
:not()//否定伪类
p:not(.p1){}//除了.p1类名的元素
:link//正常的超链接,没有访问过的链接的样式
:visited//访问过的超链接，来设置样式   只能该颜色
:hover//被鼠标移上去的时候的样式
:active//鼠标点击时候的样式
<link>//引入css
属性选择器   [title]{}//有title 这个属性的 时候就执行内容
[title='hello']{}//title为hello
[title^='h']{}//title以h开头
[title$='h']{}//title以h结尾
[title*='h']{}//title含有h的来设置样式
[title='hello']{}//区分大小写  但是[title='hello' i]//加上i代表忽略大小写

伪元素
::有两个冒号
.box::before{content:'hello';}//内容前面加内容
.boc::after{content:'bye';}//内容后面加内容
::first-letter   第一个单词   .box1::first-letter
::first-line   第一行  .box::first-line
:selection   选中的内容
继承简化了代码的编写
transparent透明
权重优先级
内联1000>id100>类和伪类10>元素1
但是   为一个样式添加了！impotant    ,则这个样式>内联
但是要谨慎使用,以为别的东西不可覆盖   color:blue !import;
复合选择器  所有选择器的权重相加再来比较
相对于其包含块叫法更合适   相对于其父元素
hsl(,,)//h表示色相0-360   s表示饱和度0%-100% 	  l表示亮度0%-100%		工业上表示颜色的方法
border  	不占盒子大小
盒子的可见框大小   由		内容区	内边距	边框共同决定
margin border padding
padding 在内容区和border之间
margin border	padding		height	padding		border	margin
width	auto	默认占满		height	auto	默认内容多高就多高	没有内容就没没高度
height一般不写死  	会溢出的问题
overflow来设置溢出的设置
overflow   			可以设置的值有		-->visible(默认的)		
										-->hidden		溢出的内容会被裁剪
										-->scroll		生成滚动条来查看完整内容
										-->auto			根据需要生成滚动条
外边距的折叠问题			两个div之间的属性可能会折叠		
						margin-bottom		and 		margin-top
子元素的margin会传递给父元素
子父元素可以设置颜色来研究
文档流
垂直方向的padding不会影响页面布局
水平方向相邻的外边距不会重叠  		会相加两者之间的距离
display来指定元素生成的框的类型	--》inline行内元素		display:inline
								--》block块元素		display:block
								--》inline-block行内块元素		display:inline-block
								inline-block有点像图片不独占一行又有块元素的特点可以设置块元素
								-->none		元素不在页面中显示
visibility:hidden;			-->不显示元素但是占领位置
但是 		display		-->不显示元素且不占领位置
.outer>li:hover .inner{display:block;}			-->outer里面选中的li 才显示
houver显示的问题可以用到祖先和子类的相关的知识  -->点祖先，祖先和子类都显示
开发中第一步就是去除浏览器的默认样式
*{margin:0;padding:0;}
list-style:none;//去除列表项点
一般只会在块元素里面放内联元素，反之不可
<a>里面什么都可以放</a>
text-align//水平居中   		text-align:center;
line-height://直接写满元素的height    则文字垂直居中了
display:-->table表格表示    --》flex弹性容器显示			-->行内弹性容器
.box1::before{content:"";display:table;}//处理外边距折叠问题
文档流		文档就是网页
before是元素开始			after在元素结尾
display:inline-block     margin-top:1px;
outline:-->是不占空间的边框		设置轮廓不会影响元素的内容
box-shadow-->设置阴影		和轮廓一样		就是加上一个特效
box-shadow:（inset）20px 20px 10px #ffe;-->第一个值正值向右移动
								--》第二个值正值向下移动
								--》第三个值越大阴影就越模糊
								--》inset  表示内部阴影  	默认外部阴影
								--》可以设置多重阴影
float 元素完全脱离文档流  		不占据文档流里面的位置
float就是浮上一层去布局排列
超链接是内联元素
脱离文档流的元素全是块元素
浮动元素位置默认不会超过其上的其他元素
脱离文档流可能会高度塌陷
BFC是元素的一个隐藏属性		一旦元素开了BFC他将会开启一个独立的布局区域
开启了BFC的元素可以包含浮动子元素		
BFC无法直接开启			需要特殊属性来开启BFC
设置元素浮动可以开启BFC
CLEAR   来清除浮动元素的影响
.clearfix::before,
.clearfix::after{
	content:'';
	display:table;
	clear:both;
}						-->就解决高度塌陷问题还有外边距重叠问题
outline 		-->outline:1px solid red;
box-shadow				rgba(0,0,0,0.5);//阴影
浮动元素不会覆盖文字
top right bottom left
position 			-->absolute		会脱离文档流		宽高都随内容撑高		性质会改变	相对于离他最近的开启了定位的元素来定位
					-->relative		相对于自身原来的位置		不会脱离文档流		设置之后会提升元素的层级
					--》fixed		开启元素的固定定位		像一种特殊的绝对定位		但是他是总是相对于视口
					-->
z-index			-->表示层级的高度		--》z-index:1..   父元素层级再高不会盖住子元素
opacity:		-->用来设置元素的不透明度		
一般来说子绝父相
绝对元素相对于其包含块来定位的
元素设置了		absolute，那么margin:0 auto;就不管用了 	除非设置的时候left top right bottom 设置为0   	那么margin:auto;-->就会水平居中
元素设置了定位 		那么就多了left bottom right top 这几个值
水平方向			left margin border padding width padding border margin right
设置的时候left top right bottom 设置为0   	那么margin:auto;-->就会水平居中
position  	默认值是static 	表示没有开启定位
font awesome 		图标库 
1em  ==  1font-size		-->font-size是自己定义的
1rem == HTML的1font-size		-->默认16px
默认行高line-height是1.33		height	and 	line-height是不一样的
font-weight		字体是否加粗		100~900	越来越粗
min-width 	max-width		最小宽度		最大宽度
--》浏览器缩小放大的时候不改变框的大小
 text-align:-->left		左对齐
			-->right		右对齐
			-->center
			-->justify		文本两端对齐
vertical-align-->baseline		沿基线对齐
				--》sub		下标
				--》super	上标
				--》bottom	沿父元素底部对齐
				--> top		沿父元素顶部对齐
				--》middle	相对于小写子母的middle对齐
				-->特殊情况会遇到		图片位置默认和文字的基线对齐的
line-through		文本删除线
over-line 		上划线
solid	wavy	dotted	dashed	
text-indenet		首行缩进  	俩个文字的px   2em
white-space		-->normal	文本自动换行
				-->nowrap	文本不换行
				--》pre		保留文本的本来格式
text-overflow		-->ellipsis		处理溢出的文本
						文本显示不全用省略号显示		
white-space & overflow & text-overflow		这三个一般一起来用
letter-spacing		字母之间的间距
word-spacing		单词之间的距离		指定空格的大小
background-clip		-->padding-box		可以到padding 框
					-->
background-image		url('')		-->no-repeat
									-->repeat	默认重复
									-->repeat-x	x轴平铺
									-->repeat-y y轴平铺
图片存储为web使用格式
background-size:100%		-->图片来适应容器来等比缩放大
background-position:top left;		-->九宫格
									-->background-positon:100px 100px;
									-->第一个值正值		图片向右移动100px
									-->第二个值正值		图片向下移动100px
									-->一般都是赋值		将多个按钮的状态保存在同一个图片当中
									-->再来通过偏移量来显示需要的状态
									-->这叫做CSS Sprite(CSS精灵),雪碧图
									-->有效降低了发送请求的速度，提升用户的体验，降低图片的总大小
									-->降低加载的速度
									-->只适用于背景图片background-image
行内元素不支持宽高的设置		只随内容来撑起宽高
link 	hover		active		hover-->active
							第一次刷新的时候为什么会闪烁呢
							因为图片这些外部资源只会在页面在加载之后，有页面请求的时候在来加载
							图片需要使用的时候才来加载就会闪烁这种叫做懒加载
							
请求-->响应-->请求

href="javascript:;"		-->javascript:;来作为占位符是可以的		不会跳转页面
table		表格		里面的colspan所占领的大小
					-->colspan行
					-->rowspan列
					-->th是表头单元格		会加粗
					-->border-collapse:collapse		表格边框重叠
					-->创建table的时候		如果没有添加	tbody theader	tfooter
					-->那么浏览器会自动只加上tbody
		<table>
			--><tr>
			--><td>
<form action='#'></form>			表单提交数据的时候   	要有input框里面要有name属性
							-->action表单提交的位置
							--><input type='email' name='email' required autofocus>-->必填的
							-->autofocus  	自动聚焦的
							-->autocomplete		自动填写表单的关闭		不再记忆所输入的内容
absolute		脱离文档流		不占空间了

设置小三角形
.arrow{
	display:none;
	width:0;
	height:0;
	boeder:10px solid #fff;
	border-top:none;
	border-color:transparent transparent #fff;
	top:10px;...
}

height  line-height		text-align
hover绑定对象也有讲究
是a标签		还是div
隐藏元素的position可以是absolute		脱离文档流		不占大小
transition		过渡效果
transition:all 4s 1s;		-->第一个值是执行动画的属性
							-->第二个值执行动画的时间
							-->第三个值要延迟多久才来执行动画
height:0		overflow:hidden		也可以隐藏元素

阿里云的图标			下载至本地	下的压缩包的里面的两个demo
不用管		直接新建iconfont文件夹来引入其它剩余的文件
class="iconfont"

margin-left是固定的距离		left不是固定的距离
outline:none;		-->去除轮廓线
left margin-left border padding-left width..
*****right=1/2父元素			margin-right=-1/2父元素
li:nth-child(1):before{}
伪元素

ico文件就是web网站标签的图标
<link rel='icon' href='favicon.ico'>
net标签小图标
开发环境和生产环境
transition-property:height,width,background-color;-->变换属性
transition-duration:2s;-->变换时间
transition-delay:1s;-->过渡延时效果
transition-time-function:		linear-->匀速效果
								ease-in-->加速运动
								ease-out-->减速运动
								ease-->先加速再减速(默认值)比ease-in-out猛一点
								ease-in-out-->先加速后减速
								steps(6,end)-->图像分六步来变换
								steps(6,start)-->快一点
transition:left 2s steps(6,end)-->简写属性
transition实现了过渡效果		交互效果		类似动画效果但不是动画
@keyframes 名字{
	
}					-->keyframes用来设置关键帧
@keyframes test{
	from{}
	to{}
}
animation			-->实现动画效果
 cubic-bezier(p1,p2,p3,p4)			-->贝塞尔曲线	设置运动风格
 animation-play-state			动画播放状态
 animation-direction		-->normal
							-->reverse
							-->alternate
							-->alternate-reverse
anomation:test 400ms steps(6) alternate-reverse;
							-->动画简写属性
元素定位之后   多了left		right
				-->记住left:0;right:0;
				-->margin:0 auto;-->这样才会居中
@keyframes falldown{
	from{top:0;}
	to{top:396px;}
	0%,50%,100%{top:0;}
	from{top:0;}
	to{top:450px;}
	infinate alernate
}			
transform:translateX();		-->沿着x轴方向平移
				translateY()	-->沿着y轴方向平移
				translateZ()	-->沿着z轴方向平移	元素距离用户的距离
.box2{
	position:absolute;
	background-color:#bfa;
	left:50%;
	top:50%;
	transform:translateX(-50%) translateY(-50%);
}			-->让一个元素永远垂直水平居中
perspective		-->视距  设置人的眼睛和网页之间的距离	让视觉有3D效果
perspective:100px;-->不宜过小
transform:rotateX()		-->沿x轴旋转		45deg
rotateY()		-->沿y轴旋转
rotateZ()		-->沿z轴旋转
div.clock-wrapper
	div.sec-wrapper
	div.hour-wrapper
	div.min-wrapper
定位之后会多left right top bottom居中		left right top bottom =	0;	margin = auto;	
transform-style: preserve-3d;		-->**添加3D效果**
html里面添加视图效果  		眼屏距离perspective: 800px;
opacity添加透明效果   transform: rotateX(90deg) translateZ(-100px);旋转
rotate			-->deg
translate			-->px
transform		-->形式
@keyframes			关键帧
transform-origin		-->旋转原点
transform:scaleX(2)		-->X轴放大两倍
transform:scale(1.2)		-->X Y轴放大1.2倍
横向布局就是不断浮动
相对路径		绝对路径
公用资源存储在一个CND服务器里面
通过CDN来加载图片
一般网站会防止盗链		但是图片防盗链很少
margin-left:-100%		左边导航栏的设置不被挤下去
<!-- 双飞翼布局
min-width
<div class="main">width:100%;
<div class="inner">zhongjian</div>padding:0 200px;
</div>
<div class="left">zuo</div>margin-left:-100%;
<div class="right">you</div>margin-left:-200px; -->
min-width:600px;
.outer-->margin:0 200px;
width:calc(100% - 200px)		-->双飞翼布局
linear-gradient		-->线性渐变		自上向下(默认)
radial-gradient		-->径向渐变		
repeating-linear-gradient		-->重复线性渐变
ellipse		椭圆
radial-gradient(at 0 0,red,..)		-->at指定圆心位置
less是css预处理语言	扩展了css语言	增加了变量
**使CSS更容易维护**
#	less里面封装一个混合mixin
less里面混合的函数		是不会在css文件当中存在的
例如
.hiedBox(){

}
命令行
		-->指令进行操作
		-->d:	e:转到对应盘符
		-->dir		当前目录下的所有文件
		-->cd + 路径 	进入指定目录		cd desktop\..
		-->cd ..		上一级目录
		-->cd .		当前目录
		-->mkdir		创建一个文件夹
		-->rmdir		删除一个文件夹
		-->cd \			c的根目录
用户变量 & 环境变量
用户变量设置的时候   PATH可以设置一组路径
当前目录下找不到文件的时候，会依次去到path的路径中去寻找
例如path 里面配置了 c:\users\desktop
		node.js里面的npm
		npm用命令行下载里面的包
		npm是国外的
		那么就用npm来下载cnpm镜像服务器
		npm install -g less
		下载less包
--a:100px;		-->定义了一个变量
width:var(--a);		-->使用了变量
方便了改的时候		直接找到变量名来修改对应的值
html{
	--a:100px;
	--b:orange;<!-- 在html里面来定义变量 -->
}
lessc style.less style.css
				-->将less文件转换为css文件
less文件：
@a:10px;
.box1{
	width:@a;
	height:10px;
	.box2{}
}			-->原生的css
转换为css文件
.box1{
	width:10px;
	<!-- 不用担心兼容性问题
	 a变量的定义-->
}.. 
ddos来攻击服务器
npm可以下载和上传
cnpm只可以下载
less里面的函数
darken()函数用来加深颜色

background-color:darken(yellow,20%);	-->加深了黄色

.box1{
	width:160px;
	height:$width;
}
										-->使用$符号来直接引用其他的值
										-->使用变量的时候就近原则
.box2{
	.box1();
}								-->box2里面来使用box1的样式**
.box2:extend(.box1){
	font-size:12px;
}	
								-->box2在box1的样式基础上进行了扩展
.box2:extend(.box1 all){

}							-->继承了所有关于box1的属性
.hello(){

}						-->选择器加了括号那么就只是用来被其他选择器来继承		（）里面可以传值		.hello(20px,40px)
相当于定义了一个函数		是一个形式参数
.hello(@a,@b){
	width:@a;
	height@b;
	background-color:#f00;
}			--->简化了开发 		要引入的时候就引入
.wrapper{
.hello(300px,500px);	}	
					-->简化了开发		减少了代码量
.box4.extend(ul){}
.box4{&.extend(ul);}		-->&符号就是这么来表示的表示外层选择器的
@import "demo02";		-->将外部的less文件来导入当前less文件
Program Files		64位的软件
Program Files(x86)		32为的软件

弹性盒子是CSS中新增的一种布局方式，是自适应容器的大小，是非常灵活的布局
display:flex;			-->弹性盒子		不会高度塌陷
justify-content:			-->space-around	空白位置到元素前后
							-->元素在主轴上的对齐方式
							-->flex-start	主轴起边
							-->flex-end		主轴终边
							-->center		水平居中
							-->space-between 	空白位置平均来分配
							-->space-evenly	空白位置在元素的一侧
							-->stretch		拉伸让元素充满盒子	

弹性容器
			-->弹性元素就是弹性容器
		弹性元素（弹性项，弹性子元素）
		inline-flex		行内弹性容器
		flex		块级弹性容器
flex-direction			-->row		横着排	自左向右
						-->column	竖着排	自上向下
						-->row-reverse	横着排	自右向左
						-->column-reverse 	竖着排	自下向上
flex-shrink:0;		-->禁止盒子收缩
flex-wrap:			-->nowrap		盒子不够的时候自动不换行		flex-flow:			-->表示可以设置flex-direction  & 	flex-wrap
flex-flow:row nowrap;	
 align-items:center			-->弹性元素在盒子里面垂直居中
							-->stretch	元素充满侧边
flex-grow：1；			指定元素的增长系数		分配弹性盒子的空间
子元素总宽度超过父元素的时候，需要使用缩短系数flex-shrink
flex-basis:			-->指定弹性盒子标准大小	默认值是auto
flex:0 1 300px;
flex:0 1 200px;		-->假设元素溢出了200px	
					-->200/(300+200)-->x
					-->x*缩短系数1*basis(分别是300和200)
flex:伸 缩 xxpx(基准);			flex-->给伸缩元素来设置
div
		div-inner	-->width:calc(20% - 10px);
					-->margin:0 5px;
					text-align:center;
		div-inner img
					-->width:100%;	-->随父元素变换
窗口放大缩小的问题
				-->引出内部网页文字图标布局同步放大缩小问题
				-->还有迁移到移动手机端的问题
pc端和移动端的屏幕问题来设计网页
修改浏览器的视口
<meta name="viewport"	content="width=device-width">
device-width 		-->设备的完美视口值	手机端有完美体验
	--><meta name="viewport" content="width=devcice-width,initial-scale=1.0">
1vw		1%视口宽度
100vw		100%视口宽度
弹性盒是float的增强版				
inline-flex		不独占一行
flex			独占一行
order可以来调整弹性元素的顺序
css像素		物理像素
视口大小就是html标签的大小
vw总是相对于视口来计算的
百分比是根据包含块来计算的
html{
	font-size:5.3333vw;-->视口大小
}
vw		设计图px 		视口大小vw		rem是html的font-size
		750px			100/750=0.13333vm		font-size最小是12px
响应式布局		-->布局样式随着视口变化而响应变化
@media		-->媒体查询		为不同的设备		不同的屏幕大小设置样式
				all			-->样式适用到所有设备
				print		-->样式到打印机上
				screen		-->..屏幕上
				speech		-->阅读器
设置断点
超小屏幕	<768
小屏幕		>=768
中等屏幕	..
-----------------------------------------------------------------------

## JS
what 布莱登 艾奇   1995年		10天开发了js语言		动态的 弱类型的
解释性的脚本语言
动态			-->只有在执行的时候才能确定数据类型
弱类型			-->数据类型是不缺定的，可以随意改变的
解释型			-->不需要去编译		执行的时候一行一行去解释执行
脚本			-->一般脚本语言		可以嵌在其他语言当中去执行
java		javascript是由livescript改名来的
java   javascript之间没有关系
why 
how
js可以      --》表单验证
            --》用户交互
            --》后端开发
            -->游戏
js组成部分      --》ECMAscript      负责js的语法规范
                -->DOM          document object model       文档对象模型    (操作元素)
                -->BOM          browser    object   model   浏览器对象模型   (操作浏览器)
js三种书写位置
			--》内嵌式
			--》外链式
			--》行内式
var  变量名
## 基本数据类型		number string boolean undefined	null
num = 3e10;		-->几乎不用
0b	开头代表是二进制数
0	开头是八进制数
0x  开头是16进制
var age;		-->undefined		-->定义变量未赋值	-->里面存的就是undefined
null		-->空类型		var obj = null;-->一般定义对象的时候来使用	用于对象初始化或者删除一个对象的时候来使用		那么console.log(obj)		-->是Object		--->对象	
console.log(typeof num);-->
console.log(typeof typeof num)-->相当于console.log(typeof "number")-->	打印出string
!==			--->不全等于
num+1		-->是一个表达式 
var a = 5;var c = '5';		a==c	-->true	-->数字型字符串自动隐式转换为数字		判断值
							a===c	-->false	--》全等
							判断类型和值					
a	= 5&&8;		console.log(a);	-->8
var b = a>8 || a<9;-->a==10-->b==tue;
Number();			-->强转类型函数		若字符串看起来不是一个数字	那么转换为NaN		而不是数字		true->1		false->0
undefined-->NaN		null--->0	"" " "-->0
String();			-->强转string类型函数
Boolean();			-->强转boolean类型函数
0    和   空字符串''	和	undefined  	和	null	转换为Boolean的时候为false		
var a = b + false;		-->false-->隐式转换为0
parseInt(a)		-->提取整数		--》a="123adf"-->a==123
								-->a="asf123"-->a==NaN
								-->第一个要为数字来开头
1/0			--》infinity	-->无穷大
'abc'<'bc'		-->因为b>a		
undefined	>	undefined	-->false
num + str -->str
num - str -->str-->num -->num-num-->num
num +- bool	-->bool	-->num
NaN+-*/	-->num
'abc'+true		-->abctrue
'abc'-true		-->NaN
NaN == NaN		-->false		-->没有可比性
***空串和null不相等		''==null		-->false;
	false和null不相等		false==null	-->false;
	undefined和Null相等		undefined==null	-->true
	0和null不相等			null是表示对象的		0是基本数据类型
	0==null				-->false

Number('23');			-->
'23'-0					-->第二种最快
parseInt('23');			-->'23'转换为23
'23'-0
键盘上输入的东西一概是字符串
prompt('输入数字')		-->键盘上面输入数据
多分支情况去考虑各种情况发生的可能性
顺序结构		分支结构		循环结构
一个if else 的时候可以用三元运算符来表示
冒泡排序	从小到大		从大到小
function maopao(){for(){}}..封装完成        为maopao();
var arr = [..];maopao(arr);
函数传参分为        --》基本数据类型
                                --》函数外和函数内部操作的不是一个值 
                    --》对象数据类型
                                --》数组是对象  那么函数内部和外部是操作的一个数据
函数的封装减轻了代码的冗余问题		function  xxx()
返回值问题
作用域链
				--》变量在查找的过程
栈结构			--》先进后出	有序的	栈底	栈顶
堆结构			--》随意增删

### 程序执行开始：首先肯定是创建全局环境	然后才是局部环境	并且这些环境是在栈里面进行管理的	创建完全局环境之后 	会把程序中所有的全局变量收集起来并且进行执行开辟空间		接着函数调用的时候才会创建函数环境	并且搜集所有的局部变量并且开辟空间 		当函数返回值之后，代表函数执行完成，此时，函数环境会立马从栈中弹出，函数环境被销毁，释放内存
当整个程序执行结束之后，全局环境才会弹出栈，也就是销毁了全局环境，释放全局环境占用的内存
ES5里面没有块级作用域   只有全局和局部
作用域分为	全局	局部	块级
let是ES6里面的语法
if(a > 1){let c =1;}console.log(c);-->undefined因为ES6里面的块级作用域的影响
## 预解析				console.log(a);
					var a = 10;		-->预解析之后的代码
					var a;
					console.log(a);
					a = 10;			-->预解析造成的代码
					预解析只会解析带var的变量,不带var的,不进行预解析
					function f1(){}
					-->这种写法	函数整体会提升
					var f1 = function(){}
					-->只会提升var f1,不会提升函数的表达式
function fun(){var a = 10;var b = 20;}
				-->预解析的效果就是
				var a;var b;a=10;b=20;
				-->开辟空间	再来赋值 

预解析优先级		
			--》先去解析函数	函数如果有同名会发生覆盖
			-->再去解析var变量
## IIFE	立即调用函数表达式
			(匿名函数自调用)
(function(){})();		-->匿名函数	不会发生预解析
						--》匿名函数自调用只能执行一次
			--》匿名函数自调用可以封装代码实现，不把代码暴露出去
			-->防止外部的命名空间被污染
jquery放在了匿名函数里面		对代码进行了封装
arguments		可以存放参数			
函数作为形参		--》回调函数
Arguments		是函数实参伪数组
## 回调函数
函数是我定义的		我没有调用		最终执行了
事件		定时器		ajax		生命周期回调函数
全局变量		和		局部变量没有关系
## 对象
简单数据		var a = 10;
一堆数据		var arr = [];
一段代码		function(){}
复杂混合体		对象	一般对象都是Object的实例对象
var obj = {};		-->定义了一个对象
## new 关键字实例化对象
1.开辟内存空间		
2.this指向该内存
3.执行函数
4.生成对象实例
对象创建的方法
1.var obj = {}
2.var obj = new Object();
3.工厂函数模式
##		原型对象和原型链
prototype		-->原型对象(灵魂)		--》默认是Object实例化的
			-->原型对象做到了资源共享	节省空间
constructor		-->指向了构造函数(肉体)
_proto_			-->隐式原型对象
console.dir(singer1);		-->详细查看	singer1
a.prototype.run = function(){console.log('fast');}
        -->原型对象里面去添加run这个函数
Object.prototype.run = function(){console.log('fast')};
        -->Object是原型对象的原型对象
		对象找属性的过程形象地成为原型链
A的原型对象是被共享的	节省了空间	A	new出来的a实例对象不是函数对象
那么a就没有显式原型对象prototype  但是有_proto_隐式原型对象,其指向A的原型对象prototype
## apply/call 改变一个函数的执行对象	bind
apply call是立即调用函数		bind()是将函数返回
add是一个window下面的函数
add.apply(cat1,[10,20]);		-->cat本来没有这个方法
								-->但是用了apply之后,换了cat可以由这个方法,cat1是cat的对象,[10,20]是参数,参数必须是数组形式
add.call(cat1,10,20)			-->call函数参数不用数组形式
add.bind(cat1,123)();-->bind修改this指向
setTimeout(function(){
	console.log(this);
}.bind(cat1),1000)
数组类型是Object
a=function(){}  -->类型是function
a={}			-->Object类型的
## typeof  instanceof 
typeof		区分基本数据类型  function	区分不了对象
instanceof			区分对象和数组
## 值类型		引用数据类型
值类型就是基本数据类型	number string boolean undefined null
引用数据类型就是对象数据类型	arr function object 内置工具
变量存在栈		数据存在堆
function()里面的参数		涉及全局变量会改变外部的值与否很关键
栈里面  
栈里面有
		全局环境
			 arr  地址	0x2b19	arr就是引用数据类型
		基本数据直接存在栈里面 a为10		10转化为2进制来存储
		function函数跟arr一样	引用数据类型
		函数环境

堆里面		存的0x2b19的内容
			堆空间的释放是靠垃圾回收机制来进行的
			删除对象	就给对象赋值为null	
var  a = [];
var  b = [];
console.log(a==b);--->false		地址不一样
new		之后开辟新的空间		传地址的时候要注意 
##		JSON		内置对象
json通常情况说的字符串就是json串	前端json串的格式就是对象或者对象的数组
"{
	"name":"abc",
	"age":32
}"
JSON对象的方法		parse(JSON串转换为对象或者数组)		stringify(JSON串)
JSON化就是字符串化		JSON.stringify(data);	-->JSON化
前端和后台交互的主要数据
后台需要的是JSON串
前端需要的JSON串.parse
##		Math函数
Math.floor()		-->向下取整
Math.ceil()			-->向上取整
Math.round()		-->四舍五入
Math.random()		-->随机数	0~1之间的数 含0不含1
Math.max(1,2,3,4)	-->返回多个数之间的最大数
Math.min(1,2,3,4)	-->返回多个数之间的最小数
Math.PI				-->圆周率
Math.pow(2,3)		-->第一个数代表底数
					-->第二个数代表指数
Math.sin()			-->三角函数的正弦函数三角函数在Math当中全部要使用弧度而不是角度			Math.PI/2		-->弧度
## 求数值范围公式

**function getRandom(min,max){Math.floor(Math.random()*(max-min+1))+min;}**
--->封装在函数里面完成了
![img](picture/bootstrap.jpg "bootstrap")

##		Date日期对象
`var date = new Date();`
`date.getFullYear()-->获得年`
`date.getMonth()+1-->月份 月份是0~11`
`date.getDate()`
`date.getHours()`
`date.getMinutes()`
`date.getSeconds()`
`date.toLocalTimeString()时间`
`date.toLocalDateString()年份日期`
`date.getTime()1970年1月1日到现在的毫秒数`
API就是接口		接口就是函数
格式化时间
2018年...
图例		全局变量和局部变量的涉及更改
封装函数到一个js		引入文件再来调用
**Number()	String()	Boolean()强转函数**
NaN是未定义或者不可表示的值
js里面很多自带函数		toString()
var b= new Number(10);-->包装对象 
var a = 10;
console.log(a.toString());-->会把a**包装成对象**	然后进行调用	包装对象的方法	调用完成之后  **临时的包装对象会立即清除**
##	ES5增加了严格模式
		--》消除了js语法的一些不合理之处
		--》消除代码运行的不安全之处	保证代码运行的安全
		--》提高编译器效率	增加运行速度
		--》为未来新版本的js做好铺垫
"use strict"
			-->变量声明必须写var
			--》禁止this指向window
			-->函数不可有重复参数
##  ES6都是严格模式下的
let 		块级作用域声明变量	let声明的变量不会进行预解析
const		定义的变量无法更改	也是块级作用	定义的时候必须初始化
Array		数组方法
**函数	--》功能 参数  返回值**
**str.match(/12/g)		-->正则	-->g表示全局global**
concat一般不用		因为用+法就行了		不用调用函数来执行
**join()-->数组变为字符串	split()-->字符串变为数组**
arr.sort();	-->数组按照unicode码进行比较排序	类似字符串比较
arr.sort(function(a,b){
	return a - b;	--》return b -a;	-->按照从大到小来排序
})-->按照从小到大来排序
**push()-->数组后面加元素	pop()后面删除一个元素	都影响原数组**
**unshift()原数组头部添加元素	shift()原数组开头删除元素	都影响原数组**
**splice	数组的这个方法是一个万能方法	可以增删改	都是在原数组基础进行的**
arr.forEach(function(item,index){
	console.log(item,index);
})-->forEach方法是遍历数组的手段，需要传递一个回调函数参数，这个方法返回的是undefined,没有return;
arr.map(function(item,index){
	return item*2;
})-->map方法就是快速生成一个新数组，与传入的数组有一个特殊的关系
arr.filter(function(item,index){
	return item>=2;
})-->过滤特定条件的数组元素，来返回一个新的符合条件的数组，不会影响原数组
## DOM	一切都是对象	文档对象模型
DOM		是一个让程序和脚本有能力动态访问和更新文档内容		结构以及样式的平台和语言中立的接口
DOM		描述了网页内容的方法和接口
DOM文档树
`<head></head>`			-->**称为根**--》HTML的**root**
### 文档对象
	节点			元素		属性	文本		注释
	元素			标签
	根元素			html标签
	文档树
####		document是window下的一个属性	代表整个DOM文档对象
window.onload		-->页面加载完成事件
一般我们等待页面加载完成后		--》才去操作dom元素
window.onload = function(){}		--》页面加载完成	执行函数代码
语法是无法操作的		只可以通过setAttribute  getAtterbute 去操作
**无论元素是天生的	还是自定义的 都可以去操作**
**setAttribute		设置属性的值**
**getAttribute		获取属性的值**
querySelectorAll('');		-->选择全部的	多个元素
innerHTML		-->内部的文本显示		-->可以识别html标签
innerText		-->文本显示	--》不可以识别标签
**innerHTML   innerText在读取内容的时候的区别**
**console.log时候的区别**
innerhtml是		会把标签内部带着其他的标签全部输出
innerText是		只会输出所有标签里面的内容或者文本	不会输出标签
var arr1 = new Array(5);-->arr1数组里面是5个undifined
---------------------------------------------------
##	textContent		innerText	的区别
textContent	可以获取隐藏元素的文本		包括换行和空白**visible:hidden	的元素可见**
innerText		不可获取隐藏元素的文本
---------------------------------------------------------
for(var i = 0;i  < pList.length;i++){
	pList[i].a = i;
	pList[i].onclick = function(){
		for(var j = 0;j<pList.length;j++){
			pList[j].innerHTML = 'haha';
		}
		pList[this.a].innerHTML = 'shuang';
	}
}
**排他思想来书写驱动程序  pList[i].a = i;**
----------------------------------------------------------
onmousemove鼠标移入		
onmouseover鼠标悬浮		onmouseout鼠标移出		
onmounseenter鼠标进入	onmouseleave鼠标离开
onclick点击		ondbclick双击
onmousedown鼠标按下		onmouseup鼠标抬起	
------------------------------------------------------
**写结构时候用class     写js的时候用id**
----------------------------------------------------
innerText		浏览器都认识
textContent			IE低版本不认识
要注意兼容性处理
------------------------------------------------------
for循环只是添加了事件监听		但是事件回调函数是不会执行的；**事件回调函数当中的代码实在事件发生的一瞬间执行的，但此时for循环已经执行完毕**
所有在事件函数当中只要出现了循环变量就会报错
--------------------------------------------------------------
arguments.length			transparent		-->透明
-----------------------------------------------
###	keyup	keydown		focus	blur
keyup		keydown		键盘抬起	键盘按下
inputNode.onkeyup = function(event){}
keyCode		键盘键码
inputs[i].checked = true;this.index.style.display
----------------------------------------------------------
哪一块需要3D空间		给其父元素开启3D空间
transform-style:preserve-3d;-->3D效果
transition:all 1s;
box.onmouseenter = function(){this.style.transform = 'rotateY(180deg)';}
box.onmouseleave = function(){this.style.transform = 'rotateY(0deg)';}		-->transform永远相当于开始的状态来变化，如果还是rotateY(180deg);-->那么就相当于没有变化
------------------------------------------------------------
childNodes-->某个元素的子节点--》包含空格	换行等
#comment		是注释
children-->子元素
parentNode-->父节点
parentElement-->父元素
firstChild-->第一个子节点
firstElementChild-->第一个子元素节点
previousSibling-->上一个兄弟节点
previousElementSibling-->上一个兄弟元素节点
nodeType-->元素节点值
------------------------------------------------------
**createElement想创建的元素名		appendChild	被追加的元素对象		创建列表**
document.write('');-->根本不用
document.write()只能在页面加载的过程中使用	如果页面加载完成之后
再使用会将其他的dom干掉	
document.createElement-->创建元素
var ulNode = document.createElement('ul');-->创建了ul
for(var i = 0; i < movies.length; i++){
	var liNode = document.createElement('li');-->创建了li
	liNode.innerText = movies[i];
	ulNode.appendChild(liNode);-->追加li元素
}
document.body.appendChild(ulNode);-->创建了ul并且显示出来
--------------------------------------------------------
节点常用的方法		文档中都是节点		元素  文本  属性  注释
插入节点:inserBofore		-->在..之前去插入节点
替换节点:replaceChild		
删除节点:removeChild		
追加节点:appendChild		
-----------------------------------------------------------
dom0		dom2有自己的独立的事件绑定和解绑方式
dom1是来遵守w3c的一些规则		dom3没有
**dom2事件如果对同一个元素添加相同的元素，会依次执行，不会覆盖**
**removeEventListener--->函数解绑用到**
**addEventListener--->来绑定事件监听**
btns[0].attachEvent('onclick',fn);-->IE10以下的会用到
-----------------------------------------------------------
##	事件流
**捕获事件流(网景)--》从外到内--》true		冒泡事件流(ie)--》从内到外->false		标准DOM事件流--》现用的最标准的事件流		包含三个阶段：捕获		获取元素		再冒泡		捕获和冒泡我们通常选择冒泡**
**event.stopPropagation();-->	阻止了冒泡发生**
**事件冒泡的好处就是可以进行事件委派(事件委托，事件代理)**
**阻止冒泡**
事件冒泡(event capturing） ：
当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window 。（注意这里传递的仅仅是事件 并不传递所绑定的事件函数。所以如果父级没有绑定事件函数，就算传递了事件 也不会有什么表现 但事件确实传递了。）
e.stopPropagation();
-----------------------------------------------------------
**事件委派**
新添加的行为		做法：
						--》给爹添加事件，不给元素本身添加，事件发生后通过爹去寻找，真正发生事件的元素处理
ulNode.onmouseover = function(event){
    var liNode = event.target;-->**寻找发生事件的儿子ulNode里面寻找liNode**
    liNode.sty..;
}-->**事件的委派**
-----------------------------------------------------------
**onmouseenter onmouseleave		如果是父子元素模型		当鼠标移入父元素的子元素的时候事件没有移出再移入		事件没有切换**
**onmouseover	onmouseout		如果是父子元素模型		鼠标移入父元素的子元素的时候事件会移出再移入		事件有切换**
-----------------------------------------------------------
**window对象是Bom的顶级对象**
location		window.location		页面地址
				window.location.href		重定向地址
history			历史记录
navigator		是一个只读对象	浏览器本身的信息
				navigator.appName	
				navigator.appVersion		浏览器版本
screen			屏幕
				screen.width		screen.height
				screen.availWidth	screen.availHeight
onresize		函数来说明窗口大小的改变
-----------------------------------------------------------
`event`
event.target || event.srcElement		-->当前事件的源
`clientX	clientY相对于视口左上角的位置`
`offsetX	offsetY相对于元素左上角的位置`
`pageX 		pageY相对于整个页面左上角的位置	带上滚动条滚动的距离`
`screenX	screenY相对于屏幕左上角的位置`
-----------------------------------------------------------
###		JS操作的所有样式都是行内样式
**rotate(0)-->直接绕Z轴转动**
-----------------------------------------------------------
**setTimeout(function(){},1000)**
-->	单次定时器:一般用来做延迟效果		定时炸弹
**清除定时器**
-->	clearTimeout(timer(timer是一个对象));
**定时器的操作是异步的		前面有一个定时器 后面其他代码	并不会等待定时器结束再来执行		而是直接执行	相当于程序同时执行两段代码 操作时异步的**
**多次定时器		setInterval(function(){},3000)	三秒执行一次代码function()		清除clearInterval()**
-----------------------------------------------------------
**for while循环时同步操作的**
-----------------------------------------------------------
Offset系列		只读
			OffsetWidth	-->拿的是盒子	内容+	padding border
			clientWidth	-->盒子内容	+padding
			scrollwidth	-->内容比盒子小的时候	拿的是clientWidth
						-->内容大于盒子的时候	拿的是OffsetWidth加上盒子一侧的内边距
## 视口宽高求法
document.documentElement.clientWidth
document.documentElement.clientHeight
拿元素的宽高	如果元素没有边框	那么clientWidth	OffsetWidth是一样的
--------------------------------------------------------------
###		clientLeft	clientTop		拿到盒子边框的大小
offsetLeft		offsetTop		拿到盒子的水平偏移量和垂直偏移量
scrollLeft		scrollTop		拿到滚动条滚动的距离
--------------------------------------------------------
## 初始包含块
初始包含块就是第一屏视口(浏览器厂商直接赋予的)		--》初始包含块是html body之外的
初始包含块	--》html	-->body	-->自己写的布局结构
html以及body控制的overflow:hidden	是作用在初始包含块里面的
没设置position的时候		元素初始相对于初始包含块的
-----------------------------------------------------------
系统滚动条有两个		body和document
body 或者 html单独设置overflow:scroll	滚动条打开的全是document的
body 和 html 都设置overflow:scroll	那么Html打开document身上的滚动条		body打开自己身上的滚动条
**禁止系统滚动条**
html,body{
	height:100%;-->为了让overflow:hidden 更有说服力	内容超出才会被掩藏或者出现滚动条
	overflow:hidden;
}
**pc端的move事件不会自动清除**
**dom0事件取消浏览器的默认行为**直接在函数里面return false;
浏览器会有些自带的拖拽行为
**dom2事件取消默认行为**event.preventDefault();
**box.setCapture && box.setCapture()元素发生事件之后**
元素的所有的事件行为会被捕获到元素身上
**box.releaseCapture&&box.releaseCapture()-->释放全局捕获**
--------------------------------------------------------
##		自制滚动条
滚动条的高度/屏幕的高度=屏幕的高度/内容的高度=滚动条移动的距离/内容的滚动距离 
--------------------------------------------------------
**正则表达式是描述字符模式的对象**
用于字符串模式匹配和检索替换的，是对字符串执行模式匹配的强大工具
外部函数的this指向window
**call		apply函数**
--------------------------------------------------------
**new一个构造函数实例化**
原型对象的本质：普通的Object实例
每个实例对象都有一个_proto_
# 原型对象
![原型对象](picture/原型对象,jpg.jpg "原型对象")
![img](picture/bootstrap.jpg "bootstrap")
##	原型链
 1. **查找对象的属性的时候	先自身找	没有就沿着_proto_来找	没有就继续_proto_来找	直到找到Object的原型对象来找**
 **原型链就是沿着_proto_查找这条链的原型链**
 2.实例对象的隐式原型对象_proto_和Object类的显时原型对象prototype同地址		Object的显式原型对象的隐式原型对象值是null
 ##		隐式原型不可以被操作	所以叫做隐式原型
------------------------------------------------------
#	debugger;
暂停程序的执行	scources来调试
断点跳过		单步调试
------------------------------------------------------
# 执行上下文会有压栈处理	先压global	script收集let
-	script和global不是平级的	平级意味终点有两个
##	变量提升	函数提升
1.	js引擎正式执行代码之前	会预解析
2.	找var function
-	**全局的预解析在定义函数的时候不关心函数是否被使用**
-	**函数局部预解析的时候如果内部函数没有被使用就不会提前定义**
###	执行上下文的变量对象
-	js引擎进入执行上下文环境之后创建一个变量对象
-	对象来手机执行上下文环境中的：变量	函数	函数参数	this
-	确认this指向
-	创建作用域链
###	执行上下文栈
-	执行上下文式动态创建的	针对函数	函数每调用一次就创建一次执行上下文		执行完就销毁	
#	作用域
## 只有全局作用域	函数作用域		**没有对象作用域**
###	作用域链
-	作用域链是一个数组结构
-	该结构内保存的是一个个变量对象
-	作用链在js代码正式执行之前执行的
####	创建全局作用域--》预解析--》创建全局执行上下文--》执行上下文环境--》全局变量对象
-	函数创建局部作用域	函数自身有一个[scopes]	上一级作用域链(global)
#	闭包
-	闭包就是一个引用关系	引用关系存在于内部函数中	引用的是外部函数的变量的对象 
##	如何产生闭包
-	函数嵌套
-	内部函数引用外部函数的局部变量
-	使用内部函数
##	闭包的作用
-	延迟外部函数变量对象的生命周期(既是优点也是缺点)
	(占内存，如果不及时清除容易造成内存溢出，泄露)	那么使用完闭包之后就应该快速清除释放设置为null
-	让函数外部可以间接操作到函数内部的数据
##	闭包的生命周期
-	产生：在嵌套内部函数定义执行完时产生了
-	在嵌套的内部函数成为垃圾对象时
##	闭包的应用
#	递归调用	尘归尘土归土	扩展开来想象以及还原	归元
-	new Foo().getName()-->先new 了Foo()实例再去找getName()函数
-	new Foo.getName()-->直接找Foo.getName()这个整体
-	new new Foo().getName()-->等同new Foo().getName()
-	console.log(1,console.log(2));-->2 1 undefined
-	**console.log()是一个函数 没有返回值**
**返回函数		以及返回函数值**
**对象里面的key都是字符串**
#	工厂函数模式
-	工厂函数
function person(name,age){
	return{
		name:name,
		age:age
	}
}
-	构造函数
function Person(name,age){
	this.name = name;
	this.age = age;
}
var person1 = new Person('kobe',12);
Person.prototype.showName = function(){
	console.log(this.name);
}-->原型对象去添加共享函数
-	Object模式
对象属性书写繁琐	重复
##	优点是批量生产	缺点是实例化的对象不知道是属于哪一类
###	Object的原型对象最好不要去动
#	原型继承		子类的原型成为父类的实例	我们去手动拼接原型链
-->父类Person		子类Child
-->**Child.prototype = new Person();**
-->会出现的问题	没有继承之前	
Child.prototype = {constructor:Child}	有constructor	但是继承之后就没有了
那么我们就要去手动添加
Child.prototype.constructor = Child;
## Child  复用	Person的代码
1.	可以用Person构造函数来实现继承	Person.call(this,name,age)
2.	当然也可以用原型继承
#	进程 线程
-	进程是程序的一次执行，占有一定的内存空间
-	线程是CPU的基本调度单位	多个进程之间的数据是不可共享的
-	双核浏览器Trident webkit..也就是渲染引擎速度 兼容性这些东西
-	alert会主色后面代码的执行
**js是单线程的	代码会阻塞	js代码分两种	同步代码和异步代码**
-	同步会阻塞后续代码的执行	同步没有回调
-	异步不会阻塞	异步有回调
#	钩子函数就是回调函数	轮询机制
	定时器会托管给定时器管理模块	
	callback queue	回调队列
	当主线程上所有的同步任务执行完毕会通过轮询机制来询问callback queue是否有可执行的回调函数		
	setTimeout后面不要写运算量大的代码	定时器是非阻塞的 会继续询问后面的可执行代码	耽误定时器执行	导致不准时
**定时器不准时因为js是单线程的**
setTimeout后面加入alert会阻塞定时器	因为alert有阻塞性质
定时器什么时候开始记时
#	webworker
worker.prototype.onmessage	用于接收另一个线程的回调函数
worker.prototype.postmessage	向另一个线程发送信息
##	模拟js 分线程
**函数本身也是对象**可以Person.show();-->函数对象调用函数
var worker = new Worker('./worker.js');
worker.onmessage = function(){
	console.log('分线程发送的数据',msg.data);
}
###	模拟分线程
onmessage = function(msg){
	console.log('主线程发送过来的数据',msg.data);
	var result = msg.data.toUpperCase();
<!-- 分线程发送数据 -->
postMessage(result);
}
## call stack 压栈队列
###		递归实现斐波那契数列
function a(n){
	return n>=3?a(n-1)+a(n-2):1;}
#	ECMAscript	ECMA组织制定和发布的脚本语言规范
stringfiy()-->js对象转换为json对象
parse()-->json对象转换为js对象
##	ES5的扩展的静态方法		
**Object.create()**
--》指定地去创建一个新的对象。并指定原型对象
var obj2 = Object.create(obj);指定obj为obj2的隐式原型对象_proto_
当然还可以添加obj2的新属性
var obj2 = Object.create(obj,{
	sex:{value:'nan',
	`writable:true`//**属性可以修改**},
	age:{value:43}
});
`writable:true`//**标识属性可以修改**
configurable-->**标识属性可以被删除true**
enumerable-->**标识属性可以用for in俩枚举**
## Object.defineProperies	配置对象
###	get方法的作用	提供扩展属性的值
###	set方法在修改扩展属性的时候会自动调用	用来监视扩展属性	不可在set方法当中修改扩展属性	否则出现死循环	可以借助第三方变量来修改
-	存储器属性	getter setter一个用来取值  一个用来监视属性
-	添加的key必须是字符串	加上引号''
var obj = {
	name:'kobe',
	age:42
}
Object.defineProperties(obj,{//配置对象
	sex:{get:function(){
		console.log('get()');
		return '男';
	},
	set:function(msg){
		console.log('set()',msg);
	}}
})
-	obj2数据复制到obj3里面
var obj2 = {name:'kobe',age:42}
var obj3={};
for(var item in obj2){
	if(obj2.hasOwnProperty(item)){
		console.log(item,':',abj2[item]);
		(function(item){
		Object.defineProperties(obj3,{
			[item]:{
				get:function(){
					return obj2[item];
				},
				set:function(msg){
					obj2[name] = msg;
				}
			}
		})
		})(item)
	}
}
# Array
-	arr.indexOf(value)-->值在数组中的第一个下标
-	arr.lastindexOf(value)-->值在数组中的最后一个下标
-	arr.forEach(function(item,index){})-->遍历数组
-	arr.map(function(item,index){})-->遍历数组返回加工后的数组
-	arr.filter(function(item,index){})-->返回符合条件的数组
var newArr =arr.map(function(item,index){
return item+10;-->返回加工后的每一项
});
var newArr = arr.filter(function(item,index){
	return item>3;
})
#	ES6
-	ES6		ES2015
-	在块作用域里有效
-	不可以重复声明
##	let
-	let提升的变量在没有赋值之前那不允许被使用
1.	用来声明变量
2.	变量提升
	-	全局变量提升
		-	会创建一个变量对象(script)用来收集全局作用域下let定义的变量		但是没有赋值	不会成为window对象的属性	script是window的下级		因为压栈是不会平行去压栈的
	-	局部变量提升
		-	会将var let定义的变量全部放到当前函数的变量对象中
	-	let的应用	**变量的解构赋值**	按需索取
	let obj2 = {username:'kobe',age:42};
	let {username,age} = obj2;
	-->方便了变量的声明使用--》全局来用	
	let arr = [1,2,3];
	let [,,a] = arr;-->数组的解构赋值	a的值为3
	--》**函数形参来解构实参**
	funtion fun({username,age}){
		console.log(username);
		console.log(age);
	}
3.	循环遍历加监听	let声明变量i
	for(let i = 0; i < btns.length; i++){
		vat btn = btns[i];
		btn.onclick = function(){
			alert(i);
		}
	}
### 箭头函数 箭头左侧是参数的位置	右侧是函数体的位置
-	箭头函数没有形参的时候	()小括号不可省略
   		let fun = () => console.log('fun()');
-	有一个形参的时候	括号随意
		let fun1 = (a) => console.log('只有一个形参的时候',a)
		let fun1 = a => console.log('只有一个形参的时候',a)
-	有多个形参的时候	括号不省略
		let fun2 = (a,b) => console.log('多个形参的时候',a,b)
-	函数体只有一条语句的时候	大括号可以省略	大括号省略的时候会自动return当前语句或者表达式的结果
		let fun3 = () => console.log('函数体只有一条语句的时候')
-	函数体有多条语句的时候	不可省略大括号	要手动return 否则return undefined
		let fun4 = () => {let a = 12;console.log('多条语句');}
-	this指向:
		箭头函数没有自己的this,箭头函数的this不是调用的时候决定的，而是定义的时候处在的上下对象就是它的this	window或者外部函数对象的this
-	箭头函数不可以用作构造函数
## 伪数组
-	arguments是用来收集实参的伪数组
-	有length属性	可以通过下标获取相应的值	但是没有数组的一般方法	push filter map
##	...运算符
-	用来取代arguments	比arguments更加灵活
-	扩展运算符(拆包)...arr
		原理:三点运算符会调用iterator接口	如果底层有这个接口	那就可以去遍历数组
##	symbol
-	是ES6提供的一种新的原始数据类型
-	基本数据类型:String number boolean null undefined Symbol
-	typeof返回值:string number boolean undefined Symbol object function
-	symbol的值是唯一的
##	iterator是一种接口机制	为各种不同数据结构提供统一的访问机制
-	创建一个指针对象	指向数据结构的起始位置

##	const	常量不可以被修改
###  模板字符串 let str = `我的名字是${obj.user},我的年龄是${obj.age}`
#	对象调用toString 数组调用toString 两者是不一样的
因为数组里面重写了Object原型里面的toString方法
#	定义检测数据类型的方法
function checkoutType(target){
	return Object.prototype,toString.call(target).slice(8,-1);
}
# for in 枚举对象属性的
**for in枚举对象 当然也可以遍历数组的下标注意是下标**
# 深度克隆
//obj保存的对象的内存地址	引用传递
let obj = {username:'kobe',age:43}
let obj2 = obj;
obj2.username = 'wade'
console.log(obj.username);
//变量保存的是基本数据类型	保存值的本身	值传递不影响原数据
let num = 123;
let num2 = num;
num2 = 234;
console.log(num);
##	深拷贝(值传递)	浅拷贝(引用传递)
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
判断深拷贝还是浅拷贝	修改拷贝后的数据修改后会不会影响原数据
arr.concat()是数组的
**浅拷贝**
let arr = [1,2,3];
let testArr = [4,5];
let arr2 = [];
arr2 = arr.concat();
console,log(arr2);
**slice函数**
let str = 'abcdef';
console.log(str.slice(3));-->输出def
console.log(str.slice(3,5));-->输出de   包含开始下标为3的数不包含结尾
#	jQuery	是js的框架	是js的函数库	是基于js来制作的 
-	项目上线的时候，一般用比较靠谱的CDN资源库
-	$()和jQuery()是一样的
-	jQuery对象是伪数组对象
-	伪数组对象是只有数组的length属性和可以用下标来访问
-	window.jQuery=window.$=jQuery
-	$是function	$()执行完返回的是对象	$.each(arr)工具对象和$('#box')是jQuery对象	两者没有必然联系
-	$()参数是选择器字符串	查找所有匹配的标签	并将他们封装成jQuery对象
-	jQuery大部分方法返回的是this
#	ES7
	指数运算符	**	3**3//27(幂运算)
	Array.prototype.includes(value)//判断数组中是否包含指定的value
#	2D变换
transform:translate(200px) scale(0.5);//盒子平移200px 再缩放0.5倍
transform: scale(0.5) translate(200px)//盒子先缩放0.5倍 再来平移100px
##	scale在translate前面   那么translate会随着scale的倍率来平移
##	一个元素的变换  旋转平移  坐标轴会随元素左上角的元素点变换
#	ps alt+f9	打开动作栏	可以选择载入可用的动作
#	bootstrap是一个框架	应用型框架	移动设备优先	用于开发响应式布局
用bootstrap  的同时也要引入jQuery	bootstrap是基于jQuery的
##	响应式的好处 		写得好可以适配所用情况
	响应式的坏处		代码量大	维护成本高	
	container-fluid//流式布局
col-lg-3大屏列显示的宽度（总宽度是12）	col-md-12中屏	col-sm-6小屏
col-md-offset-3		-->列距离左边的距离
col-md-push		--》向右边推
col-md-pull		-->向左边拉		是向上兼容的	设置的分辨率小于当前分辨率的时候 依然生效			否则失效
abbr标签是一个缩写词或者首字母的缩略词
例如	`<abbr title="Park">P</abbr>`
`<blockquote>引用来源标签`
xs		尺寸<768
sm		尺寸>=768
md		尺寸>=992
lg		尺寸>=1200
shift+space 切换为全角--》再来打出的空格就是中文字符的空格
在代码敲错的情况下	调试中文空格的难度很大
##	栅格系统是12份的
### sass是基于less移植的
#	移动端
inch 是英寸	foot是英尺
1foot=12inch	1inch=2.54cm
##	设备独立像素	也称设备无关像素	简称DIP
普通屏幕下面 1个设备独立像素等于1物理像素
高清屏幕下面 1个设备独立像素等于N物理像素
###	css像素也叫逻辑像素
###	一个位图像素对应一个物理像素	图片才能完美清晰显示
###	设备独立像素的出现可以在高分辨率的情况下也可以正常尺寸的显示元素	用多个物理像素去表示一个CSS像素
####	iphone6的参数必须记住
设备像素	750*1334
设备独立像素	375*667
ppi		326
###	像素密度PPI	屏幕上每英寸可以显示的像素点的数量	单位是ppi
开方(x*x+y*y)/屏幕尺寸=ppi
获取像素比	window.devicePixelRatio
##	pc端缩放会影响布局		移动端缩放不会影响布局
##	理想视口
`<meta name='viewport' content='width=device-width,initial-scale=1.0',minimum-scale=1.0,maximum-scale=1.0,user-scaleable=no> `
可视窗口宽度	window.innerWidth	
布局视口	document.documentElement.clientWidth
##	980px是浏览器厂商设置的布局视口的初始宽度
##	initial-scale为页面初始化的显示比例	scale=屏幕宽度独立像素/布局视口宽度
##	minimum-scale	屏幕独立像素宽度/视觉视口
## 	maximum		最大缩放比例 
##	touchstart		手指点击
##	touchmove		手指移动	即使手指离开了元素	touchmove事件也会持续触发
##	touchend		手指抬起
##	touchcancle		手指触摸打断(例如电话..)
-	location.href='http://..';
-	location.replace('http://..');
-	location.assign('http://..');-->页面跳转
##	去除默认行为
e.preventDefault();
#	window.oncontextmenu=function(){
	e.preventDefault();
}**oncontextmenu**
#	手机端练习
##  解决点击穿透问题
-	函数参数传递一个参数
然后        e.preventDefault();-->解决了穿透问题
-	
##	touch事件结束后会默认触发元素的click事件	若没有完美视口	那么 
##	计算时间点的间隔
var t1= Date.now();//获取当前时间的毫秒数
-	也等同于	var date = new Date();
var t1 = date.getTime();
##	这样就表明了对象是一个非常好的东西
可以在box里面添加t1   t2属性
两者相减的得到时间差box.t2-box.t1
##	获取html标签		document.documentElement.
document.documentElement.addEventListener('touchstart',function(e){
	//阻止默认行为
	e.preventDefault();
},{
	**passive:false;**//被动模式	默认是true 就是说preventDefault()默认是不起作用的
})
##	元素本身有点击穿透的问题	那么可以在最外边添加div来	用div来添加事件监听	e.preventDefault();	点击是click  不是touch事件
##	用其他东西来代替a标签
`<div class='item' data-href="http://.."><div>`//data-href是用来代替a标签
location.href=item.dataset.href;
##	防止点击穿透也可以用延时操作来避免
setTimeout(function(){
	el.style.display='none';
},400)
##	a标签和touchstart相比		效率touchstart更加快
-	但是从SEO优化上来看	a标签效果更加好
##	SEO
SEO做好的话		少用js来创建元素
search engine	optimization-->搜索引擎优化
网站SEO做的越好		网站排名越靠前
##	爬 虫只会爬到源代码	不会爬到js动态创建的数据
##	手机屏幕长按会出现默认行为
##	获取鼠标点击的坐标
e.clientX		e.clientY
<!-- client是相对于视口 -->
e.pageX			e.pageY
<!-- page是相对于总的页面来说 -->
##	获取当前按键的信息
window.onkeydown=function(e){
	console.log(e.keyCode);
}
##	字符码表
汉字的
gb2312  gbk
繁体
big5
unicode表示任何语言的任何文字	**统一码**
##	ctrl+c弹出alert
if(e.keyCode==67 && e.ctrlKey){
	alert('你按下了ctrl+c');
	e.preventDefault();//阻止默认行为
}
##	禁止普通用户复制
window.oncontextmenu = function(e){
	e.preventDefault();
}
##	touchstart事件重要属性
-	changedTouches	当前元素同一时间点同时按下的触点
-	targetTouches	当前元素的触点个数
-	touches			不仅限制当前元素	而是整个屏幕触点的个数
##	touchmove事件的重要属性
-	changedTouches	当前元素同一时间点同时滑动的触点
-	targetTouches	当前元素的滑动触点个数
-	touches			不仅限制当前元素	而是整个屏幕滑动触点的个数
##	touchend事件的重要属性
-	changedTouches	当前元素同一时间点同时抬起的触点
-	targetTouches	结束时候	当前元素的触点个数
-	touches			不仅限制当前元素	结束时候	而是整个屏幕触点的个数
##	获取手指离开元素时的位置
只可以用changedTouches
##	获取触点的信息
var	x = e.changedTouches[0].clientX;
###	margin  padding使用的时候会影响周围元素的布局	但是用定位的left等属性	脱离了文档流	就不会影响周围元素的布局
##	适配问题		核心在于等比缩放
-	viewport适配
`<meta name='viewport' content='width=375(直接等于设计图宽度)',user-scalable=no'>`
-	用的少	会有兼容性问题
-	rem适配
-	em和rem
-	em参照的父级元素的font-size
-	rem参照的根元素的font-size
##	rem设配方法
###	方法一
![img](picture/rem适配图.jpg "rem")
-	步骤
1.	完美视口设置
2.	设计稿总宽375布局
3.	设置font-size 100px尺寸转为rem
4.	增加js代码进行页面适配
5.	js代码
document.documentElement.style.font-size=document.documentElement.clientWidth*100(设置的font-size)/375+'px';
window.onresize=function(){
	document.documentElement.style.font-size=document.documentElement.clientWidth*100(设置的font-size)/375+'px';
}
###	方法二rem适配和less的结合
1.	less文件里面@font-size:设计稿的宽度/10rem
除以的数字也可以为其他数字
2.	上边的rem作用时为了进行字符串拼接
3.	元素css的样式
.box{
	width:200px;
	height:200px;
}转换为了
.box{
	width:200/@font-size;
	height:200/@font-size;//这里200的数字完全是根据设计稿来的
}
html里面的js代码
document.documentElement.style.font-size=document.documentElement.clientWidth/10+'px';
window.onresize=function(){
	document.documentElement.style.font-size=document.documentElement.clientWidth/10+'px';
}
##	rem适配问题的总结
1.	定值
375是设备独立像素 100是font-size 那么100px=1rem
2.	定比例+less
##	蓝湖是一个生态	自动标注距离信息
##	window.devicePixelRatio;
返回当前显示设备的物理像素分辨率与CSS像素分辨率之比。
##	1px边框的问题
解决方法
1.	用伪类选择器来解决
.box1::after{
	content:'';position:absolute;
	left:0;bottom:0;width:100%;height:1px;background:#000;
}
2.	内容的整体缩放
//整体的缩小	initial-scale	设备独立像素宽度/布局视口的宽度
375--》750		那么initial-scale=0.5		布局视口变大那么整体就缩小了
`<script>var fontSize = 50;	
document.documentElement.style.fontSize=fontSize+'px';
	var dpr = window.devicePixelRatio;	
	var initialScale=1/dpr;		
	var meta = document.querySelector('meta[name=viewport]');meta.content='user-scalable=no,initial-scale='+initialScale;
	//内容放大
	var newFontSize = fontSize * dpr;
	document.documentElement.style.fontSize=newFontSize+'px';
	</script>`
##	用正则来实现定值转换rem 
var res = str.replace(/(\d+)px/g,function(val,group){
	console.log(val);//正则匹配的符合的数据	g表示全局
	return group/100+'rem';
})
##	classactive是元素对象的属性	用来操作元素的class类
-	add 增加类名
-	 remove	移除类名
-	contains	是否包含指定的类名
-	toggle	切换类名的有无
##	色块测试

### 	幸福感就是0和1的差距
##	 网页当中图片的加载时间相比于代码的加载时间是很长的所以在js里面要用到图片参数的时候	把图片参数放到window.onload = function()里面
onload是等待所有资源加载完毕之后才会处理的函数
##	懒加载
页面的一种效果 提高页面的加载速度		降低服务器带宽资源的损耗
##	让图片不加载
-	删除图片的src属性
-	自定义一个属性来保存src对应的值
##	getXXXByXXX 获取的是动态集合，querySelector获取的是静态集合。

-	简单的说就是，动态就是选出的元素会随文档改变，静态的不会，取出来之后就和文档的改变无关了。静态集合用appendChild就会报错
<ul>
    <li>aaa</li>
    <li>ddd</li>
    <li>ccc</li>
</ul>
 
//demo1
var ul = document.getElementsByTagName('ul')[0],
      lis = ul.getElementsByTagName("li");
for(var i = 0; i < lis.length ; i++){
     ul.appendChild(document.createElement("li"));
}
console.log( lis.length);  //6
 
//demo2
var ul = document.querySelectorAll('ul'),
      lis = ul.querySelectorAll("li");
for(var i = 0; i < lis.length ; i++){
     ul.appendChild(document.createElement("li"));
}
console.log( lis.length);  //3
##	10vh是视口高度的10%
vw参照水平视口来看
## input获取焦点
var input = document.querySelector('.search');
input.addEventListener('touchstart',function(e){
	e.stopPropagation();//阻止冒泡
})
-	input丧失焦点	就是点击其他地方来让其焦点丧失
app.addEventListener('touchstart',function(e){
	input.blur();//input丧失焦点
})
##	ctrl+g直接定位到行
##	canvas画布	网页上来绘制图像
-	游戏
-	图表
-	广告
-	地图
-	图形处理
## 	canvas的宽高设置必须在行内属性去设置	canvas的默认大小是300*150		不能使用css来设置宽高
##	e.target当前元素的子元素	target属性
###	getComputedStyle(e.target)	获取了元素子元素的计算之后的CSS样式
##	 save()保存		restore()恢复在canvas画布里面很重要
##	设置渐变	createLinearGradient
下面这个函数是0,0	-->canvas.width,canvas,height	点到点
 ctx.createLinearGradient(0,0,canvas.width,canvas.height);
下面这是径向渐变
ctx.createRadialGradient(300,200,20,300,200,100);
300,200是径向渐变的中心点	20和100是渐变半径
##	文字水平对齐	text-align
ctx.textAlign = 'left'..start  end ..
##	垂直对齐	textBaseline
ctx.textBaseline = 'top';..
##	阴影设置
        // ctx.shadowColor='#99d';
        // ctx.shadowOffsetX=10;
        // ctx.shadowOffsetY=10;
        //阴影模糊程度
        // ctx.shadowBlur=10;
        // ctx.fillRect(100,..)
## 在定时器里面 清除画布很重要
ctx.clearRect(0,0,1000,1000);
##	图形合成
   //source-in图形的共同的部分
    ctx.globalCompositeOperation='source-in';
	图形合成要用到的属性globalCompositeOperation和参数
	source-..是源图形去掉
 ctx.globalCompositeOperation='destination-out';
 	destination-..是新图形去掉
##	图形的绘制也讲究属性的前后设置
ctx.fillStyle='#ccc';
ctx.fillRect(0,0,600,400);
-	fillStyle要在fillRect前面	不然就是黑色而不是灰色
### 调整画笔宽度
        ctx.lineWidth=10;
###	那只能说是先列后行了
function getPixel(imgData,x,y){
            var index = y*4*imgData.width+x*4;
            //
            var d = [];
            d[0]=imgData.data[index];
            d[1]=imgData.data[index+1];
            d[2]=imgData.data[index+2];
            d[3]=imgData.data[index+3];
            return d;
        }
##	transition时间的设置也很重要	这样才能看到变换
###	             li.style.transition = 'transform 0.5s '+(key*40)+'ms'
这里我总是在出错	就是在0.5s后面应该要跟上一个空格
##	图片水平居中的方法		三句话
 display: flex;
            justify-content: center;
            align-items: center;
#	版本控制
bug平台		禅道	
-	集中式	有所谓的核心

-	分布式	没有所谓的核心
服务器	:配置高	安装了专业的服务器操作系统	有极佳的网络环境 
-	硬盘格式
-	异地容灾备份
-	SVN的一些操作
1. 检出
2.	提交
3.	更新
4.	版本回退
有可能产生冲突
a和b 修改了同一个文件的同一位置	产生了冲突	
手动处理冲突就会很重要
HB---->可以加壳		网页变成了应用
避免冲突的好原则是更改的时候先更新
还有就是提交前先更新
配置忽略文件
*.idea
-	给文件来加锁
-	清理SVN队列
##	局域网
	192.168.0.1
##	城域网
##	广域网
##	IP地址
	分类
			局域网IP

			公网IP
			cmd 
				输入命令ping www.baidu.com
				得到百度IP
				输入命令ipconfig
				得到自己的网络配置
##	MAC地址		各个设备的‘指纹’				
#	hbuildx发行安装音乐台	app图标必须是png格式
hbuilder'做壳'很好
#	Linux
	林纳斯开发的
	10天写完git	git是基于linux的	是一个微型的linux的虚拟机
		是分布式的管理工具
##	Linux的一些命令
1. mkdir xxx 新建文件夹
2. vi xx.txt	新建编辑文件	然后摁下i进入编辑模式
								可以ESC+:+wq	保存并且退出
								ESC+:+q+！	不保存并退出
3.	cd ..  翻到上一层
4.	ls列出当前盒子当中的文件
5.	cat xx.txt 显示文件的内容
6.	clear直接清屏
#	Git
##	上方向键可以直接复制上一行的代码到当前行


