##  箭头函数

-   箭头函数没有prototype(原型)，所以**箭头函数本身没有this**
-   箭头函数的this在定义的时候继承自外层第一个普通函数的this。
-   如果箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)
-   箭头函数本身的this指向不能改变，但可以修改它要继承的对象的this。
-   箭头函数的this指向全局，使用arguments会报未声明的错误。
-   箭头函数的this指向普通函数时,它的arguments继承于该普通函数
-   使用new调用箭头函数会报错，因为**箭头函数没有constructor**
-   箭头函数不支持new.target
-   **箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名**
-   箭头函数相对于普通函数语法更简洁优雅
-   箭头函数不能当做Generator函数,不能使用yield关键字(python)
-   箭头函数不能绑定arguments，取而代之用rest … 参数
-   let C = (...c) => {
		console.log(c);
		}

##  rmf宏任务和微任务

-   ”JS是单线程的”指的是JS 引擎线程。
-   在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。
    Node环境中，只有JS 线程。
-   当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。

-   Event Loop
-   **JS引擎常驻于内存中，等待宿主将JS代码或函数传递给它**。
    也就是等待宿主环境分配宏观任务，反复等待 - 执行即为事件循环
    Event Loop中，每一次循环称为tick，每一次tick的任务如下：
    执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；
    检查是否存在微任务，有则会执行至微任务队列为空；
    如果宿主为浏览器，可能会渲染页面；
    开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。

-   在ES3以及以前的版本中，JavaScript本身没有发起异步请求的能力，也就没有微任务的存在。在ES5之后，JavaScript引入了Promise,
    不需要浏览器，JavaScript引擎自身也能够发起异步任务了。

-   ES6 规范中，microtask 称为 jobs，macrotask 称为 task
    宏任务是由宿主（Node、浏览器）发起的，而微任务由JavaScript自身发起。

-   宏任务
    -   1. script (可以理解为外层同步代码)
        2. setTimeout/setInterval
        3. UI rendering/UI事件
        4. postMessage，MessageChannel
        5. setImmediate，I/O（Node.js）

-   微任务
    -   1. Promise
        2. MutaionObserver
        3. Object.observe（已废弃；Proxy 对象替代）
        4. process.nextTick（Node.js）

-   async和await是如何处理异步任务的
    -   async是通过Promise包装异步任务。
    -   async function async1() {
		await async2()
		console.log('async1 end')
		}
		async function async2() {
		console.log('async2 end')
		}
		async1()
    -   当调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 **await的时候会就让出线程**开始执行 
        async1 外的代码（可以把 await 看成是让出线程的标志）。

-   Node.js是运行在服务端的js，虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一
    些I/O，比如新的网络连接等，所以与浏览器Event Loop不太一样。
-   Node里面对setTimeout的特殊处理：setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)。

-   Promise，process.nextTick谁先执行？
-   process.nextTick() 是一个特殊的异步API，其不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进
    行，会马上停下来执行process.nextTick()，这个执行完后才会继续Event Loop。
-   nextTick和Promise同时出现时，肯定是nextTick先执行，原因是nextTick的队列比Promise队列优先级更高。

##  取反运算符（补码全部位置取反  包括符号位）

-   ~正数补码
    -  取反变为负数 被认为是负数的补码
    -   负数补码还原回源码的样式输出
-   ~负数补码
-   ~x = -(x+1)
    -   对原来数据取反减去1
-   可以用来取整    去除小数位数
    -   ~~x
##  flex布局        (容器和项目对应)

    它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

-   容器

    flex-direction  **属性决定主轴的方向（即项目的排列方向）**
        row（默认值）：主轴为水平方向，起点在左端。
        row-reverse：主轴为水平方向，起点在右端。
        column：主轴为垂直方向，起点在上沿。
        column-reverse：主轴为垂直方向，起点在下沿

    flex-wrap   **属性定义，如果一条轴线排不下，如何换行。**
        nowrap（默认）：不换行。
        wrap：换行，第一行在上方。
        wrap-reverse：换行，第一行在下方。

    **flex-flow**属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap

    justify-content 属性定义了**项目在主轴上的对齐方式。**
        flex-start（默认值）：左对齐
        flex-end：右对齐
        center： 居中
        space-between：两端对齐，项目之间的间隔都相等。
        space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

    align-items 属性定义**项目在交叉轴上如何对齐**
        flex-start：交叉轴的起点对齐。
        flex-end：交叉轴的终点对齐。
        center：交叉轴的中点对齐。
        baseline: 项目的第一行文字的基线对齐。
        stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

    align-content   属性定义了**多根轴线的对齐方式**。如果项目只有一根轴线，该属性不起作用。
        flex-start：与交叉轴的起点对齐。
        flex-end：与交叉轴的终点对齐。
        center：与交叉轴的中点对齐。
        space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
        space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
        stretch（默认值）：轴线占满整个交叉轴。

-   项目

    order属性定义项目的**排列顺序**。数值越小，排列越靠前，默认为0。
    flex-grow属性定义**项目的放大比例**，默认为0，即如果存在剩余空间，也不放大
    flex-shrink属性定义了**项目的缩小比例**，默认为1，即如果空间不足，该项目将缩小。
    flex-basis属性定义了在分配多余空间之前，**项目占据的主轴空间**（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
    **flex属性是flex-grow, flex-shrink 和 flex-basis**的简写，默认值为0 1 auto
    align-self属性允许**单个项目有与其他项目不一样的对齐方式**，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
-   flex总结
    -   容器
        -   flex-flow:row               nowrap;
                        ^                   ^
                    项目排列            项目换不换行
        -   justify-content     -->     项目**主轴**怎么对齐（center(居中)flex-start(项目靠左对齐)space-between(居中等间距))
        -   align-items         -->      项目**交叉轴**怎么对齐 (center(居中对齐)baseline(项目第一行文字的基线对齐))
        -   align-content   -->     多根轴线的对齐方式(flex-start(交叉轴起点对齐))

##  meta标签设置网页的元数据   一般用来告诉浏览器如何解析网页
							--》name设置属性的名字
							-->content设置属性的内容
							--》description用于告诉搜索引擎网页的主要内容
##  p标签不放任何块元素
##  ##	base64 用来将图片转换为字符串   直接在页面加载时候就可以用   提升速度	不可读	
##  iframe  src  引入外部网页   iframe不会被爬虫解析
-	iframe的name和a标签的target属性值是一样的	达到了绑定的目的
-	<a href="https://www.baidu.com" target='myIframe'>baidu</a>
	<iframe name='myIframe' frameborder="0"></iframe>
##  选择器
##  span + p{}兄弟元素
        span ~ p{}选择后面的所有p兄弟元素
        div>p+tab //就生成了div 里面有个 p
##  +  {1,}   x + y{}同级别的兄弟       x ~ y{}x后面的兄弟
##  div p:first-child{}//div的第一个子元素必须并且是p 才成立 
    div p:first-of-type{}//div的p类型中的第一个
##  属性选择器   [title]{}//有title 这个属性的 时候就执行内容
        [title='hello']{} / /title为hello
        [title^='h']{} // title以h开头
		a[src*="baidu"] // src 属性中含有 abc 的每个 a 标签
		a[src$=".pdf"] // src 属性中以 .pdf 结尾的每个 a 标签
-   内联1000>id100>类和伪类10>元素1
##  visibility:hidden;			-->不显示元素但是占领位置
    但是 		display		-->不显示元素且不占领位置
##  <a>里面什么都可以放</a>
##  box-shadow-->设置阴影		和轮廓一样		就是加上一个特效
    box-shadow:（inset）20px 20px 10px #ffe;-->第一个值正值向右移动
                                    --》第二个值正值向下移动
                                    --》第三个值越大阴影就越模糊
                                    --》inset  表示内部阴影  	默认外部阴影
                                    --》可以设置多重阴影
##  脱离文档流的元素全是块元素

##  BFC是元素的一个隐藏属性		一旦元素开了BFC他将会开启一个独立的布局区域
-   设置元素浮动可以开启BFC	before   after是伪元素
    CLEAR   来清除浮动元素的影响
    .clearfix:after,.clearfix:before{
        content: "";
        display: table;
    }
    .clearfix:after{
        clear: both;
    }
-	在浮动元素后使用一个空元素如<div class="clear"></div>	并在CSS中赋予.clear{clear:both;}		
-	给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动
-	给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动
-	BFC 形成相对于外界完全独立的空间	让内部的子元素不会影响到外部元素
	-	块级格式化上下文	是页面中的一块渲染区域	有着自己的渲染规则
	-	
##  z-index:1..   父元素层级再高不会盖住子元素
##  opacity:		-->用来设置元素的不透明度
##  元素设置了		absolute，那么margin:0 auto;就不管用了 	除非设置的时候left top right bottom 设置为0   	
    margin:auto;-->就会水平居中
-   **元素设置了定位** 		那么就多了left bottom right top 这几个值
    -   元素定位之后   多了left		right
				-->记住left:0;right:0;
				-->margin:0 auto;-->这样才会居中			auto代表就是平分距离

-   position  	默认值是static 	表示没有开启定位
-   text-align:-->left		左对齐
                -->right		右对齐
                -->center
                -->justify		文本两端对齐
    vertical-align-->baseline		沿基线对齐
                    --》sub		下标
                    --》super	上标
                    --》bottom	沿父元素底部对齐
                    --> top		沿父元素顶部对齐
                    --》middle	相对于小写子母的middle对齐
##  min-width 	max-width		最小宽度		最大宽度
    --》浏览器缩小放大的时候不改变框的大小
##  line-through		文本删除线
    over-line 		上划线
##  CSS Sprite(CSS精灵),雪碧图
                -->有效降低了发送请求的速度，提升用户的体验，降低图片的总大小
                -->降低加载的速度
                -->只适用于背景图片background-image
##  第一次刷新的时候为什么会闪烁呢
                因为图片这些外部资源只会在页面在加载之后，有页面请求的时候在来加载
                图片需要使用的时候才来加载就会闪烁这种叫做懒加载
##  小三角
    .div_9{
    width: 0;
    height: 0;
    border: 10px solid black;
    border-color: transparent transparent black transparent;
    }
##  transition:all 4s 1s;		-->第一个值是执行动画的属性
        -->第二个值执行动画的时间
        -->第三个值要延迟多久才来执行动画
-   transition实现了过渡效果		交互效果		类似动画效果但不是动画

##  ico文件就是web网站标签的图标
##  transform:translateX();		-->沿着x轴方向平移
				translateY()	-->沿着y轴方向平移
				translateZ()	-->沿着z轴方向平移	元素距离用户的距离
##  perspective		-->视距  设置人的眼睛和网页之间的距离	让视觉有3D效果
-   perspective:100px;-->不宜过小
    transform-style: preserve-3d;		-->**添加3D效果**
    perspective: 800px;                 --》眼屏距离
##  npm可以下载和上传
    **cnpm只可以下载**
##  darken()函数用来加深颜色
    background-color:darken(yellow,20%);	-->加深了黄色


##  less
-   @a:10px;
    .box1{
        width:@a;
        height:10px;
        .box2{}
    }	
-   .box1{
	width:160px;
	height:$width;
    }
            -->使用$符号来直接引用其他的值
            -->使用变量的时候就近原则
-   .box2{
	.box1();
        }								-->box2里面来使用box1的样式*
-   .hello(@a,@b){
	width:@a;
	height@b;
	background-color:#f00;
    }			--->简化了开发 		要引入的时候就引入
    -   .wrapper{
            .hello(300px,500px);	}	
                    -->简化了开发		减少了代码量
-   @import "demo02";		-->将外部的less文件来导入当前less文件

##  var age;		-->undefined		-->定义变量未赋值	-->里面存的就是undefined
-   null		-->空类型		var obj = null;-->一般定义对象的时候来使用	用于对象初始化或者删除一个对象的时候来使用
-   !==			--->不全等于
-   num+1		-->是一个表达式 
-   Number();			-->强转类型函数		若字符串看起来不是一个数字	那么转换为NaN		而不是数字		true->1		
    false->0        undefined-->NaN
-   parseInt(a)		-->提取整数		--》a="123adf"-->a==123
								-->a="asf123"-->a==NaN
-   1/0			--》infinity	-->无穷大
##  栈结构			--》先进后出	有序的	栈底	栈顶	栈是独享的
    堆结构			--》随意增删		堆是共享的
##  预解析只会解析带var的变量,不带var的,不进行预解析
-   预解析优先级		
			--》先去解析函数	函数如果有同名会发生覆盖
			-->再去解析var变量
-   匿名函数	不会发生预解析
##  Object是原型对象的原型对象
    对象找属性的过程形象地成为原型链
##  一般我们等待页面加载完成后		--》才去操作dom元素
-   window.onload		-->页面加载完成事件
##	textContent		innerText	的区别
    textContent	可以获取隐藏元素的文本		包括换行和空白**visible:hidden	的元素可见**
    innerText		不可获取隐藏元素的文本
##  keyup		keydown		键盘抬起	键盘按下
    inputNode.onkeyup = function(event){}
    keyCode		键盘键码
##  document.body.appendChild(ulNode);

##  DOM0(原始事件模型) DOM1 DOM2(标准事件模型) DOM3
-   **dom0事件取消浏览器的默认行为**直接在函数里面return false;

	-	DOM0级事件	绑定速度快	页面还未加载	以至于事件可能无法正常进行	只支持冒泡

	-	同一个类型的事件只能绑定一次	多个同类型的事件绑定	后面的绑定事件会覆盖前面的绑定事件

	-	事件绑定监听函数的两种方式

		-	HTML代码中直接绑定		<input type='button' onclick='fun()'>

		-	通过 js 代码绑定事件		document.getElementById('IDBTN').onclick = fn

-   **dom2事件取消默认行为**event.preventDefault();		标准事件模型

	-	标准事件模型分为三个阶段	事件捕获阶段	事件处理阶段	事件冒泡阶段

	-	事件绑定监听函数	addEventListener(eventType, handler, useCapture)

	-	可以在一个 DOM 上绑定多个事件处理器	各自不会冲突	会依据写入的次序	依次执行代码

**onmouseenter onmouseleave		如果是父子元素模型		当鼠标移入父元素的子元素的时候事件没有移出再移入		事件没有切换**
**onmouseover	onmouseout		如果是父子元素模型		鼠标移入父元素的子元素的时候事件会移出再移入		事件有切换**

##  location		window.location		页面地址
    window.location.href		重定向地址

##  clientX	clientY             相对于**视口**左上角的位置
-    offsetX	offsetY         相对于**元素**左上角的位置
     pageX 		pageY           相对于整个页面左上角的位置	带上**滚动条滚动**的距离
     screenX	screenY         相对于**屏幕**左上角的位置

##  针对的是元素
    offsetWidth	-->拿的是盒子	        content  	padding border
    clientWidth	-->盒子                 content	    padding
    scrollwidth	-->内容比盒子小的时候	拿的是clientWidth
                -->内容大于盒子的时候	拿的是OffsetWidth加上盒子一侧的内边距
    clientLeft	    clientTop		拿到盒子边框的大小
    offsetLeft		offsetTop		拿到盒子的水平偏移量和垂直偏移量
    scrollLeft		scrollTop		拿到滚动条滚动的距离

## 视口宽高求法
    document.documentElement.clientWidth
    document.documentElement.clientHeight
##  系统滚动条有两个		body和document
    body 或者 html单独设置overflow:scroll	滚动条打开的全是document的
    body 和 html 都设置overflow:scroll	那么Html打开document身上的滚动条		body打开自己身上的滚动条
    禁止系统滚动条
##  __proto__   -->  prototype
## 	变量提升	函数提升
1.	js引擎正式执行代码之前	会预解析
2.	找var function
-	**全局的预解析在定义函数的时候不关心函数是否被使用**
-	**函数局部预解析的时候如果内部函数没有被使用就不会提前定义**
-  	执行上下文栈
	执行上下文式动态创建的	针对函数	函数每调用一次就创建一次执行上下文		执行完就销毁	
-   作用域
    只有全局作用域	函数作用域		**没有对象作用域**
##	rmf作用域
-	局部作用域
-	全局作用域
-	作用域决定了这些变量的可访问性（可见性）。
-	JavaScript 只有声明的变量会提升，初始化的不会
-	严格模式
-	消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
	消除代码运行的一些不安全之处，保证代码运行的安全；
	提高编译器效率，增加运行速度；
	为未来新版本的Javascript做好铺垫。
-	函数内部定义的变量从函数外部是不可访问的（不可见的）。
-	在 JavaScript 函数中声明的变量，会成为函数的局部变量。
-	由于只能在函数内部识别局部变量，因此能够在不同函数中使用同名变量。
-	如果您为尚未声明的变量赋值，此变量会自动成为全局变量。
-	在“严格模式”中不会自动创建全局变量。
-	在 HTML 中，全局作用域是 window。所有全局变量均属于 window 对象。
-	JavaScript，全局作用域形成了完整的 JavaScript 环境。
-	作用域嵌套的查询规则：
	首先，JS引擎从当前的执行作用域开始查找变量。
	然后，如果找不到，引擎会在外层嵌套的作用域中继续查找。
	最后，直到找到该变量，或抵达最外层的全局作用域为止。
-	function foo(b) {
    console.log(a + b) // 4
	}
	foo(2)
	var a = 2
-	NaN			因为foo函数前面没有a的赋值	那么就获取不到a的值	那么就得到答案NaN
-	如果对未声明过的变量进行赋值：
	在非严格模式下，JS引擎会为其自动创建一个全局变量且进行赋值。
	如在严格模式下，会导致 ReferenceError 异常
-	词法作用域（静态作用域）
	词法作用域就是定义在词法阶段的作用域，简单说就是函数的作用域在函数定义的时候就决定了。
	词法作用域查找规则是：作用域查找是从内到外进行查找的，直到找到第一个匹配的标识符时停止。
-	函数中的参数是局部作用域
-	function foo(obj) {
    with (obj) {
        b = 4
        a = 2
		}
	}
	var obj = {
		b: 3
	}
	foo(obj)
	console.log(obj.a) // undefined
	console.log(obj.b) // 4
	console.log(a)  // 2，a被当前全局变量泄露到全局作用域上了
-	使用关键字 let 或 const 定义块级作用域的变量。
-	a = 10
	var a
-	var a 和 a = 10 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务
-	if语句中的变量会预解析	变量提升
-	函数声明和变量声明都会被提升，但是出现在有多个“重复”声明的代码中，函数会首先被提升，然后才是变量。
	函数没有方法重载，存在两个相同的函数名，后面的函数会覆盖前面的函数。
-	函数前面调用执行的是函数重复的结果		函数后面调用执行的是函数变量提升之后的结果
-	foo() // 3
	function foo() {
		console.log(1)
	}
	var foo = function () {
		console.log(2)
	}
	function foo() {
		console.log(3)
	}
	foo() // 2 函数表达式的提升情况
-	函数预解析的情况是
-	foo(){console.log(3)}
	var foo
	foo()
	foo = function(){console.log(2)}//对象该在哪里赋值就在哪里赋值
	foo()
-	function fn(){
        console.log(a);
        var a=45;
        console.log(a);
    }
-	undefined-->45		首先是变量提升		声明但是未定义
-	var obj = {
        val:2,
        dbl:function(){
            var val = 45;
            console.log(this);
            this.val*=2;
            console.log(val);
            console.log(this.val);
        }
    }
    var ff = obj.dbl();
    var fn=obj.dbl;
    fn();
-	{val:2,dbl:f}	45 4 window  45 NaN
-	obj对象里面的函数属性中的this指定的是obj的this		不是函数局部的this
-	把对象的函数属性赋值给变量		那么函数的this指针不再指向对象obj	而是指向window对象
-	var x = 10;
	function fn() {
		console.log(x)
	}
	function show(f) {
		var x= 20;
		f();
	}
	show(fn);
-	结果是10		原因是**每个函数都有自己独立的执行环境**		调用函数来帮忙		但是函数依照自己定义的地方来执行函数结果
-	var obj = {
            fn2:function () {
                console.log(fn2);
            }
        }
        obj.fn2();
-	对象里面调用要用到this指针 的指向问题		这里没有用到this指针出现问题
-	用了this指针会输出fn2的函数形式
-	当函数与变量同名时，函数会覆盖掉变量
-	由于JavaScript是单线程的，只有一个执行栈，如果每次都要等的话是很不好的，所以会先把setTimeout函数先放进一个任务队列中，等到执行栈中执行完了之后再完成任务队列中的任务。
-	for(let i = 0;i < 5;i++){
	}
	console.log(i);
-	i is not defined
-	块级作用域里面用let和const声明的变量就不会被外部访问到
-	for(var i=0;i<=5;i++){
	console.log("hello");
	}
	console.log(i);
-	相同的函数名	变量名	声明的时候会函数优先	预解析使用的时候是函数优先的
-	let没有变量提升		但是有暂时性死区	就是说使用let const变量在声明之前使用是会报错的
-	var变量提升是首先赋值为undefined		但是let const 是没有赋值的	存在暂时性死区状态	只有定义赋值之后才可使用let const变量
-	其实let const 变量是提升了的		但是规定不可再其声明前使用变量而已		索引这一特性称为暂时性死区
-	用const声明恒定变量	声明的同时就必须赋值	否则会报错
-	在if或则for语句里面定义的函数，函数名变量会同步到和函数同一个作用域下	同步作用域会影响全局变量的使用
-	同步作用域的时候记住函数实际的位置		若相同的变量名在前面赋值了	变量的值会同步到相应的if for所在的作用域的下面
-	function foo() {
	var val = 'hello';
	function bar() {
		function baz() {
		val = 'world;'
		};
		baz();
		console.log(val); //=> world
	};
	bar();
	};
	foo();
-	var doc = document;
	for(var i = 0; i < 10000; i++){
		var but1 = doc.getElementById("but1");
	}
-	先把全局对象的变量放到函数里面先保存下来，然后直接访问这个变量
-	数组数据的插入比较快的方法
-	arr[arr.length] = target
-	[target].concat(arr)
-	用splice向中间插入元素是最快的
-	a < b?a:b比起使用Math.min()速度会更加快
-	return function(){}	在循环里面使用是相互独立的返回数据		数据可以独立维护
-	(function(i){return function(){console.log(i)}})(i)
-	封装成函数。在封装函数的时候，善用运用回调函数
-	flex子元素宽度超出父元素的时候		超出宽度ow		子元素宽度sw1 sw2..
-	子元素宽度	sw1 = sw1 - ow*(sw1*sw1Shrink1/(sw1*sw1Shrink+sw2*sw2Shrink))
-	自身宽度(200px)- A减小的宽度(100px * (200px * 3/(200 * 3 + 300 * 2))) = 150px
-	flex布局就是子元素宽度超出父元素就会缩小	用到缩小公式
-	父元素有所剩余就是会根据数值来按照一定比例来分配所剩下的数据值
-	flex-basis优先级是大于width
#	闭包
-	闭包就是一个引用关系	引用关系存在于内部函数中	引用的是外部函数的变量的对象 
##	如何产生闭包
-	函数嵌套
-	内部函数引用外部函数的局部变量
-	使用内部函数
##	闭包的作用
-	延迟外部函数变量对象的生命周期(既是优点也是缺点)
	(占内存，如果不及时清除容易造成内存溢出，泄露)	那么使用完闭包之后就应该快速清除释放设置为null
-	让函数外部可以间接操作到函数内部的数据
-	外部函数  里面定义了一个内部函数	内部函数访问使用了外部函数定义的变量属性  然后外部函数最后返回的
	是内部函数
	外部函数的代码无法访问内部函数的变量	但是内部函数的代码可以访问外部函数的变量
	外部函数执行完毕	执行期间创建的变量不会销毁  每运行一次函数就会在内存里面留下一组变量
	闭包的特性可以实现模块模式  用一个函数包裹模块代码 将不需要暴露的变量隐藏起来  好处是不会污染全局变量空间
	node.js就是将别人要调用的方法return  就实现了模块化
	可以同匿名函数自调用的形式来使用闭包
	(function(i){
		return function(){
			alert(i)
		}
	})(i)
	函数里面创建另一个函数会造成速度和性能的浪费
	每一次执行外部函数  都会重新创建一个内部函数
	可以用原型来解决
##  console.log(1,console.log(2));-->2 1 undefined
-	**console.log()是一个函数 没有返回值**
##  #	工厂函数模式
-   	工厂函数
    function person(name,age){
        return{
            name:name,
            age:age
        }
    }
    -	构造函数
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
##  Person.call(this,name,age)
-    Child  复用	Person的代码
##  进程 线程
-	进程是程序的一次执行，占有一定的内存空间	是程序**分配**和执行管理资源的基本单位	是计算机资源的基本单位
-	线程是CPU的基本**调度**单位	多个进程之间的数据是不可共享的	是进程的一部分
##  钩子函数就是回调函数	轮询机制
-   当主线程上所有的同步任务执行完毕会通过轮询机制来询问callback queue是否有可执行的回调函数	
-   setTimeout后面**不要写运算量大的代码**	定时器是非阻塞的 会继续询问后面的可执行代码	耽误定时器执行	导致不准时
-   **定时器不准时因为js是单线程的**
##  webworker
    worker.prototype.onmessage	用于接收另一个线程的回调函数
    worker.prototype.postmessage	向另一个线程发送信息

##	rmf原型链
-	任何对象都有一个隐式原型对象  Object的__proto__为null
-	对象的隐式原型指向构造函数的显式原型对象
-	显式原型有着一些函数的属性和方法
-	js沿着沿着原型链没有找到属性或者方法返回undefined
## 	ES5的扩展的静态方法		
-   **Object.create()**
    --》指定地去创建一个新的对象。并指定原型对象
    var obj2 = Object.create(obj);指定obj为obj2的隐式原型对象_proto_
    当然还可以添加obj2的新属性
    var obj2 = Object.create(obj,{
        sex:{value:'nan',
        `writable:true`//**属性可以修改**},
        age:{value:43}
    });
    `writable:true`//**标识属性可以修改**
    `configurable`-->**标识属性可以被删除true**
    `enumerable`-->**标识属性可以用for in俩枚举**
-    **Object.defineProperies	**配置对象****
-	get方法的作用	提供**扩展属性的值**
-   set方法在修改扩展属性的时候会自动调用	用来**监视扩展属性**	不可在set方法当中修改扩展属性	否则出现死循环	可以借助第三方变量来修改
-   添加的key必须是字符串	**加上引号''**
    var obj = {
        name:'kobe',
        age:42
    }
    Object.defineProperties(obj,{//配置对象
        sex:{get:function(){
            console.log('get()');
            return '男';
        },
        set:function(msg){
            console.log('set()',msg);//set有引号
        }}
    })
-	**obj2数据复制到obj3里面**
var obj2 = {name:'kobe',age:42}
var obj3={};
for(var item in obj2){//in来遍历对象
	if(obj2.hasOwnProperty(item)){
		console.log(item,':',abj2[item]);
		(function(item){
		Object.defineProperties(obj3,{
			[item]:{
				get:function(){//获取
					return obj2[item];
				},
				set:function(msg){//设置
					obj2[name] = msg;
				}
			}
		})
		})(item)
	}

##  rmfArray
-	arr.forEach(function(item,index){})-->遍历数组  不改变原来数组      只有抛出异常才会中止    break不
	可中止   不返回fi数据
-	arr.map(function(item,index){})-->遍历数组返回加工后的数组      返回数据    
-	arr.filter(function(item,index){})-->返回符合条件的数组
-	arr.join('')		数组里面的元素连接成字符串
-	arr.concat(arr2)	不会改变原来数组	而是会**返回新的数组**
-	arr.slice(s,e)		不会修改原数组 **返回新的子数组**	**左闭右开**	slice(-1)代表的是倒数第一个
-	arr.splice(start,count,[value1,value2,..])
-	arr.reverse()	直接**修改原来数组**	**返回数组地址**
-	arr.sort()	修改原来数组	将数组字典序排序	**返回数组地址**
-	arr.indexOf(target)	arr.lastIndexOf(target)	返回target在数组中第一次出现的位置	最后一次出现的位置
-	arr.forEach((value,index)=>{})	循环数组	没有返回值
-	arr.map((value,index)=>{})	循环数组	有返回值
-	arr.toString()	类似于arr.join(',')		注意是用','连接形成的字符串
-	arr.unshift('value1','value2',...)	数组开头插入元素
-	arr.shift()	弹出数组最开头的元素	修改原数组	返回被弹出的元素
-	arr.push()	返回数组的length
-	arr.pop()	返回被弹出的数组元素
-	let a = arr.every(item =>{return item>0});console.log(a);//数组全部元素满足条件返回true
-	let a = arr.some(item => {return item>3});console.log(a);//数组中遇到符合条件的就会退出循环	有一个符合就返回true	
-	否则返回false
-	let a = arr.filter(item => item>20);console.log(a)//过滤出大于20的元素		组成一个新的数组
-	let a = arr.reduce((total,value,index,arr)=>{return total+value})
-	value是可选的	不指定初始值	会将数组中的第一个元素作为初始值	index不传入初始值	index是从1开始	总的
	循环的次数是数组的	长度减去1		传入初始值	index是从0也就是第一个元素开始	
-	index传入就是0		不传入就是1
-	value index两个都不指定		return x		返回的就是数组元素的第一个元素
-	arr.reduceRight
	reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低（从右到左）处理数组。
-	arr.find		let a = arr.find(item => {return item.id === 2})
-	arr.findIndex()
	找出第一个符合条件的数组成员，没找到返回 undefined。
-	1.find()与findIndex()参数与用法相同，不同的是find返回元素，findIndex返回索引；找不到时find返回
	undefined，findIndex返回-1.
	2.findIndex()与indexOf()，findIndex比indexOf更强大一些，可以通过回调函数查找对象数组，indexOf只能查找数组中指定的值，不过indexOf可以指定开始查找位置的索引
-	find findIndex里面的参数是回调函数(item,index)=>{}	而indexOf(item)参数就是需要查询的值
-	arr.indexOf(23,5)//从5的位置开始查找23
-	arr.includes()
	表示某个值是否在数组里，includes() 不接受函数参数。
-	arr.copyWithin(target,start,end)	start end之间是复制的值		target是复制的值去往的目的地
-	end没有的话	复制到target的位置为止
-	arr.entries()	创建并返回数组可迭代的对象	var x = arr.entries()
-	x.next().value		可迭代对象迭代输出数据的方法		.next().value
-	实现二维数组	new Array(n).fill(0).map(()=>new Array(n).fill(0))
-	实现函数对象数据的赋值		就是直接用var变量 来赋值	不需要this	
-	var fn = function(){var stack = []}		不需要用this来指定数据变量的数据的设置
-	var a = new Array(5); //指创建**长度为5的数组** 
	var a = new Array([5]); //指创建一个数组，**长度为1，并且第一位是5**
-	push unshift**返回的是新数组的长度**
-	pop shift splice**返回的是移除的元素值**
-	arr.length=5; //将数组的长度减少到5，**索引等于或超过5的元素被丢弃**
	-	可以用来数组去除元素
	-	length属性是如此的神奇，利用它可以方便的增加或者减少数组的容量
-	用 prototype 属性**提供对象的类的一组基本功能**
-	constructor 属性保存了**对构造特定对象实例的函数的引用**



##  let提升的变量在**没有赋值**之前那**不允许被使用**
-   a is not defined        **NG**
-   而var变量的是       可以使用不过是undefined
-   变量提升
	-	全局变量提升
		-	会创建一个**变量对象(script)**用来收集全局作用域下let定义的变量		但是没有赋值	不会成为window对象的属性	script是window的下级		因为压栈是不会平行去压栈的
	-	局部变量提升
		-	会将var let定义的变量全部放到当前函数的变量对象中
		-	但是**只有使用var关键字声明的变量才会被初始化undefined值**，而let和const声明的变量则不会被初始化值。
-   let的应用	**变量的解构赋值**	按需索取
    -   let obj2 = {username:'kobe',age:42};
        let {username,age} = obj2;
	-->**方便了变量的声明使用**--》全局来用	
## 	...运算符	可以打包	解包
-	用来取代arguments	比arguments更加灵活
##  Object.prototype.toString.call(target).slice(8,-1);
##	2D变换
-   transform:translate(200px) scale(0.5);//盒子平移200px 再缩放0.5倍
    transform: scale(0.5) translate(200px)//盒子先缩放0.5倍 再来平移100px
-   **scale在translate前面**   那么translate会随着scale的倍率来平移
-	scale 只对可以定义宽高的元素生效	span 元素需要转换为 inline-block 才可以使用 scale
##	响应式的好处 		写得好可以适配所有情况
	响应式的坏处		代码量大	维护成本高	
##  window.onkeydown=function(e){
	console.log(e.keyCode);
    }
##  document.querySelector('.search');
##  e.target当前元素的子元素	target属性
##  save()保存		restore()恢复在canvas画布里面很重要
##   清除画布很重要
      ctx.clearRect(0,0,1000,1000);
##  git是基于linux的
-   是一个微型的linux的虚拟机
-   git分为三个区域
-   工作区	暂存区	版本区
-  	git add xx.txt	添加指定文件到暂存区
-	git status	工作区状态	文件绿色代表在暂存区	红色在工作区
-	git reset --hard HEAD^	回到上一个版本
-	git reset --hard HEAD^^	回到上两个版本
-	git reset --head 版本号		回到指定的版本号
-	git checkout --x.txt	暂存区指定文件区替换工作区的指定文件
-	git rm -- cached x.txt  取消暂存区刚刚的提交文件
-	git rm x.txt	删除文件
-	git rm  -r xxx	删除文件夹
##  style标签是html解析器来异步解析的	那么就会有闪屏可能
-   link引入css样式就会避免闪屏	css解析器是同步的	就不会有闪屏
-   无论css js阻塞都不会阻塞外部资源的请求
-   defer的作用	defer紧随dom解析之后	使用之后可以知道dom解析什么时候解析完
##  前端优化
-	使用cdn节点进行外部资源加速
-	css进行压缩
-	减少http请求数	多个css文件进行合并
-	优化样式表代码
##	缓存机制
-	浏览器在本地磁盘上将用户之前请求的数据存储起来	用户再次改数据的时候无需再次发送请求	直接从浏览器本地获取数据
-	缓存的好处
	-	减少请求的个数
	-	节省带宽	减少浪费不必要的网络资源
	-	减轻服务器压力
	-	提高浏览器网页的加载速度	提高用户体验
-	缓存的分类	请求成功的资源状态码是200ok
	-	强缓存
		-	不会向服务器发送请求	直接从本地缓存中获取数据
	-	协商缓存
		-	向服务器发送请求	服务器根据请求头的资源判断是否命中协商缓存
		-	如果命中	则返回304状态码通知浏览器从缓存里读取资源
	-	强缓存和协商缓存的共同点
		-	都是从浏览器读取数据
	-	强缓存和协商缓存的不同点
		-	强缓存不会请求服务器
		-	协商缓存会请求服务器	根据服务器返回的信息决定是否使用缓存
-	强缓存里的header参数
	-	expires		指定具体日期强缓存到期
	-	cache-control:max-age=..(可以强缓存的时间)
	-	cache-control优先级高于expires
-	协商缓存
	-	Last-Modified上一次修改的时间是什么时候
	-	if-Modified-Since和Last-Modified一起控制协商缓存
	-	Etag解决了last-modified难解决的问题
	-	etag和if-none-match	一起解决协商缓存
		-	一些文件也许会周期性更改	但是内容并不会改变	
		-	某些文件修改频繁	一秒内修改n次
		-	某些服务器不能精确得到文件的最后修改时间
##  单线程处理不好cpu密集型任务
###	浏览器的js由哪几部分组成
-	BOM		window浏览器对象模型	很多的API(location,history)
-	DOM		document文档对象模型	很多的API(对DOM的增删改查)
-	ES规范		ES5	ES6	
###	node端的js由及部分组成
-	没有了BOM	因为服务器不需要	服务器没有浏览器对象	没有window
-	没有了DOM	没有浏览器窗口	就是没有document
-	几乎包含了所有的ES规范
-	没有了window 取而代之的式一个global的全局变量	node中禁止函数指向global		而是指向了一个空对象
##	node事件循环模型	有六个阶段	1.timers 2.pending callbacks	3.idle,prepare	4.poll	5.check	6.close callbacks
-	timers()	定时器阶段	计时	setTimeout	setInterval	执行定时器的回调
-	pending callbacks()	系统阶段	准备系统内置的东西
-	idle,prepare	准备阶段
-	poll	轮询阶段式核心	
	-	如果回调队列有待执行的回调	那么就去回调函数	同步执行	
	-	如果回调队列为空	
	-	如果有设置过setImmediate	进入下一个check阶段
	-	如果没有设置setImmediate	则停留 等待回调函数插入回调队列
	-	若定时器到点了	进入下一个check阶段		原因式为了走阶段	直到下一个阶段
-	check	专门用于执行setImmediate所设置的回调
-	close callbacks()	关闭回调阶段
-	process.nextTick()-----用于设置立即执行函数()---'人民币玩家'	在任意阶段都优先执行	但还是怕主线程
###	setImmediate设置立即执行函数		clearImmediate
-	**回调函数天生是要等其他忙完再执行的**	不是定时器
-	这里涉及到计时速度和轮询的速度关乎到定时器和setImmediate的先后顺序
-	**在主线程上加了代码	影响了轮询速度和定时器速度**	因为线程消耗的时间为定时器争取了时间		否则就只看轮询时间和计时开始时间	
###	process.nextTick()	是用来设置立即执行函数		process.nextTick高于定时器	是特殊的
##	commonJs是双端的js模块化规范	服务器端	浏览器端	只有commonjs是双端的
###	commonjs引入模块必须按顺序引入	服务器端比较敏感	干活有顺序
-	暴露模块
	-	module.exports = value;
	-	exports.xxx = value;
	-	export是es6里面的语法
	-	module1.js	对象
		-	module.exports = {data:..,test(){}}
	-	module2.js	函数
		-	exports.haha = function(){
		}
	-	module3.js	数组
		-	exports.perqi = [1,2,34,5,6];
	-	可以引入对象	函数	数组...
	-	创建了module1.js	modules2.js	module3.js来暴露对象	函数...
	-	app.js里面来引入module1.js....
		-	let module1 = require('./modules/module1');..
		-	let {data,test}=require('./modules/module1');
		-	引入的同时	进行解构赋值
		-	'./'必须写清楚	要加上
		-	let xx = ..来引入
		-	这里写了路径	就是说不是在node_modules里面去找	而是去自定义那里去找
		-	let a = require('uniq');//当然在npm i uniq之后这样来引入	默认去node_modules里去找
		-	uniq([1,2,3,45,6,7,12,23,45,12,34])
		-	这样写是字典排序并且去重1 12 2 23 3.. 
###		commonJs模块化内置的一个关系	module.exports ={} exports ={}		{}暴露出的对象	module.exports和exports以module.exports为主
##	不使用模块化的缺点
-	文件冲突
-	不便于维护
-	不便于按需加载
##	浏览器里面没有require	window.require
-	服务器	和	浏览器里运行js可能有天壤之别
-	浏览器不认识require		那么会用browserify
	-	npm i browserify -g			全局安装在c盘		4048表示权限不够	要以管理员身份打开9
	-	有些东西是不可全局安装的
	-	**browserify js/src/app.js -o js/dist/peiqi.js**	borwserify将A目录下的js翻译到了B目录		使得浏览器认识翻译后的js文件
#	ES6		相应的暴露方式对应各自的引入方式	es6可以混合暴露
-	暴露模块
	-	结构
	-	js
		-	src
			-	module1.js..
			-	app.js
	-	index.html
	-	分别暴露
	-	统一暴露
	-	默认暴露	优点写法简单	import uniq from 'uniq'
-	module1.js	分别暴露
	-	export let data = ''
		export funtion demo(){}..
-	module2.js	统一暴露
	-	let arr = []
		function demo2(){}
		function test2(){}
		export{demo2,test2}//统一暴露函数	精简版写法
		export{demo2 as h1,test2 as h2}		完整版写法
-	module3.js	默认暴露		只能暴露一次	只能写一次	否则报错
	-	export default {
		name:'',age:,speak(){}
	}
-	app.js	汇总modulexxxx.js的js文件
-	引入模块
	-	分别暴露的引入
	-	import {data,demo1,test1} from	'./module1'
	-	分别暴露引入的另一种方式	import * as haha from './module1'
	-	统一暴露的引入
	-	import {demo1,test1} from	'./module2'
	-	统一暴露引入的另一种方式	import * as haha from './module2'
	-	默认暴露的引入
	-	import module3 from './module3'
	-	默认暴露引入的另一种方式	import * as haha from './module3'	但是尽量不要用这种方式
	-	混合暴露	包含分别暴露	统一暴露	默认暴露
	-	再来引入	import {} from ''	import module from ''
	-	当然两种引入方式也可以一起用	import module,{} from''
	-	上面默认暴露的	应该写在最前面
##	浏览器不认识es6模块化语法	那么要用到 babel来翻译转换
-	babel是facebook的
-	babel可以把es6==》es5
-				jsx==>js	jsx必须闭合
##	cli:command line interface	命令行接口工具	babel的'经纪人'
-	npm i babel-cli -g	**babel体积大**
-	npm install babel-preset-es2015	--save-dev
-	创建.babelrc文件	rc = run control	运行控制	在包里直接创建这个运行时控制文件
-	babel在干完		babel xxx.js -d xx.js
-	只是转换后的js文件可能是commonjs模块规范的 	那么就还要操作
-	browserify xx.js -o xx.js	这样才能转换成功	浏览器才认识
#	AMD-RequireJS
-	结构
	-	js
		-	lib//放一些第三方的库
		-	modules
		-	定义没有依赖的模块
-	定义没有依赖的模块
-	define(function(){
	//数据只读
	let data = 'atguigu'
	function getDataL(){
		return data.toLowerCase()
	}
	return {getDataL};
})
-	定义一个有依赖的模块
-	define(['module1'],function(module1){
	let msg = '',
	function getDataAndMsg(){}
	return getDataAndMsg
})
-	app.js里面来设置requirejs
	-	requirejs.config({

	})
-	AMD模块化中	也要用特殊的引入方式	移入require.js
-	AMD模块化用jquery	不用jQuery
-	baseUrl:''	//开始的根目录就是index.html所在的目录
-	404请求资源未定位
#	CMD模块化
-	module1.js
	-	define(function(require,exports,module){})
-	module2.js
	-	define(function(){})
-	module3.js
	-	define(function(){
		//引入module2	同步引入
		let module2 = require('./module2')
		//异步引入
		require.async('./module1',function(m3){})
		module.exports = {}
	})
-	汇总js配置	main.js
	-	define(function(require){
		let module1 = require('./module1')..
	})
-	index.html里面来引入sea.js
-	`<script>seajs.use(./../main)</script>`
##	buffer缓冲器
-	buffer是和数组类似的对象		不同的是buffer是专门来保存二进制数据的
-	buffer大小一旦确定就不可修改
-	buffer效率很高	存储和读取很快	直接对计算机的内存进行操作
-	每个元素占用内存的大小为1字节		就是8bit
-	buffer是node 的核心模块	无需下载
##	node里面的文件操作
-	**简单文件写入(异步文件写入)**
-	fs是node的核心模块	无需下载 但是要引入
-	let fs = require('fs')//引入内置的fs
-	fs.writeFile('路径','写的内容',{mode:0o444},(err)=>{
	if(err){

	}else{

	}
})//调用writeFile方法
-	sync是同步的		async是异步的
	-	fs.writeFile(file,data[,options],callback)
	-	file是要写入的文件路径
	-	data要输入的数据
	-	options	可选参数
		-	encoding	设置文件的编码方式	默认似乎utf-8
		-	mode	设置文件的操作权限
					默认值是0o666=0o222+0o444
					0o111是文件可被执行的权限
					0o222文件可被写入的权限
					0o444文件可被读取的权限	mode:0o444
		-	flag	打开文件要执行的操作	默认值是'w'
			-	w写入
			-	a追加		flag:'a'
	-	callback	回调函数
	-	err	错误对象
##  关系型数据库只能使用硬盘
###	如何判断对象是否为空对象
-	JSON.stringify(errMsg !== '{}')//true为不是空对象
##	rmfcookie
-	存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie
-	存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销
-	身份认证信息就特别适合放在cookie中
-	每个域名下的cookie 的大小最大为4KB
-	JS 原生的 API提供了获取cookie的方法：document.cookie	这个方法只能获取非 HttpOnly 类型的cookie
-	cookie选项来设置的，cookie选项包括：expires、domain、path、secure、HttpOnly
-	expires其实是cookie失效日期，expires必须是 GMT 格式的时间（可以通过new Date().toGMTString()	如果没有设置该选项，则默认有效期为session，即会话cookie。这种cookie在浏览器关闭后就没有了
-	expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替
-	max-age 的值是一个以秒为单位时间段
-	max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age
-	domain是域名，path是路径，两者加起来就构成了 URL
-	所以domain和path2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。
-	“baidu.com”其子域如“api.baidu.com”、“dev.api.baidu.com”
-	“/ ”子路径“/home”、“/home/login”
-	发生跨域xhr请求时，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下cookie也不会自动被添加到请求头部中
-	secure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie才能被发送至服务器。
-	默认情况下，cookie不会带secure选项(即为空)。所以默认情况下，不管是HTTPS协议还是HTTP协议的请求，cookie 都会被发送至服务端。但要注意一点，secure选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 cookie。
-	httpOnly
这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。
-	一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。
-	XSS 攻击，有一段恶意的script脚本插到了网页中。这段script脚本做的事情是：通过document.cookie读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了
-	cookie既可以由服务端来设置，也可以由客户端来设置。
-	response header中有一项叫set-cookie，是服务端专门用来设置cookie的
-	一个set-Cookie字段只能设置一个cookie
-	cookie其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码		encodeURIComponent/decodeURIComponent
-	大多数XSS攻击都是针对会话cookie的盗窃。后端服务器可以通过在其创建的cookie上设置HttpOnly标志来帮助缓解此问题
-	cookie是服务器发送到用户浏览器并保存本地的一小块数据 他会在浏览器下一次向同一个服务器发送请求被携带发送到服务器	用于告知服务器两个请求是来自同一个浏览器的 如保持用户的登录状态 cookie 使基于无状态的http协议记录稳定状态的信息成为了可能
-	cookie的应用场景
	-	会话状态管理		用户登录状态 购物车
	-	个性化设置			用户自定义设置 主题
	-	浏览器行为跟踪		跟踪分析用户行为
-	会话cookie
-	持久cookie  cookie的过期时间设置只和客户端相关  而不是服务器
-	cookie的域和页面的域不一样		就是第三方cookie
-	cookie是不能跨域的
-	secure属性是规定了传输的协议只能是https		httponly指的是不可以用js来获取cookie
-	domain和path定义了cookie的作用域		就是cookie应该发送给哪些URL
-	set-cookie:key=value;SameSite=Strict
-	SameSite指的是允许服务器要求某个cookie在跨站请求的时候不会被发送	从而阻止了跨站请求伪造
-	SameSite的属性值
	-	None 		浏览器会在同站 跨站请求的时候继续发送cookie
	-	Strict		浏览器只发送相同站点请求的cookie	如果请求来自与当前location的URL不同的URL
					则不包括标记为Strict属性的cookie
	-	Lax			cookies将会为一些跨站子请求保留	  例如图片加载或者frames的调用
					但只有用户从外部站点导航到URL才会发送
-	session同步问题


##	rmfxss
-	防止 cookie信息泄露		服务端设置set-cookie		httponly		限制用js来获取用户cookie并用获取的cookie来操作非用户本意的操作
-	手机验证码来设置登录
##	分类
-	会话cookie	关闭浏览器	会话cookie会自动消失	存在内存里
-	持久化cookie	有有效期	到期自动销毁	存储在用户的硬盘上
##	工作原理
-	cookie是服务器给浏览器的	服务器拿到cookie	分析里面的内容	校验cookie的合法性	根据cookie内容	进行具体的业务逻辑
##	应用
-	解析http无状态问题	7天免登录
-	cookie不一定只由服务器生成	前端同样可以生成cookie但是毫无意义 
##	cookie   当前讲的是基于node 下的express
-	给客户端种cookie不需要任何的库
	res.cookie('mignzi',JSON.stringify(obj))//会话cookie
	res.cookie('ming','hello',{maxAge:1000*30})//持久化30秒的cookie	到点会自动销毁
-	let cookieParser = require('cookie-parser')//是一个中间件
	app.use(cookieParser)
	req.cookies
	res.clearCookie('cookieName')//清除cookie
-	浏览器模板引擎
##	cookie和session配合
-	session会话存储是存储在服务器内存里面的	避免服务器断电影响	那么就要做session持久化
#	session
-	session就是会话
	-	前端通过浏览器去查看cookie时候	会看到cookie的过期时间是session	
	-	后端人那员通常把session会话存储		简称为session存储
-	特点
	-	存储在服务端
	-	存储的是浏览器和服务器之间沟通产生的一些信息
-	工作流程
	-	第一次浏览器请求服务器	服务器开辟内存空间	供session会话存储
	-	返回响应的时候	自动返回一个cookie	
	-	以后请求的时候	会自动携带这个cookie	给服务器
	-	服务器从cookie中拿到对应的session的id	去服务器中匹配
	-	服务器匹配信息	决定下一步逻辑
##	令牌盗取	就是	cookie被他人盗取
#	AJAX就是JS和XML
-	无刷新获取数据	纯数据
-	是一种使用现有标准的新方法
##	XML可扩展标记语言
-	被设计用来传输和存储数据
-	AJAX工作原理是相当于用户和服务器之间加了一个中间层(AJAX引擎)使得用户操作和服务器响应异步化
##	AJAX的缺点
-	没有浏览历史	不可以回退
-	存在跨域问题	用代理解决跨域问题
-	SEO不友好	搜索引擎优化
###	post请求注意加上有一句
-	xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')//设置特殊的请求头
-	用于解析post请求请求体参数	参数的编码类型是
-	Content-Type 标头告诉客户端实际返回的内容的内容类型。
-	app.use(express.urlencoded({extend:true}))
-	ie发送get请求问题就是会总是走缓存	那么就要用欺骗Date.now()		来每次都是不同的字符串
-	res.send(123)不可以只返回数字	要数字.toString()
##	跨域	ajax请求可以发送	但是不可以获取数据	
-	跨域对服务器没有影响	对浏览器有影响
-	浏览器为了安全	而采用同源策略
##	同源策略是一个安全策略		netspace网景公司提出
-	web是构建在同源策略之上的
-	所谓同源	也称为同域	是指协议	域名	端口都要相同
###	非同源受到哪些限制
-	cookie不可以读取
-	dom无法获得
-	ajax请求不可获取数据
###	form表单跨域不会被拦截
-	ajax发的请求------ajax引擎-------听从同源策略
-	form发请求--------浏览器其他模块------不听从同源策略
#	rmfpromise
-	promise抽象表达:
-	promise是一门新的技术	ES6规范
-	promise是js中进行异步编程的新解决方案
-	Promise 将嵌套格式的代码变成了顺序格式的代码。
-	promise具体表达:
-	promise是一个构造函数
-	promise对象用来封装一个异步操作并且可以获取成功和失败的结果值
###	promise初始状态是pending 表示是初始的	未确认的
-	var promise1 = new Promise(function(resolve,reject){
	//excutor执行器函数	同步回调函数
	console.log('excutor()')
	setTimeout(function(){
		resolve('foo')
	},1000)
})//promise封装了一个定时器的异步操作
promise1.then(function(value){//异步执行成功的回调函数
	console.log(value)
})
###	使用promise封装异步ajax请求
-	function myAsyncFunction(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest()
		xhr.open('GET',url)
		xhr.onload = () => resolve(JSON.parse(xhr.responseText))//成功回调
		xhr.onerror = () => reject(xhr.statusText)//出错的回调
		xhr.send()
	})
}
**自己写promise封装**
	function promiseAjax(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest()
		xhr.open('GET',url)
		xhr.send()
		xhr.onreadystatechange = () => {
			if(xhr.readyState!==4)return
			if(xhr.status >= 200 && xhr.status < 300){
				resolve(JSON.parse(xhr.response))//resolve交出正确数据
			}else{
				reject(new Error('request error status:'+xhr.status))//交出错误数据
			}
		}
	})
}
	promiseAjax('url')
	.then(
		data => {
			console.log('yes',data)//正确数据的输出
		},
		error => {
			alert(error.message)//错误数据的输出
		}
	)
**async/await	解决回调地狱的终极解决方案	更加精简**
-	async function request(){
	try{
		const result = await doSimething()
		const newResult = await doSomethingElse(result)
		const finalResult = await doThirdThing(newResult)
		console.log('Got the final result:' + finaResult)
	}catch(error){
		failureCallback(error)
	}
}
###	改变promise状态(resolve reject)和指定回调函数(.then .catch)谁先谁后	常规是先指定回调函数	指定不是执行	后来改变状态
-   状态改变一次之后不会再改变了    状态只改变一次  分先后顺序
-   没有定时器的时候	就是先改变状态	后指定回调函数
-   先是回调    还是状态    看定时器的时间设定  短的优先
-   fn (){}//在类里面放在原型对象上面
-	fn = () => {}//放在实例对象上面
##	async和await作用
-	简化promise对象的使用	不要通过then指定回调函数去结果数据
-	是回调地狱的终极解决方案
##  宏队列和微队列
-	宏队列
	-	dom事件回调
	-	ajax回调
	-	定时器回调
-	微队列
	-	promise回调
	-	mutation()回调
##  await在console.log()之前执行
async function async1(){
	console.log('async start')
	await async2()//相当于.then 函数来执行  
	console.log('async end')//放进微队列
}
###	AJAX请求和http请求的关系	AJAX请求是特殊的http请求
-	AJAX请求获取数据	不需要整个页面的刷新
-	只有XHR或者fetch发出的才是ajax请求	其他所有的都是非ajax请求
###	浏览器端收到响应
-	一般请求	浏览器会直接显示响应体数据	也就是刷新/跳转页面
-	ajax请求	浏览器不会对界面进行任何更新操作	只是调用监视的回调函数并传入响应相关数据
###	axios处理链流程
-	添加请求拦截器	在发请求之前执行
-	作用
	-	对请求的配置做一些处理	data header 
	-	对请求进行检查	不满足就不发请求
-	axios.interceptors.request.use(function (config) {
	console.log('req interceptor onResolved()')
	return config//必须返回config
})
-	**后面的请求拦截器会先console.log**
-	添加响应拦截器	得到响应后执行的回调函数
-	作用
	-	对请求成功的数据
	-	对请求失败的数据
-	axios.interceptors.response.use(
	function(response){
		console.log('res interceptor1 onResolved()')
		return response;
	},
)
#	webpack	模块打包器(构建工具)	遵循CommonJS规范的文件
-	webpack看来	前端所有资源文件作为**模块处理**
-	webpack不支持三点运算符的解析
##	五个核心概念
-	Entry	入口起点	指示webpack应该使用哪个模块	作为构建内部依赖图开始
-	Output	告诉webpack再哪里输出它所创建的bundles	以及如何命名这些文件	默认值是./dist
-	Loader	本身是运行在node.js里的js模块 让webpack能够去处理那些非js文件		webpack自身只能解析js json
-	Pulgins	插件可以用于执行范围更广的任务	打包优化和压缩	定义环境中的变量等
-	Mode	生产模式production和开发模式development
-	优点:
-	webpack可以编译打包js和json文件
-	可以将es6的模块化语法转换为浏览器可识别的语法
-	可以压缩代码
-	缺点:
-	不可编译打包css img等文件
-	不可将js的es6基本语法转化为es5以下的语法
##	打包样式文件中的图片资源
-	npm i file-loader url-loader -D
-	import img from './image.png'
-	图片编码格式base64
-	图片<8kb	转为base64		图片>8kb	不转为base64
-	file-loader和url-loader是一对兄弟
-	用的时候url-loader是对file-loader的上层封装
-	那么使用的时候都要安装
-	静态模块指的是在开发阶段 可以被 webpack 直接引用的资源文件
-	webpack 运行流程是串行的	将各个插件串联起来
	-	初始化阶段	初始化插件和配置插件执行环境所需要的参数
	-	编译构建阶段	针对每个 module 串行调用对应的 loader 去翻译文件内容	再找到 module 
		依赖的 module 递归进行编译处理
	-	对编译后的 module 组合成 chunk 			chunk 转换成文件 输出到文件系统
-	webpack 碰到不可识别的模块的时候	会在配置中寻找该文件类型的解析规则		loader
	-	loader 的配置	在 module.rules 里面书写文件解析规则	rules 是数组对象形式
	-	对象属性的 test 为匹配的规则	一般情况是正则表达式
	-	use 也是数组对象类型		针对匹配的文件类型	调用对应的 loader 进行处理
	-	module.exports = {
		module: {
		rules: [
			{
				test: '/\.css$/',
				use: [
					{loader: 'style-loader'},
					{
						loader: 'css-loader',
						options: {
							modules: true
						}
					},
					{loader: 'sass-loader'}
				]
			}
		]
		}
	}
	-	loader 支持链式调用 链中每个 loader 会处理之前已经处理的资源	最终变为 js 代码	顺序是相反的
		顺序	上述代码的执行顺序是 sass-loader css-loader style-loader
	-	css-loader 只负责对 .css 文件进行一个解析	而不会将解析后的 css 文件插入到页面中
		若是希望完成插入到 style 的操作 需要使用 style-loader
		
#	自动编译打包运行	webpack-dev-server
-	安装loader
-	npm i webpack-dev-server -D
-	自带了自动刷新效果	但是是整个页面刷新
-	那么避免页面复杂的时候	耗资源	
-	**那么用到了局部刷新	叫做热模替换HMR	是webpack提供的最有用功能**
-	不会在本地生成打包文件		只会在内存里面生成
	那么在devServer里面加上hot:true就实现了局部刷新
-	**html不支持热模替换	css支持**
-	npx webpack --watch	//内部启动服务器来监视文件的变化 但是	不会自动刷新浏览器	热模替换	代理	
##	消息订阅和发布机制	
	-	适用于任意组件之间通信
	-	缺点是乱像菜市场	没有集中式管理
##	VM是ViewModel	模板视图	
	-	完成了Data Bingdings	数据绑定
	-	DOM Listeners			DOM监听
##  -	(function(){})()//这是立即执行函数表达式
##	for in 可以遍历到myObject的原型方法method
##	person.constructor === Person
-	Object.getPrototypeOf(person) === Person.prototype
##	分页存储管理
-	页面和页表
-	例如32位的	操作系统	页的大小是2**12		则0---》2**20页逻辑地址
-	物理块的大小和页的大小一致
-	页表是记录逻辑空间（虚拟内存）中**每一页在内存中对应的物理块号**。
-	页号 P=逻辑地址/页大小
	页内地址 F=逻辑地址%页大小
	根据页表查得 2 号页对应着 25 号物理块
	物理地址 A=物理块号*页大小 + 页内地址
##	for循环头部的let不仅将i绑定到for循环快中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值。
##	数据的存储结构就是		数据的逻辑结构在计算机里面的表示
-	逻辑运算符两侧的运算对象可以是任何数据类型
-	在C程序中，函数调用能出现在表达式语句中
-	c程序中,外部类型的变量只能定义一次，但可在不同地方声明多次
-	磁盘上物理结构为**链接结构**的文件只能**顺序存取**；
##	ul li+li 表示ul下的第一个li的所有兄弟li节点
-	**内联**是将style写在<head></head>标签里面的，可以写很多标签的样式，**行内是将style写在目标标签里面**(比如说<p>标签)
##	箭头函数和非箭头函数的效率的比较
-	 handleClick = () => {
    console.log('this is:', this)
	}
-	构造函数来绑定函数	返回函数
-	 constructor () {
        super(props)
        this.handleClick = this.handleClick.bind(this)
    }
    handleClick () {
        console.log('this is:', this)
    }
-	结果是非箭头函数的效率更加高效
##	箭头函数没有自己的this		this的指向只有一个
-	function fun () {
	return () => {
	return () => {
	return () => {
	console.log(this.name)
	}
	}
	}
	}
-	**所有的内层函数都是箭头函数**，都没有自己的this，它们的this其实都是最外层函数的this。
##	某进程创建的若干个线程，这些线程不能共享的是
-	程序计数器
-	某线程的栈指针
##	标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。
-	但是，如果**模板字符里面有变量**，就不是简单的调用了，而是会将**模板字符串先处理成多个参数**，再调用函数
-	function getPersonInfo (one, two, three) {
	console.log(one)
	console.log(two)
	console.log(three)
	}
	const person = 'Lydia'
	const age = 21
	getPersonInfo `${person} is ${age} years old`
-	[“”, “ is ”, “ years old”] “Lydia” 21
-	.push(...)返回新数组的长度
##	Promise.all(iterable) 允许在 iterable 中使用 **non-promise 的“常规”值**
	通常，Promise.all(...) 接受含有 promise 项的可迭代对象（大多数情况下是数组）作为参数。但是，如果这些对象中的任何一个不是 promise，那么它将被“按原样”传递给结果数组。
-	但是race()不可以
-	typeof *  返回的是字符串形式  --》string
-	利用 sourcemap 可以定位到具体的出错代码文件的行、列信息
-	目标站点由wordpress搭建-->做渗透测试-->使用wpscan对网站进行扫描
##	紧邻兄弟组合器+和一般兄弟组合器~的区别：+会选取符合条件的**一个元素**进行获取（即3）		不可选择前面	
-	~会选取符合条条件的**所有元素**（即3和4）
-	h2+p {}	--> 选择所有 h2 后面紧跟的 p 元素	
-	h2~p {} --> 选择 h2 元素后面的所有 p 元素
##	max-height会覆盖掉 height, min-height又会覆盖掉max-height		
-	顺序是max-height-->height-->min-height
-	 while (cnt<N)
    {
        i = i + 2;
        cnt = cnt + i;
    }
-	cnt以2为基础来不断接近值		时间复杂度是O(N**(1/2))
-	var a  =10;
	(function(){console.log(a);let a = 20})()		//let换为var的时候结果是不一样 的
-	let a是cannot access a 		var a是undefined
##	let var 在for循环里面的作用域是不同 的
-	const fn = function(){}
	const res = JSON.stringify(fn)--》undefined		
-	document.body.style = 'background-color':'#fff'
-	document.body.style.setProperty('background-color','#fff')
##	slice() 方法可从已有的数组中返回选定的元素。
-	但是返回的数据类型是 **array** 不是 string 这点要注意一下！
##	数组里面最后一个元素
-	slice(-1)		pop()		arr[arr.length-1]
-	slice不会改变原来数组		是浅层复制
-	slice是左闭右开的		返回的数据类型是array数据类型的
##	http1 rmfhttp2
-	http1
-	高延迟 — 队头阻塞(Head-Of-Line Blocking)
-	队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。
-	解决方案就是
1.	将同一页面的资源分散到不同域名下，提升连接上限。虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。
2.	减少请求数量
3.	内联一些资源：css、base64 图片等
4.	合并小文件减少资源数
-	无状态特性 — 阻碍交互
-	无状态是指协议对于连接状态没有记忆能力。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。上一次请求验证了用户名密码，而下一次请求服务器并不知道它与上一条请求有何关联，换句话说就是掉登录态。
-	明文传输 — 不安全性
-	不支持服务端推送
-	http2
-	二进制分帧 - HTTP2 性能增强的核心
	多路复用 - 解决串行的文件传输和连接数过多
-	二进制分帧
	首先，HTTP2 没有改变 HTTP1 的语义，只是在应用层使用二进制分帧方式传输。因此，也引入了新的通信单位：帧、消息、流。
	分帧有什么好处？服务器单位时间接收到的请求数变多，可以提高并发数。最重要的是，为多路复用提供了底层支持。
-	多路复用
	一个域名对应一个连接，一个流代表了一个完整的请求-响应过程。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。
-	HTTP2 的缺陷
-	TCP 的队头阻塞并没有彻底解决
-	TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。
-	多路复用导致服务器压力上升
-	多路复用容易 Timeout
-	大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。
##	Object.defineProperty()
-	Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
-	直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用
-	const object1 = {};
	Object.defineProperty(object1, 'property1', {
	value: 42,
	writable: false
	});

	object1.property1 = 77;
	// throws an error in strict mode

	console.log(object1.property1);
	// expected output: 42
-	configurable
	当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
	默认为 false。
-	enumerable
	当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。
	默认为 false。
##	rmfVue
-	computed 和 watch 有什么区别及运用场景
-	computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计
	算 computed 的值。
-	watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。
-	当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。
-	当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们
	执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。
-	为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？
-	Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来
	实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。
-	Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。
-	Vue 中的 key 到底有什么用？
-	key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快
-	diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点
-	因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导
	致之前节点的状态被保留下来,会产生一系列的 bug。
-	key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1)
-	谈一谈 nextTick 的原理
-	JS 执行是单线程的，它是基于事件循环的。
-	所有同步任务都在主线程上执行，形成一个执行栈
-	主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
	一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
-	消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结
	束后，都要清空所有的 micro task。
-	Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
-	如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。
-	事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
-	为了协调异步任务，Node 提供了四个定时器，让任务可以在指定的时间运行		后两个是 Node 独有的
-	setTimeout()
	setInterval()
	setImmediate()
	process.nextTick()
-	node.js 核心特性
-	单线程
-	非阻塞I/O
-	事件驱动
	浏览器端把鼠标点击、键盘按键等定义为事件，而node把网络请求、I／O操作等也看作事件，严格来说，一切动作都是事件，这就是事件驱动的思想
	在程序启动时，便进入事件循环，不断遍历执行事件队列中产生的事件，而在执行过程中，又会产生新的事件，因此称为事件循环
-	宏任务队列包含任务: A1, A2 , A3
	微任务队列包含任务: B1, B2 , B3
-	首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行B1, B2 , B3，执行完后清空
	微任务队中的任务，接着执行宏任务中的第二个任务A2，依次循环。
-	 宏任务 Macrotask队列真实包含任务：
	script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering
-	Vue 组件 data 为什么必须是函数 ?
-	因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。
-	所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在
	以上问题。
-	base64图片的使用是src='base64图片的数据'
##	v-model
-	一方面modal层通过defineProperty来劫持每个属性，数据劫持,一旦监听到变化通过相关的页面元素更新。另一方面通过编译模板文件，为控件的v-model绑定input事件，从而页面输入能实时更新相关data属性值。
-	首先在页面初始化时候，vue的编译器会编译该html模板文件，将页面上的dom元素遍历生成一个虚拟的dom树。再递归遍历虚拟的dom的每一个节点。当匹配到其是一个元素而非纯文本，则继续遍历每一个属性。
??如果遍历到v-model这个属性，则会为这个节点添加一个input事件，当监听从页面输入值的时候，来更新vue实例中的data想对应的属性值。
-	同样初始化vue实例时候，会递归遍历data的每一个属性，并且通过defineProperty来监听每一个属性的get，set方法，从而一旦某个属性重新赋值，则能监听到变化来操作相应的页面控制。
-	v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
	text 和 textarea 元素使用 value 属性和 input 事件；
	checkbox 和 radio 使用 checked 属性和 change 事件；
	select 字段将 value 作为 prop 并将 change 作为事件。

-	Object.defineProperty(data,"name",{
	get(){
		return data["name"];
	},
	set(newVal){
		let val=data["name"];
		if (val===newVal){
			return;
		}
		data["name"]=newVal;
		// 监听到了属性值的变化,假如node是其对应的input节点
		node.value=newVal;
	}    
})
-	vue数据绑定是通过 数据劫持和观察者模式 的方式来实现的
##	rmf虚拟DOM和diff算法
-	什么是虚拟DOM（virtual DOM）：
	所谓的虚拟 dom，也就是我们常说的虚拟节点，它是通过JS的Object对象模拟DOM中的节点，然后再通过特定的render（渲染）方法将其渲染成真实的DOM的节点。
-	真实DOM和虚拟DOM的区别：
	虚拟DOM不会进行排版与重绘操作
	真实DOM频繁排版与重绘的效率是相当低
	虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分，最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗
	虚拟DOM有效降低的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部
diff算法
-	diff算法的原理：
	逐步解析newVdom的节点，找到它在oldVdom中的位置，如果找到了就移动对应的DOM元素，如果没找到说明是新增节点，则新建一个节点插入。遍历完成之后如果oldVdom中还有没处理过的节点，则说明这些节点在newVdom中被删除了，删除它们即可。
-	delete add move
-	1、产生两个虚拟DOM树：newVDom，oldVDom。
2、oldVDom和真实DOM保持一致
3、操作的newVDom
4、操作完毕后，通过diff算法对比newVDom和oldVDom的差异，并在oldVDom标注哪些节点要删除，哪些节点要增加，修改
5、根据oldVDom操作真实的DOM，让真实Dom和oldVDom保持一致
-	解决浏览器性能
-	使用原生js  jQuery操作DOM	不用VDOM导致代码耦合性高难以维护	频繁重绘重排	消耗性能
-	那么VDOM来操作	减少了重绘重排	提高渲染效率
-	虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI	
-	虚拟 DOM 到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。
-	{
	tag: 'div',
	props: {
		id: 'app'
	},
	chidren: [
		{
		tag: 'p',
		props: {
			className: 'text'
		},
		chidren: [
			'hello world!!!'
		]
		}
	]
	}
-	观察主流的虚拟 DOM 库（snabbdom、virtual-dom），通常都有一个 h 函数，也就是 React 中的 React.createElement，以及 Vue 中的 render 方法中的 createElement
##	组件编写方式与 Vue 实例的区别：
1 	data是个函数（面试题）
	一个组件的 data 选项必须是一个函数,且要有返回object，只有这样，每个实例（vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据相互影响,也就是说，组件的作用域是独立的。
2	组件模板（html代码）只能有一个根标签
3	组件名不可和html官方的标签名同名
4	组件没有el选项，只有根实例存在el
5	书写：组件名如果小驼峰，那么使用时，用短横线（羊肉串的写法），或者组件名直接都用大驼峰。
##	动态创建dom
-	vue更新dom是异步队列的方式。vue的数据更新后，不会理解更新dom。如果想在dom更新后，做些事情，就用nextTick。
-	this.$nextTick(回调函数);这个函数里是知道什么时候处理dom的，当你传入回调函数时，nextTick内部会在处理完dom后，调用该回调函数
-	this.$nextTick(()=>{
	new myObject('ObjectName',{config})	
	})
##	
-	Fetch：
	fetch是ES6新增的，Fetch是基于promise设计的。fetch不是ajax的进一步封装，而是原生js。Fetch函数就是原生js，没有使用XMLHttpRequest对象。
##	数据依赖
-	我们使用Vue这个构造函数去实例化了一个vue实例app。传入了props, data, watch, methods等属性。在实例化的
	过程中，Vue提供的构造函数就使用我们传入的options去完成数据的依赖管理，初始化的过程只有一次，
-	function Vue (options) {
	if (process.env.NODE_ENV !== 'production' &amp;&amp;
		!(this instanceof Vue)) {
		warn('Vue is a constructor and should be called with the `new` keyword')
	}
	this._init(options)
	}
-	
##	rmfString
-	查找字符串中的字符串	indexOf() 方法返回字符串中指定文本首次出现的索引（位置）
-	lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引
-	search() 方法搜索特定值的字符串，并返回匹配的位置
-	search() 方法无法设置第二个开始位置参数。
-	indexOf() 方法无法设置更强大的搜索值（正则表达式）。
-	slice(start, end) 提取字符串的某个部分并在新字符串中返回被提取的部分。slice(-1)是倒数第一个数据	start end
-	substring() 类似于 slice()。	不同之处在于 substring() 无法接受负的索引。	start end
-	substr() 类似于 slice()。	不同之处在于第二个参数规定被提取部分的长度。	start length
-	replace() 方法用另一个值替换在字符串中指定的值	不会改变调用它的字符串。它返回的是新字符串。
-	默认地，replace() 只替换首个匹配	replace() 对大小写敏感。
-	toUpperCase() 把字符串转换为大写
-	通过 toLowerCase() 把字符串转换为小写
-	所有字符串方法都会返回新字符串。它们不会修改原始字符串。
-	trim() 方法删除字符串两端的空白符
-	charAt(index) 方法返回字符串中指定下标（位置）的字符串		str.charAt(0)
-	charCodeAt(index) 方法返回字符串中指定索引的字符 unicode 编码	
-	如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串。
-	它是只读的。str[0] = "A" 不会产生错误（但也不会工作！）
-	当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
	当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
-	两个typeof返回的是不一样的	一个返回的是Object		一个是string
-	toLocaleLowerCase()		toLocaleUpperCase()
-	sup() 方法用于把字符串显示为上标		str.sup()		sub()下标
-	strike()用删除线来显示字符串
-	link()将字符串显示为链接
-	small()小字号来显示字符串		big()大字号来显示字符串
-	match()		str.match(pattern)	返回匹配的符合的正则的数据数组
-	str.fontsize(3)使用指定的尺寸来显示字符串
-	bold()粗体来显示字符串
-	str.fontcolor('green')
-	去除字符串的最后一个字符		str.substr(0,str.length-1)		str.substring(0,str.length-1)
-	var str2 = new String("http://www.xyz.com");
	两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型
	console.log( str2.valueOf() === str2 );   // false
-	valueOf() 方法返回指定对象的原始值。
-	!==	 不绝对等于（值和类型有一个不相等，或两个都不相等）		
##	rmfvuex
-	组件之间的共享数据的方式
-	父向子传值		v-bind属性绑定
-	子向父传值		v-on事件绑定
-	兄弟组件之间共享数据		EventBus
-	$on		接收数据的组件
-	$emit	发送数据的组件
-	Vuex
-	vuex的核心概念		state   mutations    action  	getter
-	组件全局状态(数据)管理的机制		实现组件之间数据的共享
-	vuex管理共享的数据	易于开发和后期维护
-	高效实现组件之间的数据共享	提高开发效率
-	存在vuex里面的数据都是响应式的	可实时保持数据与页面同步
-	组件之间的共享数据是适合存在vuex中		但是对组件的私有数据存在自身的data里面
-	npm i vuex
-	弄个store.js文件
-	import Vuex from 'vuex'
-	Vue.use(Vuex)
-	const store = new Vuex.Store({
	state:{}
	})
-	export default new Vuex.Store({
	state:{count:0}
	})
-	store挂载到vue实例中
-	所有的组件可以从store中获取全局的数据
-	state
-	state提供唯一的公共数据源	所有的共享数据都统一放到store里面的state存储
-	组件访问state中数据的方式
-	this.$store.state.全局数据名称
-	也可以用另外一种方式访问state里面的数据
-	import {mapState} from 'vuex'
-	computed:{...mapState(['count'])}-->拿到了state里面的count数据
-	vuex不允许组件直接修改全局的state里面的数据		this.$store.state.count++-->错误，直接改变全局数据
-	mutations用于变更store里面的数据		可以集中监控数据的变化	不用去很多组件里面寻找变化 的位置
-	mutations:{add(state){state.count++}}
-	methods:{handlel(){this.$store.commit('add')}}-->组件里面methods来使用store里面的数据mutation方法
-	记得使用commit('xxx')
-	触发mutation里面的函数的时候不止可以使用state里面的数据还可以传入参数this.$store.commit('add',args1)
-	commit是触发mutaion里面的函数的一种方式		
-	还有一种方式是mapMutations
-	import {mapMutations} from 'vuex'
-	组件里面使用methods:{...mapMutations(['add','addN']),handler1(){this.add()}}-->调用mutations里面
	的方法
-	使用了add  addN函数
-	mutations里面不可以写异步的代码setTimeout()
-	Action用于异步操作 不可用mutations			但是在Action中还是要通过触发mutation来间接改变数据
-	actions:{addAsync(context){setTimeout(()=>{context.commit('add')},1000)}}	context可以理解为
	new出来的store		就是this
-	组件里面使用actions里面的异步操作		this.$store.dispatch('addAsync')
-	触发actions的方式
-	import {mapActions} from 'vuex'		省略了
-	组件里面使用methods:{...mapActions(['addAsync']),methodhandler(){this.addAsync()}}
-	mapActions   mapState  mapMutations是把全局的方法和属性映射为组件自己的方法和属性
-	getter	来对store里面的state数据进行加工处理形成新的数据		类似于vue的计算属性
-	getter  不改变store里面的数据   只是加工包装state里面的数据来展示
-	getters:{showNum(){return "当前最新的数量['+state.count+']"}}
-	使用getter
-	this.$store.getters.showNum
-	import {mapGetters} from 'vuex'
-	computed:{...mapGetters(['showNum'])}
-	<Input @change='inputChange'>
-	methods:{inputChange(e){e.target.value}}		-->e.target.value是文本框的数据
-	
-	
-	
-	
-	
-	








-	js实现indexOf方法
-	idnexOf		字串在父串首次出现的位置		indexOf要求传入起始位置		否则从0开始匹配
-	function myIndexOf(str1,str2,n){//target是开始匹配的位置
    let i
    let len1 = str1.length
    let len2 = str2.length
    if(n === undefined || n === null || n <= -1){
    i = 0//i是输入 的起始位置       特殊情况分为undefined null   -1
    //起始位置也要和父串的长度进行比较  不可超过len2-1
        }else if(n > len2){
    return -1
    }else{
    i = n
    }
    //开始比较字串父串的长度   len1  len2
    if(len1>len2){
    return -1
    }else{
    for(var j = i;j < len2;j++){
    if(str1 === str2.substr(j,len1))
    return j
    }
    }
    return -1
    
}
       
let str1 = 'mf'
let str2 = 'rmf123'
let res  = myIndexOf(str1,str2,0)
console.log(res)
-	js实现rmf栈实现队列
-	//两个栈实现队列的操作
//先进后出实现先进先出
//设置一个入队栈stack1   一个出队栈stack2
//入队是push       出队是pop
//出队的 时候将入队的顺序倒序
let stack1 = []
let stack2 = []
function add(node){
    while(stack2.length){
    stack1.push(stack2.pop())
}
stack1.push(node)
}
function poll(){
    if(stack2.length === 0){
    while(stack1.length !== 0){
    stack2.push(stack1.pop())
}
}
return stack2.pop() 
}
-	var myQueue = function(){this.stack = []}
	myQueue.prototype.add = function(node){this.stack.push(node)}
	myQueue.prototype.poll = function(){
		var temp = []
		for(var i = 0;i < this.stack.length;i++)temp.push(this.stack.pop())
		let res = temp.pop()
		for(var i = 0;i < this.stack.length;i++)temp.push(this.stack.push(temp.pop()))
		return res
	}

-	队列实现栈
## rmfcall rmfapply rmfbind
-	数组取得最大的数据值		Math.max.apply(null,arr1)
-	如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。

-	实现bind函数
-	//实现bind函数	在Function的原型对象上面定义bind函数
	Function.prototype.myBind = function(obj){
	if(typeof this !== 'function'){
	throw new Error('Function.prototype.bind-what is trying to be bound is not callable')
	}
	var _this  = this
	let objArgs = Array.prototype.slice.call(arguments,1)
	var fn = function(){}
	var bound = function(){
	var params = Array.prototype.slice.call(arguments)
	return _this.apply(this.constructor === _this ? this:obj,objArgs.concat(params))
	}
	fn.prototype = this.prototype
	bound.prototype = new fn()
	return bound
	}
-	构造函数实例的constructor属性永远指向构造函数本身
-	bind函数的作用
-	如果某些函数，前几个参数已经 “内定” 了，我们便可以用 bind 返回一个新的函数。也就是说，bind() 能使一个函数拥有预设的初始参数。
-	ployfill填充物
-	什么时候容易丢失 this 指向？恩，setTimeout 是一个场景，很容易把 this 指向 window，当然，setInterval 也是一样。当使用对象的方法时，需要 this 引用对象，你可能需要显式地把 this 绑定到回调函数以便继续使用对象。
-	window.setInterval(canvas.render, 1000 / 60);
-	var canvas = {
	render: function() {
		this.update();
		this.draw();
	},}
-	this指向指向了window		丢失了this指向	那么解决问题
-	window.setInterval(canvas.render.bind(canvas),1000/60)
-	bind函数来绑定指向的问题		解决了this指向丢失的问题
-	伪数组转换为真数组
-	Array.prototype.slice.apply(arguments)
-	bind可以用来封装绑定一些函数
-	var mySlice = Array.prototype.slice;var slice = Function.prototype.call.bind(mySlice)
-	slice(arguments,1)		使用的时候直接使用函数名
-	var myForEach = Array.prototype.forEach;var forEach = Function.prototype.call.bind(myForEach)
-	使用自定义的bind函数的时候		let bound = fn.myBind(obj,1);bound是obj绑定函数fn的函数名;
-	var person = new bound();		person绑定了函数有着obj的指向
-	bind函数的使用有俩个步骤	首先是绑定函数的指向的问题		然后就是函数的new的操作	一个变量名去承接这一个绑定函数
-	let fn  = function(){console.log(this)}		fn()	-->window{}
-	let bound = fn.myBind(obj);bound()		-->obj的内容
##	rmfh5
-	var canvas = document.getElementById('myCanvas');
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(0, 0, 100, 100);
-	<input list="browsers">			定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。
	<datalist id="browsers">
	<option value="Internet Explorer">
	<option value="Firefox">
	<option value="Chrome">
	<option value="Opera">
	<option value="Safari">
	</datalist>
-	<article>	定义页面独立的内容区域。
	<article>
	<h1>Internet Explorer 9</h1>
	<p>rmf</p>
	</article>
-	<aside>	定义页面的侧边栏内容。
-	<details>		<details> 标签规定了用户可见的或者隐藏的需求的补充细节。
	<summary>Copyright 1999-2011.</summary>
	<p> - by Refsnes Data. All Rights Reserved.</p>
	<p>All content and graphics on this web site are the property of the company Refsnes Data.</p>
	</details>
-	<summary>标签包含了details标签的标题
-	<dialog> 标签定义一个对话框、确认框或窗口。
-	<dialog open>This is an open dialog window</dialog>
-	<figure> 标签规定独立的流内容（图像、图表、照片、代码等等）。
	<figure> 元素的内容应该与主内容相关，同时元素的位置相对于主内容是独立的。如果被删除，则不应对文档流产生影响。
-	<figcaption> 标签为 <figure> 元素定义标题。
	<figcaption> 元素应该被置于 <figure> 元素的第一个或最后一个子元素的位置。
-	<footer> 标签定义文档或者文档的一部分区域的页脚。
	<footer> 元素应该包含它所包含的元素的信息。
-	<header> 标签定义文档或者文档的一部分区域的页眉。
	<header> 元素应该作为介绍内容或者导航链接栏的容器。
-	<mark> 标签定义带有记号的文本。
-	<p>Do not forget to buy <mark>milk</mark> today.</p>
-	<meter> 标签定义度量衡。仅用于已知最大和最小值的度量。	比如：磁盘使用情况，查询结果的相关性等。	
-	<meter value="2" min="0" max="100">2 out of 10</meter><br>
	<meter value="0.6">60%</meter>
-	<nav> 标签定义导航链接的部分。
-	<nav>
	<a href="/html/">HTML</a> |
	<a href="/css/">CSS</a> |
	<a href="/js/">JavaScript</a> |
	<a href="/jquery/">jQuery</a>
	</nav>
-   <progress> 标签定义运行中的任务进度（进程）。
-	<ruby> 标签定义 ruby 注释（中文注音或字符）。
	在东亚使用，显示的是东亚字符的发音。
-	<rp>在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。
-	<section> 标签定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。
-	<time> 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。t该元素能够以机器可读的方式对日期和时间进行编码，这样，举
	例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果。标签不会在任何浏览器中呈现任何特殊效果。
-	<wbr> 标签可以用来定义HTML文档中需要进行换行的位置，与<br>标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 
	<wbr> 标签的位置进行换行
-	<bdi> 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。
-	h5中删除的元素
-	<big><center><strike><font><dir>标签表示一个目录
-	<hgroup>可以将h1到h6放入里面	例如主标题和副标题的组合使用可以用hgroup来装载h标签
	
##	rmfCss3
-	多列布局方式
-	**column-count**	column-width	column-gap		column-rule
-	将 div 元素中的文本分为三列	column-count:3		**指定元素被均分的列数**
	.divText{
		column-count:3//div元素被分为了三列
	}
-	**column-width**:20px		列的宽度
-	**column-gap**:20px		列之间的宽度		指定**多列之间的间距**
-	**column-rule**:3px outset #000		用来指定列之间的规则	*宽度	样式	颜色*
-	column-width及column-count属性可以合并起来使用，**columns来设置列宽和列数**
		columns:100px 2;
-	column-span	来指定**元素跨域的列数**	比如一个标题很长	在**上方一列的宽度是不够放置标题的**
	那么就column-span:all		来指定跨越所有列		这样就可以盛放标题了
	**默认值是跨越一列**		
-	**列之间样式的规则**		hidden(隐藏)	dotted(点状)	solid(实线)		double(双实线)	dashed(虚线)
	column-rule-style
-	宽度的规则		thin(细边框)	medium(中等边框)	thick(粗边框)	length(指定宽度)
-	CSS3提供rgba来支持为元素设置透明度
-	rgba(255, 0, 0, 0.75)
-	还有提供透明度的属性
-	display(none会从dom树中移除 动态改变此属性时会引起重排)	绑定元素的事件不存在
-	opacity(影响子元素 元素隐藏	依然占据空间 会被继承 但是绑定元素的事件依然会被触发)			
-	rgba(不影响子元素 依然可以触发绑定的事件)
-	visibility(hidden  元素会隐藏但是不会消失 依然占据空间 会被子元素继承	不会触发该元素已经绑定的事件 引起重绘)
-	z-index(元素要保证脱离文档流的前提下,才会生效z-index:-1 会被继承  无法响应已经绑定的事件)
-	opacity属性将某元素及其所有的子元素都应用透明样式，而rgba只在被设置的元素应用透明样式并不影响其子元素。
-	元素设置 height: 0px; width: 0px; 若是元素含有子元素	那么还需要设置 overflow: hidden;
-	绝对定位 top: -9999px; left: -9999px;
-	border-radius是四个属性的缩写
-	border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius
-	线性渐变和径向渐变
-	linear-gradient	linear-gradient(135deg, black, white);
-	渐变轴是相对笛卡尔坐标系的y轴来设置deg的
-	radial-gradient	 radial-gradient(#000, #fff);
-	多背景图片支持
-	box-sizing设置盒模型	content-box		border-box
-	**content-box  是默认值**。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都**会被增加到最后绘制出来的元素宽度中。**
-	border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px
	会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。
-	text-shadow		box-shadow
-	text-shadow为文字添加阴影		每个阴影值由元素在X和Y方向的偏移量、模糊半径和颜色值组成。
-	text-shadow: 2px 2px 2px green;
-	box-shadow 属性用于在元素的框架上添加阴影效果。
-	box-shadow: 5px 5px 2px  green;
-	inset
	如果没有指定inset，默认阴影在边框外，即阴影向外扩散。
	使用 inset 关键字会使得阴影落在盒子内部，这样看起来就像是内容被压低了。 此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。
-	该属性可设置的值包括阴影的X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色。
-	CSS3提供@font-face特性为页面自定义字体的展示提供支持。
-	@font-face { 
    font-family: BorderWeb; 
    src:url(BORDERW0.eot); 
	}
-	使用的时候的样式	font-family: "BorderWeb";
-	媒体查询（media queries）可以让你为不同的设备基于它们的能力定义不同的样式。
-	@media all and (max-width:480px){#sidebar {   float: none;   clear: both;  }   }
-	@media是关键字（可以将其理解成css的一种语法糖，跟@import类似）
-	screen，这个关键字就是我们所说的媒体类型（这里screen其实就是电脑屏幕
-	all	screen print(打印模式)	是常用的媒体类型		handheld(手持设备)	projection	演示模式、幻灯片等	tv电视媒体
-	speech	 听觉设备，应用于屏幕阅读器等发声设备。
-	not或者only这两个关键字修饰媒体类型		不是这种媒体		只是这种媒体
-	可以自动识别屏幕宽度、并做出相应调整的网页设计。
-	@media only screen and (min-width: 768px) {
    .col-1 {width: 8.33%;}
    .col-2 {width: 16.66%;}
    .col-3 {width: 25%;}
	}
-	transition(过渡) transform(变化) animation(动画)
-	transition主要包含四个值，transition-property（执行变换的属性），transition-duration（执行变换的持续时间）,
-	transition-timing-function(变换的速率变化模式),transition-delay(变换延迟时间)。
-	ease（逐渐变慢）linear（匀速）ease-in（加速）ease-out（减速）ease-in-out（加速然后减速）
-	transform的所有变换都是**围绕着x轴,y轴，中心点来进行变换的**		**平移旋转拉伸**
-	transform属性允许你旋转，缩放，倾斜或平移给定元素
-	transform:rotate(30deg)旋转	
-	transform:translate(-50%,-50%)		translateX()	translateY()
-	transform:scale(0.5)x,y轴的缩放		scaleX()		scaleY()
-	transform:skew(20deg)		skewX()	**X轴方向来倾斜**	skewY()**y轴方向来倾斜**
	-	斜拉
-	matrix()	**将2D方法合并成一个**		包含六个参数旋转 缩放 平移
	-	transform： matrix（1,0,0,1,10,10）--其他数值都不动，e和f分别加10	这是**平移元素的格式**
	-	缩放		transform：matrix（2,0,0,2,0,0)			**缩放只和第一个第四个元素相关**
		-	可以在相关的属性上面写缩放的大小
	-	旋转
		-	transform：matrix（cosθ，-sinθ,sinθ,cosθ,0,0);
		-	元素的旋转涉及到了四个属性值的书写	**旋转多少度就计算出这个度数的cosθ，sinθ**就可以达到我们想要的效果啦	
-	backface-visibility该属性用于隐藏内容的背面。默认情况下，背面可见的，也就是当翻转后，背面内容仍然可见。但是当	
	backface-visibility设置为hidden的时候，旋转后内容将会被隐藏
-	animation		animation-name(动画名，也就是keyfram中定义的动画名)		animation-duration（动画持续时间）
-	animation-timing-function（动画变化的速率）			animation-delay（动画延迟播放的时间）
-	animation-iteration-count（动画循环的次数，infinite是无限次）  
-	animation-direction（动画的方向）(alternate(动画正向反向交替进行) reverse normal)
-	animation-play-state动画的播放状态	
-	animation: 3s ease-in 1s infinite reverse both running slidein;
-	选择器
-	p:first-child	选择属于父元素的第一个子元素的每个 <p> 元素
-	p::first-letter	选择每个 <p> 元素的首字母
-	:first-of-type	p:first-of-type	选择属于其父元素的首个 <p> 元素的每个 <p> 元素。元素不一定是第一个	只要类型是第一个
-	:in-range	input:in-range	选择其值在指定范围内的 input 元素。min=''  max=''
-	:invalid	input:invalid	选择具有无效值的所有 input 元素。
-	input:invalid {
	border: 2px solid red;
	}
-	:lang(language)	p:lang(it)	选择 lang 属性等于 "it"（意大利）的每个 <p> 元素。
-	p:lang(en)
	{ 
	background:yellow;
	}
-	:last-child	p:last-child	选择属于其父元素最后一个子元素每个 <p> 元素。		元素必须是最后一个
-	:last-of-type	p:last-of-type	选择属于其父元素的最后 <p> 元素的每个 <p> 元素。	元素类型是最后一个
-	:link	a:link	选择所有未访问过的链接。
-	a:link
	{
	background-color:yellow;
	}
-	:not(selector)	:not(p)	选择非 <p> 元素的每个元素。
-	:not(p)
	{
	color:#ff0000;
	}
-	input:not([type = radio]) {
	border: 1px solid #ccc;
	}
-	:nth-child(n)	p:nth-child(2)	选择属于其父元素的第二个子元素的每个 <p> 元素。
-	p:nth-child(2)
	{
	background:#ff0000;
	}
-	:nth-last-child(n)	p:nth-last-child(2)	同上，从最后一个子元素开始计数。
-	:only-child	p:only-child	选择属于其父元素的唯一子元素的每个 <p> 元素。	父元素有且只有一个p元素	不可容纳其他任何元素
-	:only-of-type	p:only-of-type	选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。父元素p元素的类型有且只有一个
-	:optional	input:optional	选择不带 "required" 属性的 input 元素。
-	input:optional {
	background-color: yellow;
	}
-	:out-of-range	input:out-of-range	选择值超出指定范围的 input 元素。
-	input:out-of-range {
	border: 2px solid red;
	}
-	::placeholder		input::placeholder	选择已规定 "placeholder" 属性的 input 元素。
-	:read-only	input:read-only	选择已规定 "readonly" 属性的 input 元素。
-	input:read-only {
	background-color: yellow;
	}
-	:required	input:required	选择已规定 "required" 属性的 input 元素。
-	input:required {
	background-color: yellow;
	}
-	:root	:root	选择文档的根元素。
-	:root
	{
	background:#ff0000;
	}
-	::selection	::selection	选择用户已选取的元素部分
-	::selection
	{
	color:#ff0000;
	}
-	:target	#news:target	选择当前活动的 #news 元素。			#news是一个元素的id		是a超链接的href		
-	id='news'		href='#news'
-	:target
	{
	border: 2px solid #D4D4D4;
	background-color: #e5eecc;
	}
-	:valid	input:valid	选择带有有效值的所有 input 元素。
-	input:valid {
	background-color: yellow;
	}
-	相邻兄弟选择器		+
-	选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器。
-	这个也会循环查找，即当两个兄弟元素相同时，会一次循环查找
-	li + li {
        color:red;
    }
-	<li>List item 1</li>
    <li>List item 2</li>
    <li>List item 3</li>
-	循环查找		那么2 3就会变色
-	~ 选择器
　　作用是查找某一个指定元素的后面的所有兄弟结点。
-	如果需要在内联的场景下使用flex布局，则需要设置display: inline-flex。
-	order的用法如下
	用整数值来定义排列顺序，数值小的排在前面。默认值为0，且可以设置为负值。
-	background-image属性添加背景图片。
	不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。url(img_flwr.gif), url(paper.gif); 
-	background-size指定背景图像的大小	 background-size:80px 60px;
-	background-origin 属性指定了背景图像的位置区域。  background-origin:content-box;	背景图片的相对位置
-	content-box, padding-box,和 border-box区域内可以放置背景图像。
-	background-clip背景剪裁属性是从指定位置开始绘制。
-	text-shadow并不是在CSS3中新增的的新属性，在CSS2.0时就已经有了这个属性了，之后在CSS2.1不知何故被移除了，最终在CSS3中又重新收纳
	了这个属性。
-	text-shadow还是box-shadow，都是支持多重阴影的
-	box-reflect	box-reflect：包括3个值
-	direction 定义方向，取值包括 above 、 below 、 left 、 right。
-	 offset定义反射偏移的距离，取值包括数值或百分比，其中百分比根据对象的尺寸进行确定。默认为0。
-	mask-box-image定义遮罩图像，该图像将覆盖投影区域。如果省略该参数值，则默认为无遮罩图像。
-	-webkit-box-reflect:below 10px -webkit-linear-gradient(transparent,transparent 50%,rgba(0,0,0,.8)); 
-	border-radius
-	设置1个值时，四个方向都使用同一个值
	设置2个值时，左上和右下使用第一个值，右上和左下使用第二个值
	设置3个值时，左上使用第一个值，右上和左下使用第二个值，右下使用第三个值
	设置4个值时，分别对应左上、右上、左下、右下的顺序进行赋值
-	border-top-left-radius，左上角
	border-top-right-radius，右上角
	border-bottom-right-radius，右下角
	border-bottom-left-radius，左下角
-	若设置一个值，则表示水平半径和垂直半径相同
	若设置两个值，则表示分别按顺序设置水平、垂直半径
-	css3为了区分伪类和伪元素，伪元素采用双冒号写法。
-	常见伪类——:hover,:link,:active,:target,:not(),:focus。	--> 利用元素的状态信息选择元素
-	常见伪元素——::first-letter,::first-line,::before,::after,::selection。	--> 无法用 HTML 语义表达的实体
-	::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。
	这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。
-	伪类元素的display是默认值inline
-	通过attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。
-	a::after{
    content: "(" attr(href) ")";
	}
-	url()/uri()	用于引用媒体文件
-	a::before{
    content: url("https://www.baidu.com/img/baidu_jgylogo3.gif");
	}
-	垂直居中
-	**单行 行内元素**line inline-block -->line-height设置为100%		-->多行的时候就不行了
	-	div	中的div设置display:inline-block		再来设置父元素line-height:	
		这样就可垂直居中		**line-height是设置在父元素上面的**
-	vertical-align:middle	指在元素内的所有元素垂直位置互相居中，并不是相对于外框的高度垂直居中
	**如果有一个方块变成了高度100%**，那么其他的方块就会真正的垂直居中。利用::before和::after添加div进到杠杠内，**before和after是添加到父元素上面**，让这个“伪”div的高度100%，就可以轻松地让其他的div都居中。不过不过不过！div记得要把display设为inline-block，毕竟vertical-align:middle；是针对行内元素，div本身是block，所以必须要做更改！**伪元素记得加上content:''**
-	用到CSS特有的calc动态计算的能力，我们只要让要居中的div的top属性，与上方的距离是“50%的外框高度+ 50%的div
	高度”		 top:calc(50% - 15px);		calc 内部的表达式，在使用运算符号时，两遍必须加上空格
-	子元素必须要加上position:relative	transform是CSS3的新属性	top:50%;transform:translateY(-50%);
-	绝对定位就是CSS里头的position:absolute，利用绝对位置来指定，但垂直居中的做法又和我们正统的绝对位置不太
    相同，是要将上下左右的数值都设为0，再搭配一个margin:auto，就可以办到垂直居中，不过要特别注意的是，设定绝对定位的子元素，其父元素的position必须要指定为relative喔！
-	flex布局align-itmes来实现
-	布局
-	table 的特性决定了它非常适合用来做布局，并且表格中的内容可以自动居中，这是之前用的特别多的一种布局方式
	display：table;dispaly:table-cell 来支持 teble 布局
	table 比其它 html 标记占更多的字节（造成下载时间延迟,占用服务器更多流量资源）
	table 会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度,让用户等待更久的时间)
-	flex布局
-	float布局
	-	float 元素可以形成块，如 span 元素。可以让行内元素也拥有宽和高，因为块级元素具有宽高
	-	高度塌陷	子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。
		-	父元素设置 overflow: auto 或者 overflow: hidden
		-	**给父元素加一个 after 伪元素**	content:'';visibility:hidden;display:block;clear:both
		-	浮动元素会把块级元素的位置空出来
			<div class='left'></div>
			<div class='right'></div>
			<div class='middle'></div>
	-	float的元素的**只会影响当前或者后面的标准盒子，不会影响前面的标准流**
-	响应式布局
	-	最简单的处理方式是加上一个 meta 标签
	-	<meta name='viewport' content='width=device-width,initial-scale=1'>		
	-	rem 指的是 html 元素的 font-size，html 元素的 font-size 默认是 16px，所以 1 rem = 16px；然后根
		据 rem 来计算各个元素的宽高
	-	media query		媒体查询
	-	screen and (max-width:360px){html{font-size:16px}}
-	**用户界面**
	-	resize属性		resize属性指定一个**元素是否应该由用户去调整大小**。
		-	resize:both		
	-	outline-offset属性
		-	outline-offset 属性**对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓**
		-	轮廓**不占用空间**
		-	**轮廓可能是非矩形**
		-	outline:1px solid red
	-	轮廓线 outline-width 是不会占据空间的
-	要为 HTML 元素**使用字体**
	-	@font-face
		{
		font-family: myFirstFont;
		src: url(sansation_light.woff);
		}
	-	@font-face来自定义设置字体样式
-	word-break 指定了单词断行
	-	word-break: normal	// 默认的断行规则
	-	word-break: break-all // 任意字符间断行
	-	word-break: keep-all	// CJK(中国/日本/韩国) 文本不断行
##	rmf浏览器内存泄露
-	setInterval用多了，会占用大量的内存，要我们必须及时清理		否则，运行时间一长，极有可能导致浏览器崩溃！
-	几种常见的js内存泄露
-	**意外的全局变量**
-	haorooms ="这是一个全局的haorooms"
-	生成了一个全局的haorooms		我们在编程中尽量少的避免全局变量！
-	全局变量可能由this创建
-	function foo() {
	console.log(this)
	}
	foo()
	// Foo 调用自己，this 指向了全局对象（window）
-	**没有及时清理的计时器或回调函数**		setInterval定时器的清除直接在定时器里面循环进行即可
-	function b() {
    var a = setInterval(function() {
        console.log("Hello");
        clearInterval(a);
        b();                
    }, 50);
	}
	b();
-	不断创建定时器		和		清除定时器		setTimeout()函数是在返回的函数里面直接调用返回的函数
-	返回的函数里面第一步就是清除定时器		clearTimeout()
-	function time(f, time) {
    return function walk() {
     clearTimeout(aeta);
        var aeta =setTimeout(function () {
            f();
            walk(); 
        }, time);
    };
	}
	time(updateFormat, 1000)();
-	**脱离 DOM 的引用**
-	保存 DOM 节点内部数据结构很有用。
-	var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
	};
-	 DOM 元素存在两个引用：一个在 DOM 树中，另一个在elements字典中。
-	决定删除这些行时，需要把两个引用都清除。
##	变量的声明
-	var a = 1,
		b = 2,
		now = new Date();
-	插入迭代值	var name = values[i++];
-	不提倡new Array()  new Object()		而是const a = [1,2,3]	直接赋值
-	数字转换为字符串速度最快的是	num+''--->string 
-	parseInt()是用于将字符串转换成数字
##	rmf算法
-	从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程
	思想。
-	构成递归需具备的条件：
	子问题须与原始问题为同样的事，且更为简单；
	不能无限制地调用本身，须有个出口，化简为非递归状况处理。
-	递归与普通循环的区别是：循环是有去无回，而递归则是有去有回	它不是一次性完成的，是通过不断重复的，但每次重复又比之前更好一点，
	这样一种非线性的进程。
-	在循环的次数较大的时候，迭代的效率明显高于递归。
-	迭代是一种线性的进程。
-	递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。
-	迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。
-	迭代可以转换为递归，但递归不一定能转换为迭代。
-	选择排序--》n个数据里面选择最小值--》n-1个数据里面寻找最小值--》n-2 n-3 n-4...1
-	插入排序--》2 3 4 5 6...n个数据是依次排序好的数据--》将第一待排序序列第一个元素看做一个有序序列，把第二
	个元素到最后一个元素当成是未排序序列。--》从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。
-	 for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
-	希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序--》
	待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。
-	归并排序-->分而治之思想--》
-	 var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
-	 while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
-	快速排序
-	从数列中挑出一个元素，称为 "基准"（pivot）;重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比
	基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
-	线性数据结构
	-	线性表
		-	数据元素之间的关系是一对一的关系
	-	栈
		-	只能在栈顶进行插入删除
	-	双端队列
	-	数组
	-	串 包含单个或者多个字符的有序序列
##	rmf笔试
-	parent不是js的保留字
-	保留关键字不可以用作变量、标签或者函数名。有些保留关键字是作为 Javascript 以后扩展使用。
-	[] == ![]		-->true
-	null == undefined   -->true
-	null === undefined   -->false
-	null instanceof Object	-->false		null可以理解是原始数据类型  但是不属于object
-	typeof null			-->object		
-	foo对象有att属性	获取att属性的值		foo.att 		foo['att'] 
-	js全局函数		String()  Number()	eval()	encodeURIComponent()	decodeURIComponent()	isNaN()
-	isNaN() 函数用来确定一个值是否为NaN 
-	isFinite()	检查某个值是否为有穷大的数。
-	parseFloat()	解析一个字符串并返回一个浮点数。
-	parseInt()	解析一个字符串并返回一个整数。
-	全局函数与内置对象的属性或方法不是一个概念。全局函数它不属于任何一个内置对象
-	label标签的**for属性和input框的id属性相互绑定**	那么最后就是点击lable的时候	实际点击的是input标签
-	label元素**不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性**。如果您在 label 元素内
	点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。
-	input框设置display:none		但是lable标签里面的文本还是显示的  点击label标签里面的文本相当于点击了input框  那么就触发了 点
	击事件		label的for属性和input框的id属性的配合		方便了元素样式在出现和消失样式的设置	类似事件委托
-	label标签的关联方式主要有两种，显示关联和隐式关联：
	-	显式关联是通过label标签的for属性，显式与另一个表单控件id关联
	-	隐式关联是**直接将表单控件放到label标签内**，这种情况下，label标签只能包含一个表单元素，包含多个只对第一个有效。
-	label可以关联的表单元素		**lable的for		和表单的id**
	-	type
		-	text		checkbox	radio	file	paddword	
	-	textarea	select
-	null === null -->true
-	null == 0 -->false
-	[] == [] --》false
-	typeof NaN	-->number
-	typeof null -->object
-	null == object	-->false
-	[] == false   0   '' -->true
-	false == ''    '  '   0		-->true
-	引用数据类型比较的是空间地址
-	对象==字符串 ： 对象转字符串，字符串比较
-	布尔==字符串 ： 布尔转数字，字符串转数字
-	Chrome默认最小字号是12px
-	content-length
-	Content-Length 是一个实体消息首部，用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。
-	是服务端告诉客户端body的大小有多大。
-	Http协议的请求报文和回复报文都有header和body，body就是你要获取的资源，例如一个html页面，一个jpeg图片，
	而header是用来做某些约定的。例如客户端与服务端商定一些传输格式，客户端先获取头部，得知一些格式信息，然后才开始读取body。
-	客户端： Accept-Encoding:gzip （给我压缩一下，我用的是流量，先下载下来我再慢慢解压吧）
	服务端1：Content-Encoding:null(没有Content-Encoding头。 我不给压缩，CPU没空，你爱要不要）
	服务端2：Content-Encoding:gzip (给你节省流量，压缩一下）
-	去除重复的字符str.replace(/(.)\1+/g,'$1')
-	Math.cbrt()数据的立方根
-	

##	rmfjs
-	JavaScript 可以通过不同的方式来输出数据：
	使用 window.alert() 弹出警告框。
	使用 document.write() 方法将内容写到 HTML 文档中。
	使用 innerHTML 写入到 HTML 元素。
	使用 console.log() 写入到浏览器的控制台。
-	JavaScript 对大小写是敏感的。
-	您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：
-	document.write("你好 \
	世界!");
-	你好世界
-	null undefined的理解
-	在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法
-	undefined表示一个变量没有被声明，或者被声明了但没有被赋值（未初始化），一个没有传入实参的形参变量的值为
	undefined，如果一个函数什么都不返回，则该函数默认返回undefined。null则表示“什么都没有”，即“空值”。
	Javascript将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的；
	undefined不是一个有效的JSON，而null是；
	null 和 undefined 的值相等，但类型不等：undefined的类型(typeof)是undefined；null的类型(typeof)是object。	null 逻辑上是空对象指针	那么 typeof null --> object
-	在'null'上执行算术转换时，则值为0，
-	但是，“undefined”不执行任何此类转换	如果您尝试将“undefined”添加到数字中，您将获得NaN或Not-a-Number
-	Undefined 这个值表示变量不含有值。
	可以通过将变量的值设置为 null 来清空变量。
-	对象也是一个变量，但对象可以包含多个值（多个变量）
-	person["lastName"]		访问对象属性的一种方式
-	value = person.fullName();
-	value为函数的返回值
-	value = person.fullName;
-	value为函数的内容
-	因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。
	局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。
-	局部变量在函数执行完毕后销毁。
	全局变量在页面关闭后销毁。
-	var lastname="Doe",
		age=30,
		job="carpenter";
-	数据声明定义的常用格式
-	JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型：
-	var x;               // x 为 undefined
	var x = 5;           // 现在 x 为数字
	var x = "John";      // 现在 x 为字符串
-	toFixed()	把数字转换为字符串，结果的小数点后有指定位数的数字。会进行四舍五入
-	Number(" ")       // 返回 0
-	Number("99 88")   // 返回 NaN
-	+ 可用于将变量转换为数字：
-	var y = "5";      // y 是一个字符串
	var x = + y;      // x 是一个数字
-	如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字)
-	Boolean([])	-->true			Boolean({})	-->true
-	JavaScript 中的所有数据都是以 64 位浮点型数据(float) 来存储。
-	在 JavaScript 中, 对象 使用 名字作为索引。
-	person["age"] = 46;
-	在 JavaScript 中, 全局作用域是针对 JavaScript 环境。
	在 HTML 中, 全局作用域是针对 window 对象。
-	使用 var 关键字声明的全局作用域变量属于 window 对象
-	使用 let 关键字声明的全局作用域变量不属于 window 对象
-	在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量
-	使用 var 关键字声明的变量在任何地方都可以修改
-	在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量
-	在相同的作用域或块级作用域中，不能使用 var 关键字来重置 let 关键字声明的变量
-	const声明的常量必须初始化，而let声明的变量不用
	const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改。
-	我们不能对常量数组重新赋值			或者数组
-	const cars = ["Saab", "Volvo", "BMW"];
	cars = ["Toyota", "Volvo", "Audi"];  
-	const let关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。
-	JSON 是用于存储和传输数据的格式。
	JSON 通常用于服务端向网页传递数据 。
-	JSON 格式仅仅是一个文本。	文本可以被任何编程语言读取及作为数据格式传递
-	rmfasync异步编程
-	JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。
-	resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。
-	如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作
-	catch 块只会执行第一个
-	then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。
-	await 指令后必须跟着一个 Promise
-	在函数表达式存储在变量后，变量也可作为一个函数使用
-	内置的 JavaScript 函数构造器（Function()）
-	函数也可以访问函数外部定义的变量
-	removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄
-	element.removeEventListener("mousemove", myFunction);
-	appendChild() 方法，它用于添加新元素到尾部。
-	将新元素添加到开始位置，可以使用 insertBefore() 方法
	-	parentElement.insertBefore(newChild, referenceChild)
	-	子节点会插入到 referenceChild 的前面 也就是指定位置
-	parent.removeChild(child);
-	DOM 需要清楚您需要删除的元素，以及它的父元素
-	child.parentNode.removeChild(child)
-	child.parentNode.replaceChild(newChild,child)
-	getElementsByTagName() 方法返回 HTMLCollection 对象。
-	HTMLCollection 无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。
-	getElementsByClassName()	所有浏览器的 childNodes 属性返回的是 NodeList 对象。
-	大部分浏览器的 querySelectorAll() 返回 NodeList 对象。
-	HTMLCollection 是 HTML 元素的集合。
-	NodeList 是一个文档节点的集合。
-	节点列表不是一个数组！
-	节点列表看起来可能是一个数组，但其实不是。
-	在一个已存在构造器的对象中是不能添加新的属性
-	使用 prototype 属性就可以给对象的构造函数添加新的属性
-	极大或极小的数字可通过科学（指数）计数法来写
-	var y=123e5;    // 12300000
-	var z=123e-5;   // 0.00123
-	所有 JavaScript 数字均为 64 位
-	此格式用 64 位存储数值，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号
-	var x = 0.2+0.1; // 输出结果为 0.30000000000000004
-	可以使用 toString() 方法 输出16进制、8进制、2进制。
-	var myNumber=128;
	myNumber.toString(16);   // 返回 80
-	数字可以是数字或者对象
-	var x = 123;
	var y = new Number(123);
-	toPrecision()	
	返回一个指定精度的数字
-	var a=123;
	b=a.toPrecision(2); // b="1.2e+2"		2代表截取a的前面两位数据之后再进行转为指数形式	结果是字符串
-	其中包含了四舍五入
-	toExponential()	返回一个数字的指数形式的字符串，如：1.23e+2
-	toFixed()	
	返回指定小数位数的表示形式。		b=a.toFixed(2); // b="123.00"
-	JavaScript 是属于 HTML 和 Web 的编程语言。
-	html 结构		css	样式		js	行为
-	表达式是**值、变量和运算符**的组合，计算结果是值。
	-	6 * 10
-	在 JavaScript 中，**首字符必须是字母、下划线（-）或美元符号（$）**
-	===    ==相差的是**类型上面的比较**
-	任何变量均可通过设置值为 **undefined 进行清空**。其类型也将是 undefined。
-	空值与 undefined 不是一回事。**空的字符串变量既有值也有类型**。
-	Undefined 与 null 的**值相等，但类型不相等**
-	**类型转换**
	-	Number 类型的 toString() 方法比较特殊，它有两种模式，即**默认模式和基模式**
	-	在**默认模式**中，无论最初采用什么表示法声明数字，Number类型的toString()方法返回的都是数字的十进制表示
	-	采用 Number 类型的 toString() 方法的**基模式**，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。
		-	var iNum = 10;
			alert(iNum.toString(2));	//输出 "1010"
			alert(iNum.toString(8));	//输出 "12"
			alert(iNum.toString(16));	//输出 "A"
-	两种把**非数字的原始值转换成数字的方法**，即 parseInt() 和 parseFloat()。
	-	**只有对 String 类型调用这些方法，它们才能正确运行**；对其他类型返回的都是 NaN。
	-	parseInt() 方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由 parseInt() 方法的第二个参数指定的，所以要解析十六进制的值，需如下调用 parseInt() 方法
		-	var iNum1 = parseInt("AF", 16);	
		-	parseInt('str',mode)	->**以mode进制来转换为十进制**
	-	parseFloat()
		-	对于这个方法来说，**第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的**。parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 "11.22.33" 将被解析成 11.22。
		-	使用 parseFloat() 方法的另一不同之处在于，**字符串必须以十进制形式表示浮点数**
-	**Number(undefined)	NaN**
-	强制转换成字符串和调用 toString() 方法的唯一不同之处在于，**对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误**
-	没有 () 的函数将返回函数定义
-	由于局部变量只能被其函数识别，因此可以在不同函数中使用相同名称的变量。
	**局部变量在函数开始时创建，在函数完成时被删除。**
-	函数中的参数
	-	（根据 Netscape 的文档，**最多可接受 255 个**），而不会引发任何错误。任何遗漏的参数都会以 **undefined**传递给函数，多余的函数将忽略。
-	**对象冒充可以实现多重继承**
	-	function ClassZ(color,name) {
		this.newMethod = ClassX;
		this.newMethod(color);
		delete this.newMethod;

		this.newMethod = ClassY;
		this.newMethod(name);
		delete this.newMethod;
	}
	-	这里存在一个弊端，**如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法**，**ClassY 具有高优先级**。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。
-	prototype 对象是个模板，要**实例化的对象都以这个模板为基础**。总而言之，**prototype 对象的任何属性和方法都被传递给那个类的所有实例**。原型链利用这种功能来实现继承机制
-	**位运算符是在数字底层（即表示数字的 32 个数位）进行操作的**。
-	**负数的补码是正数的反码加一**
-	**~运算符**
	-	把运算数转换成 32 位数字
	-	把二进制数转换成它的二进制反码
	-	把二进制数转换成浮点数	
	-	~x			-->			-x-1
-	**左移运算**
	-	var iOld = 2;			//等于二进制 10		**记住先转换为二进制**
		var iNew = iOld << 5;	//等于二进制 1000000 十进制 64
	-	左移运算**保留数字的符号位**
		-	如果把 -2 左移 5 位，得到的是 -64
-	**无符号右移运算**			**>>>**
	-	**负数无符号右移运算**的时候会出现问题
	-	**负数则被作为正数来处理**		负数当作正数处理		那么结果是会偏大的
-	JavaScript 并**没有一个标准来统一其语法或特性**		是ECMA诞生的原因
-	引用类型数据**放在变量的栈空间中的值是该对象存储在堆中的地址**。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响
-	typeof
	-	对应声明但是没有初始化		没有任何声明的变量	是没有具体区分的	返回的是undefined
	-	但是这两种变量是typeof的特例		其他运算操作对于没有任何声明的变量是会报错的
	-	函数没有明确的返回值的时候	返回的是undefined
-	ECMAScript 默认把具有 6 个或 6 个以上前导 0 的浮点数转换成科学计数法
	-	8-e17
-	大于MAX_VALUE		就是		POSITIVE_INFINITY		1.7E308
-	小于MIN_VALUE		就是		NEGATIVE_INFINITY		5e-324
-	**Object 对象**		ECMAScript 中的**所有对象都由这个对象继承而来**
	-	hasOwnProperty(property)	
		-	**判断对象是否有某个特定的属性**。必须用字符串指定该属性。（例如，o.hasOwnProperty("name")）
	-	IsPrototypeOf(object)	**判断该对象是否为另一个对象的原型**。
		-	a.prototype.isPrototypeOf(b)				b = new a()
		-	**a的原型对象是否出现在b的原型链上面**
	-	valueOf
		-	**对象是复合值，而大多数对象无法真正表示为一个原始值**，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值
		-	**undefined和null没有valueOf()方法**

##	rmfrouter
-	hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/
	#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash **不会重新加载页面。**
	-	**访问index.html文件		按照对应的哈希值来加载对应的组件文件**
	-	window.onhashchange=function(event){
		let newURL = event.newURL
	}
-	history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏
	览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。
	-	访问规则是	服务器预先定制的规则	history重写url路径	
-	history.pushState() 相比于直接修改 hash，存在以下优势:
	pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
	pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
	pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
	pushState() 可额外设置 title 属性供后续使用。
-	history模式看起来是加载了页面文件	但是没有服务器配置转发机制	那么路径下面没有对应的组件文件	就会返回404
	重写url路径
##	三次握手	四次挥手
-	第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是
	正常的。
	第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
	第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
##	rmfjs继承
-	原型链继承
-	Son.prototype = new Father(); //原型链继承
-	A：重写了Son的原型，让子类原型和子类构造函数之间断开联系。
	B：子类原型是父类的实例，其原型指针[[prototype]]指向了父类的原型对象，这样子类就可以沿着原型链访问到父类的方法
	C：子类原型是父类实例，通过父类构造函数，子类原型继承了父类的属性superproperty。
	最终，子类继承了父类的方法和属性。属性是基本类型值时没有问题，但如果是**引用类型值**（比如数组），那么修改实例1的该属性（比如向数组push一个新值），实例2也会跟着改变。
	arr.push(3)	-->arr还是旧的地址			arr=[1,2,3]//arr是新的地址了
	实例们**只有共性，不能保持个性**。
	记得修改子类的构造函数
-	构造继承
-	function Son(){
    //继承了Father，同时还传递了参数 
    Father.call(this,"Nicholas");
    this.age = 29;
	}
-	在子类构造函数中调用了父类的构造函数，创建子类实例会执行子类的构造函数（含父类的构造函数），也就完成了继
	承。
-	方法在构造函数中定义，无法实现函数复用。比如父类中有一个方法getName()，则每次创建子类实例的时候，都要创
	建一个新的getName()，
-	实例们保持了个性，却不能共享方法。
-	组合继承
-	构造函数来继承属性，原型链来继承方法。
-	让实例们即保持个性，又共享方法。
-	prototype属性给函数和对象添加了可以共享的属性和方法
	__proto__是查找某函数或者对象的原型链的方式

##	rmfes6
-	继承
-	子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继
	承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
-	static关键词声明方法：比如 static hello() {}
-	static hello() {
    console.log('hello world');
	}
-	class Son extends Father {
	 }
-	let cp = new ColorPoint(25, 8, 'green');
	cp instanceof ColorPoint // true
	cp instanceof Point // true
-	实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。
-	Object.getPrototypeOf方法可以用来从子类上获取父类。因此，可以使用这个方法判断，一个类是否继承了另一个
	类。
-	Object.getPrototypeOf(ColorPoint) === Point
-	super作为函数调用时，代表父类的构造函数。
-	super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相
	当于A.prototype.constructor.call(this)。
-	super()只能用在子类的构造函数之中，用在其他地方就会报错。
-	**super作为对象时，在普通方法中，指向父类的原型对象A.prototype；在静态方法中，指向父类。**
-	super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。
-	每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有
	prototype属性和__proto__属性，因此同时存在两条继承链。
-	子类的__proto__属性，表示构造函数的继承，总是指向父类。
-	子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。
-	class A {
	}

	class B extends A {
	}

	B.__proto__ === A // true
	B.prototype.__proto__ === A.prototype // true
-	Object.setPrototypeOf = function (obj, proto) {
	obj.__proto__ = proto;
	return obj;
	}
-	子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父
	类的原型。
-	 p2.__proto__.__proto__ === p1.__proto__ // true
-	ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，
	使得父类的所有行为都可以继承。
-	static在用父类实例的方法属性		其他方法就是原型上面使用方法
-	for循环的特别之处	循环变量那一部分是一个父作用域	但是循环体内部是一个单独的子作用域
-	for循环里面使用var声明变量  变量会泄露为全局变量
-	避免在块级作用域里面声明函数
-	es6有六种声明变量的方法  var  function   let  const  import  class
-	顶层对象是window	node里面指的是global
-	类的数据类型就是函数	类本身就是指向构造函数的 使用的时候直接new className()
	类中添加方法是不用添加关键字function的
	类的所有方法都定义类的prototype上面		类的实例调用方法 实际上就是调用原型上面的方法
	Point.prototype.constructor === Point
	类的内部所有定义的方法都是不可枚举的
	类的所有实例共享一个原型对象
	p1.__proto__ === p2.__proto__
	可以通过__proto__来为类添加方法	但是不推荐使用 这样会影响所有实例 改变了类的原始定义
	getter   setter函数		对某个属性设置存值函数和取值函数 拦截属性的存取行为
	getter setter函数都在Descriptor上面
-	属性表达式
	let methodName = 'getArea'
	class Square{ [methodName](){}}
-	类和模块的内部默认的是严格模式
	-	类不存在变量提升		new Class1();class Class1{}
	-	es6的类本质上是es5构造函数的一层包装  所以许多函数的特性被class继承  比如name属性
	-	class Point{};Point.name		name 属性总是紧跟class关键字后面的 类名
	-	方法之前加上*   方法就变为了Generator函数  function* fn(){}
	-	Symbol.iterator返回类的默认遍历器
		* [Symbol.iterator](){for(let i of this.args){yield arg}}
	-	 const proxy = new Proxy(target, handler);
		return proxy;
-	类中的static方法是不会被实例继承的	而是通过类来直接调用的方法	这称为静态方法
-	静态方法包含的this指向的是类		而不是实例
-	静态方法可以和非静态方法重名
-	父类的静态方法可以被子类继承使用
-	es6规定class内部只有静态的方法  没有静态的属性	已经有一个提案提出static prop来定义静态属性使用
-	旧的静态属性的添加方式		class Class1{};Class1.prop1 = 1;prop1就是静态属性
-	私有方法和属性就是只能在类的内部使用  外部是不能访问使用的
-	将私有方法移出模块		调用call函数来改变函数的指向  将函数变为私有的方法
-	class class1{
	foo(para){
		bar.call(this,para)
	}
	}
	bar(){}
	bar函数成为了私有的方法
-	new.target用来确定构造函数是怎么调用的		构造函数不是new调用的 会返回undefined
	返回new命令作用于的那个构造函数
	Person.call(person,para)	person的构造函数不是通过new调用的
	if(new.target === Person){
		this.name = name
	}else{
		throw new Error('必须使用new命令生成实例')
	}
-	子类继承父类的时候  new.target返回的是子类
-	Object.getPrototypeOf(son) === father可以用来从子类上获取父类
-	子类普通方法中通过super调用父类的方法	方法内部的this指向的是子类的this
-	使用super的时候	必须显式指定是作为函数还是对象来使用super的		否则会报错
-	class存在两条继承链	
	-	B.__proto__ === A
	-	B.prototype.__proto__ === A.prototype
-	原生构造函数的继承	以前这些构造函数是无法继承的  不能自己定义一个Array的子类
	子类无法获取原生构造函数内部属性	原生构造函数会忽略apply call方法传入的this	也就是说原生构造函数的
	this是无法绑定的	导致获取不到内部属性	
-	es6允许原生构造函数来定义子类	因为es6是新建父类的实例对象的this	然后再用子类的构造函数修饰this
	使得父类的所有行为都可以被继承
	class MyArray extends Array{
		constructor(...args){
			super(...this)
		}
	}
-	extends关键字不仅可以用来继承类		还可以用来继承原生构造函数	在原生构造函数的数据解构上面来定义
	自己的数据结构
	继承Object子类的时候 有一个行为怪异
	就是es6改变了Object的函数行为	一旦发现Object方法不是通过new Object()这种形式调用的 Object
	构造函数会忽略参数
-	**函数直接返回对象**
	-	return {x,y}
-	对象中直接书写函数
	-	var obj = {method(){console.log('me')}}
		-	**简写的对象方法不能用作构造函数**
	-	var obj = {method:function(){console.log('me')}}
-	**表达式）作为对象的属性名，即把表达式放在方括号内**		表达式还可定义方法名
	-	var obj = {['a'+'bc']:123,['say'+'hello'](){console.log('hello')}}
			obj.abc//123
-	属性名表达式是	一个对象		**默认情况下会自动将对象转化为字符串**
-	**对象的方法使用了取值函数（ getter ）和存值函数（ setter ）**，则 name 属性不是在该方法上面，而是该方法的属性的**描述对象的 get 和 set 属性上面**，返回值是**方法名前加上 get 和 set** 。
	-	var obj = {
		get foo(){}
		set foo(x){}
	}
		obj.foo.name//throw new error
		var getfooddescriptor = Object.getOwnPropertyDescriptor(obj,'foo')
		getfooddescriptor.get.name//'get foo'
-	对象方法使用了get 		set		那么函数的name属性是在**函数的表达对象上面**
	-	Object.getOwnPropertyDescriptor(obj,'foo')//foo是函数名
	-	返回的装饰器对象加上get set获取函数名
-	**对象的方法是一个 Symbol 值，那么 name 属性返回的是这个 Symbol 值的描述**。
	-	var	key1 =  Symbol('symboldes')
		var obj = {[key1](){}}
		obj[key1].name
	-	对象调用函数的方式		不使用点运算符号		因为函数是简写的方式
	-	var	key1 =  Symbol('symboldes')
		var obj = {[key1]:function(){}}
		obj[key1].name
-	**对象的每个属性都有一个描述对象**
	-	Object.getOwnPropertyDescriptor(obj,'parameter')
-	四个操作会忽略 enumerable 为 false 的属性		**不可枚举的属性是不可遍历的操作**
	-	for in
	-	Object.keys()
	-	Object.stringify()
	-	Object.assign()
-	**对象中函数方法是不可枚举的**
-	使用for in 方法来进行数据的遍历			可以尽量避免使用for in 		会枚举继承的属性	
	使用Object.keys()更加适合
-	遍历对象的属性
	-	for in
	-	Object.keys()
	-	Object.getOwnPropertyNames()
	-	Reflect.ownKeys(obj)
		-	包含了对象的所有属性 	**包括symbol**
-	super关键字
	-	this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 super ，指向**当前对象的原型对象**。
	-	**设置对象的原型对象**		setPrototypeOf
		-	Object.setPrototypeOf(obj,obj2)
		-	var obj = {foo(){return super.para}}
			var obj2 = {para:'obj2para'}
			Object.setPrototypeOf(obj,obj2)
			obj.foo()
		-	super的作用的有效性		还取决于函数的写法
		-	正确函数的写法
			-	foo(){}		//js引擎认为对象的属性foo	的super是正确的使用
		-	错误函数的写法
			-	foo:()=>{}
			-	foo:function(){return super.para}
			-	foo:super.para
				-	**super 用在一个函数里面	然后赋值给obj对象的属性**
				-	super不是在对象中直接使用的方法是错误的
				-	还有就是对象属性中的super的使用直接修饰了对象的属性
-	super.para		-->		Object.getOwnPrototypeOf(this).para
	-	这是函数中的解释
-	**解构赋值的拷贝是浅拷贝**




##	symbol
-	你使用了一个他人提供的对象，但又想**为这个对象添加新的方法**（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从**根本上防止属性名的冲突**。
	-	let s = Symbol()
	-	**Symbol 函数前不能使用 new 命令**，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 **Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。**
	-	Symbol 函数的**参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的**。
		-	let s1 = Symbol()
			let s2 = Symbol()
			s1 === s2//false
	-	Symbol 值**不能与其他类型的值进行运算，会报错**
	-	创建 Symbol 的时候，可以添加一个描述。
		const sym = Symbol('foo');
		-	读取这个描述需要**将 Symbol 显式转为字符串**
			const sym = Symbol('foo');
			String(sym) // "Symbol(foo)"
			sym.toString() // "Symbol(foo)"
			ES2019 提供了一个实例属性 description ，**直接返回 Symbol 的描述**
			sym.description // "foo"
-	**由于每一个 Symbol 值都是不相等的**，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能**保证不会出现同名的属性**
	-	var obj = {}
		var symbolmy = Symbol()

		-	obj[symbolmy]=''

		-	var obj = {
			[symbolmy]:'ok'
		}//**对象中使用symbol		使用中括号**

		-	Object.defineProperty(obj,symbolmy,{value:'ok'})
-	**点运算符后面总是字符串，所以不会读取 mySymbol 作为标识名所指代的那个值**，导致 a 的属性名实际上是一个字符串，而不是一个 Symbol 值。
	-	const mySymbol = Symbol();
		const a = {};
		a.mySymbol = 'Hello!';
		a[mySymbol] // undefined
		a['mySymbol'] // "Hello!"
		//因为点运算符		那么使用字符串来访问数据
	-	对象使用Symbold数据		obj[symbolmy]		obj[symbolmy](argsmy)
-	魔术字符串指的是，在代码之中**多次出现、与代码形成强耦合**的某一个具体的字符串或者数值
-	字符串改为数值运算方式		str-'0'
-	**shapeType.triangle 等于哪个值并不重要，只要确保不会跟其他 shapeType 属性的值冲突即可**。因此，这里就很适合改用 Symbol 值
-	Symbol作为属性名，遍历对象的时候，该属性不会出现在**for...in 、 for...of 循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 、 JSON.stringify()**返回。
-	 **Reflect.ownKeys() 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名**。
-	Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，**为对象定义一些非私有的、但又希望只用于内部的方法**


##	Reflect
-	Reflect 对象与Proxy 对象一样，也是 ES6 为了**操作对象而提供的新 API**
-	设计目的
	-	**将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty ），放到 Reflect 对象上**。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，**从 Reflect 对象上可以拿到语言内部的方法**。
	-	修改某些 Object 方法的**返回结果，让其变得更合理**
		-	Object.defineProperty(obj, name, desc) 在**无法定义属性时，会抛出一个错误**，而 Reflect.defineProperty(obj, name, desc) 则会**返回 false** 。
	-	**让 Object 操作都变成函数行为**。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name] ，而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了**函数行为**。
		-	if('name' in obj)		判断属性有无在对象中存在		这是命令行为
			转变为函数行为		Reflect.has(obj,'name')
	-	**Reflect对象的方法与 Proxy对象的方法一一对应**，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，**作为修改行为的基础**
	


##	es6 module模块的语法
-	es6模块的设计思想尽量静态化 使得编译时就能确定模块的依赖关系 以及输出输入的变量
	commonjs  amd模块都只可在运行时确定这些东西
	let {stat,exists,readfile} = require('fs')
	这句代码就是整体加载fs模块  生成一个_fs对象	再从对象上面读取三个方法 这种加载叫做运行时加载
	只有运行的时候才能得到这个对象		导致不可在编译时'静态优化'
-	es6模块不是对象	而是通过export命令显式指定输出的代码	再通过import命令来引入
-	es6模块
	-	import {stat,exists,readFile} from 'fs'
		这种方法叫做编译时加载   静态加载
		es6在编译时完成了模块的加载	效率更加高
-	es6模块自动采用的是严格模式
	-	变量必须声明之后使用
	-	不可对只读属性赋值 否则报错
	-	不能使用前缀0来表示八进制数据 
	-	禁止this指向全局对象
	-	arguments不会自动反应函数参数的变化
	-	增加了保留字 static protected  interface
-	模块主要由两个命令构成 export  import
	export用于规定模块的对外接口
	import用于输入其他模块提供的功能
##	export命令
-	export{firstName,lastName,year}
-	export命令可以输出函数 类 变量
-	export输出的变量就是本来的名字		可以使用as关键字来重命名
	function v1(){}
	export{
		v1 as streamV1
	}
	v1被重命名了
-	export 1					-->错误
-	export var m = 1			-->正确
-	var m = 1;export m;			-->错误
-	var m = 1;export {m}		-->正确
-   var n = 1;export{n as m}	-->正确
-	export function f(){}		-->正确
-	function f(){};export{f}	-->正确
-	CommonJs输出的是值的缓存  不存在动态更新
##	import命令
-	import用来加载模块
	import {file1,file2} from './file.js'
	import {file1 as myFile} from './file.js'
	import * as myModule from './file.js'
-	import命令输入的变量都只是可读的	不存在加载模块脚本里面 	改写接口
	但是如果引入的模板文件是一个对象	那么是可以修改对象上面的属性的
-	import命令具有提升效果	会提升到整个模块的头部	首先执行
-	import是静态执行的	所以不能执行表达式和变量
-	多条同样的import语句 只会执行一次 而不是执行多次	
-	import()函数可以用在任何地方	不仅仅是模块 非模块的脚本也可以使用import函数
	它是运行时执行的函数	什么时候运行到这一句	就会加载指定的模块	import()函数和加载的模块没有静态
	连接关系	import()函数是异步加载的
	import('./file.js')
	.then(()=>{

	})
	.catch(()=>{

	})
	import('./myModule.js')
	.then(({export1, export2}) => {
	// ...·
	});
	export1 export2是myModule.js的输出接口  可以解构获取
-	浏览器脚本异步加载的两种方式
	-	<script src="path/to/myModule.js" defer></script>
		<script src="path/to/myModule.js" async></script>
	-	defer  async的使用
		defer要等到整个页面渲染完成	以及其他脚本执行完成	才会执行	defer是渲染完执行
		async一旦下载完成	渲染引擎就会中断渲染	执行这个脚本之后 在继续渲染	async是下载完后执行
		多个defer的script标签是按照页面出现的顺序加载的
		但是多个async的脚本的执行顺序是没有保证的
	-	浏览器加载es6模块	也是用script标签	但是要加上type='module'
		这样浏览器就知道只是一个es6模块
		<script type='module' src='./file.js'></script>
	-	带有type='module'的		都是异步加载的	不会造成堵塞浏览器 等到整个页面渲染完成	再执行模板文件
		等同于打开了script标签的defer属性
	-	async会感染带有type='module'的标签的执行顺序	会按照async的玩法进行加载
	-	es6模块允许内嵌在网页中
		<script type="module">
		import $ from "./jquery/src/jquery.js";
		</script>
-	异步加载 css
-	alternate
	-	<link rel="alternate stylesheet" href="myCss.css" onload="this.rel='stylesheet'">
-	media
	-	<link rel="stylesheet" href="myCss.css" media="noexist" onload="this.media='all'">
-	对于外部的模块脚本
	-	代码是在模块作用域里面执行的	而不是全局作用域里面执行的	外部是不可见的
	-	模块脚本自动采用严格模式
	-	es6模块之中	顶层的this关键字返回的是undefined	而不是window	模块顶层使用this是无意义的
	-	commonJs模块的顶层this指向当前模块
##	es6 commonJs的差异
-	commonJs模块输出的是一个值的拷贝	es6模块输出的是值的引用
-	commonJs模块是运行时加载	es6是编译时输出接口
	-	commonJs加载的是一个对象	对象只有在脚本运行完成时候才能生成
	-	但是es6模块不是对象	它的对外接口是一种静态定义	在代码静态解析的时候才会生成
	-	es6模块是动态引用	并且 不会缓存值  模块里的变量绑定其所在的模块
##	node.js里面加载文件
-	.mjs总是以es6模块加载文件
-	.cjs总是以commonJs模块加载
-	可以整体加载	也可以按需加载
##	pack.json
-	文件中有两个字段可以指定模块的入口文件
-	main   和   	exports
-	"main":"./src/index.js"		项目的入口文件是指定的路径
-	exports字段的优先级要高于main		可以指定脚本或者子目录的别名
-	"exports":{"./submodule":"./src/submodule.js"}		别名是submodule
-	exports的别名是'.'	代表模板的主入口	可以直接简写exports字段的值
-	"exports":"./main.js"
-	exports字段只有支持es6的node.js才认识	旧版本的node.js是不认识的
##	加载路径
-	es6模块的加载路径必须给出脚本的完整路径
##	循环加载
-	a脚本的执行依赖于b脚本		b脚本的执行依赖于a脚本
-	循环加载表示存在强耦合 处理不好	程序无法执行
-	commonJs模板无论加载多少次	都只会在第一次加载时运行一次	以后再次加载 会返回第一次运行的结果
	除非手动清理缓存
-	commonJs的循环加载
-	a.js和b.js之间存在相互引用	循环加载的时候就会有着规律
	-	先执行a.js  那么到达引用b.js的位置	接着去b.js的文件去执行	到达引用a.js的位置	再次去a.js的位置
		取回已经执行的部分	而不是最后的结果
	-	回到b.js	b.js执行完成	回到a.js	执行完成
	-	commonjs输入的是被输出的值的拷贝	不是引用
-	es6的循环加载
	-	es6模块是动态引用	引入的变量可以写成函数的形式来解决接口未定义的问题
	-	function foo(){console.log('foo')}
		export {foo}
	-	在其他.mjs文件引入的时候就不会出现未定义的错误
##	export default命令
-	export default function(){}
-	export default function foo(){}
	默认输出一个函数	引入的时候可以为这个函数取任意的函数名
	就算函数命名为foo 	但还是视同匿名函数加载	因为用到了export default
	import anonymousFunction from './file.js'
-	用export default	一个模块只有一个默认输出	那么export default只可以用一次
	那么相应的就是import 的大括号就可以省略不写	因为export default只默认暴露了一个对象
	export {foo,bar} from 'my_module'
	这是export  import的复合写法	相当于
	import {foo,bar} from 'my_module'
	export {foo,bar}
	foo,bar实际上并没有导入到当前模块 只是相当于对外转发了这两个接口	导致当前模块不可直接使用foo,bar
-	export import 只能出现在模块的顶层	不可以在代码块中 比如在if语句	函数当中
	如若这样	会产生句法错误 而不是执行时错误
##	promise
-	Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大
-	ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。
-	Promise 是一个对象，从它可以获取异步操作的消息
-	Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）
-	resolve()		reject()来改变函数的状态
-	一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise 对象的状态改变，只有两种可能：从 
	pending 变为 fulfilled 和从 pending 变为 rejected 
-	有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
-	**promise的一些缺点**
	-	无法取消 Promise ，一旦新建它就会立即执行，无法中途取消
	-	不设置回调函数， Promise 内部抛出的错误，不会反应到外部
	-	当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
-	Promise 对象是一个构造函数，用来生成Promise 实例。
-	Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是resolve 和reject 。它们是两个函数
-	Promise 实例生成以后，可以用 then方法分别指定resolved状态和 rejected状态的回调函数。
-	promise.then(function(value) {
	// success
	}, function(error) {
	// failure
	});
-	then 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为 resolved时调用，第二个回调
	函数是 Promise对象的状态变为rejected时调用
-	一个异步操作的结果是返回另一个异步操作。
-	const p2 = new Promise(function (resolve, reject) {
	// ...
	resolve(p1);
	})
-	p1 的状态就会传递给 p2 ，也就是说， p1 的状态决定了 p2 的状态。如果 p1 的状态是 pending ，那么 p2 的
	回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 resolved 或者 rejected ，那么 p2 的回调函数将会立刻执行。
-	Promise 实例具有then方法，也就是说， then 方法是定义在原型对象 Promise.prototype 上的。
-	then 方法返回的是一个新的 Promise 实例
-	 reject() 方法的作用，等同于抛出错误。
-	promise构造	.then .catch方法会产生promise	
-	一般来说，不要在 then() 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），总是使用 catch 方
	法。	
-	someAsyncThing()
	.catch(function(error) {
	console.log('oh no', error);
	})
	.then(function() {
	console.log('carry on');
	});
-	上面代码运行完 catch() 方法指定的回调函数，会接着运行后面那个 then() 方法指定的回调函数。
-	finally()方法用于指定不管Promise对象最后状态如何，都会执行的操作
-	finally 方法的回调函数不接受任何参数	finally 方法里面的操作，应该是与状态无关的
-	finally 本质上是 then 方法的特例。
-	Promise.all()方法用于将多个Promise 实例，包装成一个新的 Promise 实例
-	const p = Promise.all([p1, p2, p3]);
	-	只有 p1 、 p2 、 p3 的状态都变成 fulfilled ， p 的状态才会变成 fulfilled
	-	只要 p1 、 p2 、 p3 之中有一个被 rejected ， p 的状态就变成 rejected
	-	作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected ，并不会触发 Promise.all() 
		的 catch 方法
-	Promise.all([p1, p2])
	.then(result => console.log(result))
	.catch(e => console.log(e));
	// ["hello", Error: 报错了]
	-	p2 首先会 rejected ，但是 p2 有自己的 catch 方法，该方法返回的是一个新的 Promise 实例， p2 指向
		实际上是这个实例。该**实例执行完 catch 方法后**，也会变成 resolved 
	-	const p2 = new Promise((resolve, reject) => {
		throw new Error('报错了');
		})
		.then(result => result)
		.catch(e => e);
-	**Promise.race()** 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
-	const p = Promise.race([p1, p2, p3]);			
-	只要 p1 、 p2 、 p3 之中有一个实例率先改变状态， p 的状态就跟着改变
-	**Promise.allSettled()** 方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例
-	只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected 包装实例才会结束
-	状态只可能变成 fulfilled 	该数组的每个成员都是一个对象
-	Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成 
	fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态
-	**Promise.resolve()**
-	有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。
-	参数是一个 Promise 实例
	如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。
-	参数是一个 thenable 对象
	thenable 对象指的是具有 then 方法的对象	Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。
-	参数不是具有 then 方法的对象，或根本就不是对象
	如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved 
-	**Promise.reject()**
-	Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected 。
-	Promise.reject() 方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数。这一点与 Promise.
	resolve 方法不一致。
-	Promise.reject 方法的参数是一个 thenable 对象	后面 catch 方法的参数不是 reject 抛出的“出错了”这个字符
	串，而是 thenable 对象。
-	**Promise.try()**
	-	更好地管理异常
	-	语句抛出同步错误的时候可以用到try  catch		Promise.try(()=>{}).then().catch()
-	同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 
-	**第一种写法**是用 async 函数来写		(async () => f())();
-	 f 是异步的，就可以用 then 指定下一步
-	(async () => f())()
	.then(...)
-	第二种写法是使用 new Promise() 
##	async
-	async 函数是什么？一句话，它就是 Generator 函数的语法糖。
-	async 函数对 Generator 函数的改进
	-	内置执行器。
		-	Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器
	-	更好的语义
	-	更广适用性
		-	 yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值
	-	返回值是 Promise。
		-	async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。
-	async 函数有多种使用形式。
	-	// 函数声明
		async function foo() {}
	-	// 函数表达式
		const foo = async unction () {};
	-	// 对象的方法
		let obj = { async foo() {} };
		obj.foo().then(...)
	-	// 箭头函数
		const foo = async () => {};
-	promise的reject resolve来改变状态     then catch是对应状态的操作
-	await 命令后面是一个 thenable 对象（即定义了 then 方法的对象），那么 await 会将其等同于 Promise 对
	象。
-	任何一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。
-	有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 await 放在 try...
	catch 结构里面，
	-	另一种方法是 await 后面的 Promise 对象再跟一个 catch 方法，处理前面可能出现的错误。
-	await 命令后面的 Promise 对象，运行结果可能是 rejected ，所以最好把 await 命令放在 try...catch 代码块
	中。
-	第二点，多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。
	-	// 写法一
		let [foo, bar] = await Promise.all([getFoo(), getBar()]);
	-	// 写法二
		let fooPromise = getFoo();
		let barPromise = getBar();
		let foo = await fooPromise;
		let bar = await barPromise;
-	多个请求并发执行，可以使用 Promise.all 方法。
-	async function dbFuc(db) {
	let docs = [{}, {}, {}];
	let promises = docs.map((doc) => db.post(doc));
	let results = await Promise.all(promises);
	console.log(results);
	}
-	async 函数**可以保留运行堆栈。**
	-	const a = async () => {
		await b();
		c();
		};
	-	b() 运行的时候， a() 是暂停执行，上下文环境都保存着。一旦 b() 或 c() 报错，错误堆栈将包括 a() 
-	async 函数的实现原理，就是将 Generator函数和自动执行器，包装在一个函数里。
-	const textPromises = urls.map(async url => {
    const response = await fetch(url);
    return response.text();
	});
-	map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响
-	顶层的 await 命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执
	行。
##	遍历器
-	JavaScript 原有的表示“集合”的数据结构，主要是数组（ Array ）和对象（ Object ），ES6 又添加了 Map 和
	Set
-	遍历器是一种线性处理
-	有一些场合会默认调用Iterator接口
	-	解构赋值
		-	对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。
		-	let [x,y] = set;
			// x='a'; y='b'
	-	扩展运算符
		-	扩展运算符（...）也会调用默认的 Iterator 接口
		-	var str = 'hello';
			[...str] //  ['h','e','l','l','o']
-	for...of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM 
	NodeList 对象）、后文的 Generator 对象，以及字符串
-	for...of 循环调用遍历器接口，数组的遍历器接口只返回**具有数字索引**的属性
	-	let arr = [3, 5, 7];
		arr.foo = 'hello';
		for (let i of arr) {
		console.log(i); //  "3", "5", "7"
		}
		foo不是数字索引
-	Set 和Map 结构也原生具有Iterator接口，可以直接使用 for...of 循环。
-	let interator = str[Symbol.iterator]();	// interator.next()
-	et 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组
-	var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
	for (var e of engines) {
	console.log(e);
	}
-	var es6 = new Map();
	es6.set("edition", 6);
	es6.set("committee", "TC39");
	es6.set("standard", "ECMA-262");
	for (var [name, value] of es6) {
	console.log(name + ": " + value);
	}
-	let map = new Map().set('a', 1).set('b', 2);
	for (let pair of map) {
	console.log(pair);
	}
	// ['a', 1]
	// ['b', 2]
-	entries() 返回一个遍历器对象，用来遍历 [键名, 键值] 组成的数组。对于数组，键名就是索引值；对于 Set，键
	名与键值相同。Map 结构的 Iterator 接口，默认就是调用 entries 方法。
	keys() 返回一个遍历器对象，用来遍历所有的键名。
	values() 返回一个遍历器对象，用来遍历所有的键值。
-	Array.from 方法将其转为数组。
-	对于普通的对象， for...of 结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用
	-	一种解决方法是，使用 Object.keys 方法将对象的键名生成一个数组，然后遍历这个数组。
-	JavaScript 提供多种**遍历语法**。最原始的写法就是 for 循环。
	-	这种写法比较麻烦，因此数组提供内置的 forEach 方法。
		无法中途跳出 forEach 循环， break 命令或 return 命令都不能奏效。
	-	myArray.forEach(function (value) {
		console.log(value);
		});
	-	for...in 循环可以遍历数组的键名。
	-	for...in 循环有几个缺点。
		-	数组的键名是数字，但是 for...in 循环是以字符串作为键名“0”、“1”、“2”等等。
		-	for...in 循环主要是为遍历对象而设计的，不适用于遍历数组。
		-	for...in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
	-	for...of 循环相比上面几种做法，有一些显著的优点。
		-	有着同 for...in 一样的简洁语法，但是没有 for...in 那些缺点。
		-	不同于 forEach 方法，它可以与 break 、 continue 和 return 配合使用。
		-	提供了遍历所有数据结构的统一操作接口。
##	set  map数据结构
-	Set 结构的实例有以下属性。
	Set.prototype.constructor ：构造函数，默认就是 Set 函数。
	Set.prototype.size ：返回 Set 实例的成员总数。
-	Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。
	Set.prototype.add(value) ：添加某个值，返回 Set 结构本身。
	Set.prototype.delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。
	Set.prototype.has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。
	Set.prototype.clear() ：清除所有成员，没有返回值。
-	Set 本身是一个构造函数，用来生成 Set 数据结构。
	-	const s = new Set();
		[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
-	typeof set -->object
-	Array.from 方法可以将 Set 结构转为数组。
-	数组去重
	-	Array.from(new Set(array))
	-	[...new Set(array)]
-	Set 结构的实例有四个遍历方法，可以用于遍历成员。
	Set.prototype.keys() ：返回键名的遍历器
	Set.prototype.values() ：返回键值的遍历器
	Set.prototype.entries() ：返回键值对的遍历器
	Set.prototype.forEach() ：使用回调函数遍历每个成员
-	Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和 values方法的行为完全一致。
-	map 和 filter 方法也可以间接用于 Set 了。
	-	let set = new Set([1, 2, 3]);
		set = new Set([...set].map(x => x * 2));
		// 返回Set结构：{2, 4, 6}
	-	let set = new Set([1, 2, 3, 4, 5]);
		set = new Set([...set].filter(x => (x % 2) == 0));
		// 返回Set结构：{2, 4}
-	// 交集
	let intersect = new Set([...a].filter(x => b.has(x)));
	// set {2, 3}
	filter函数体就是要满足的内容
##	WeakSet结构与Set类似，也是不重复的值的集合。但是，它与 Set 有两个区别。
-	首先，WeakSet 的成员只能是**对象**，而不能是其他类型的值
-	WeakSet 中的对象都是**弱引用**，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不
	再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
-	const a = [[1, 2], [3, 4]];
	const ws = new WeakSet(a);
	// WeakSet {[1, 2], [3, 4]}
-	a 是一个数组，它有两个成员，也都是数组。将 a 作为 WeakSet 构造函数的参数， a 的成员会自动成为 WeakSet 
	的成员。
	a 数组的成员成为 WeakSet 的成员，而不是 a 数组本身。这意味着，数组的成员只能是对象。
-	const b = [3, 4];
	const ws = new WeakSet(b);
	// Uncaught TypeError: Invalid value used in weak set(…)
-	WeakSet 结构有以下三个方法。
	WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
	WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
	WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
-	WeakSet 没有 size 属性，没有办法遍历它的成员。
-	WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成
	员就取不到了。
-	WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
-	**对象只接受字符串作为键名**
-	ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串
	-	Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现
	-	“键值对”的数据结构，Map 比 Object 更合适。
-	const m = new Map();
	m.set(o, 'content')
-	Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。
-	const map = new Map([
	['name', '张三'],
	['title', 'Author']
	]);
-	items.forEach(
	([key, value]) => map.set(key, value)
	);
-	map.set(['a'], 555);
	map.get(['a']) // undefined
-	上面代码的 set 和 get 方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因
	此 get 方法无法读取该键，返回 undefined 。
-	如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键
-	size 属性
	size 属性返回 Map 结构的成员总数。
-	set 方法设置键名 key 对应的键值为 value ，然后返回整个 Map 结构。
-	set 方法返回的是当前的 Map 对象，因此可以采用链式写法。
-	let map = new Map()
	.set(1, 'a')
	.set(2, 'b')
	.set(3, 'c');
-	Map.prototype.get(key)
	get 方法读取 key 对应的键值，如果找不到 key ，返回 undefined 。
-	Map.prototype.has(key)
	has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
-	Map.prototype.delete(key)
	delete 方法删除某个键，返回 true 。如果删除失败，返回 false 。
-	Map.prototype.clear()
	clear 方法清除所有成员，没有返回值。
-	Map的**遍历顺序就是插入顺序。**
-	Map 结构转为数组结构，比较快速的方法是使用扩展运算符（ ... ）。
	-	[...map.keys()]
		// [1, 2, 3]
	-	[...map.values()]
		// ['one', 'two', 'three']
-	结合数组的 map 方法、 filter 方法，可以实现 Map 的遍历和过滤（Map 本身没有 map 和 filter 方法）。
-	const map1 = new Map(
	[...map0].filter(([k, v]) => k < 3)
	);
-	Map 还有一个 forEach 方法，与数组的 forEach 方法类似，也可以实现遍历。
	-	forEach 方法还可以接受第二个参数，用来绑定 this 。
	-	const reporter = {
		report: function(key, value) {
			console.log("Key: %s, Value: %s", key, value);
		}
		};
		map.forEach(function(value, key, map) {
		this.report(key, value);
		}, reporter);
-	WeakMap 与 Map 的区别有两点。
	首先， WeakMap **只接受对象作为键名**（ null 除外），不接受其他类型的值作为键名。
-	WeakMap 的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。
-	WeakMap 结构有助于防止内存泄漏。
-	const e1 = document.getElementById('foo');
	const e2 = document.getElementById('bar');
	const arr = [
	[e1, 'foo 元素'],
	[e2, 'bar 元素'],
	];
	-	e1 和 e2 是两个对象，我们通过 arr 数组对这两个对象添加一些文字说明。这就形成了 arr 对 e1 和 e2 的
		引用。一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放 e1 和 e2 占用的内存
	-	arr [0] = null;
		arr [1] = null;
	-	一旦忘了写，就会造成内存泄露
-	如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 
	元素上添加数据，就可以使用 WeakMap 结构。当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。
-	WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。
-	const wm = new WeakMap();
	let key = {};
	let obj = {foo: 1};
	wm.set(key, obj);
	obj = null;
	wm.get(key)
	// Object {foo: 1}
-	键值 obj 是正常引用。所以，即使在 WeakMap 外部消除了 obj 的引用，WeakMap 内部的引用依然存在。
-	WeakMap 与 Map 在 API 上的区别主要是两个
	-	一是没有遍历操作（即没有 keys() 、 values() 和 entries() 方法），也没有 size属性
	-	二是无法清空，即不支持 clear 方法。因此， WeakMap 只有四个方法可用： get() 、 set() 、 has() 、 
		delete() 
-	WeakMap 的用途	
	-	WeakMap应用的典型场合就是DOM 节点作为键名
-	Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Map、
	Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。
-	可以使用core-js和regenerator-runtime(后者提供generator函数的转码)，为当前环境提供一个垫片。
##	proxy
-	Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即
	对编程语言进行编程。
-	Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，
-	因此提供了一种机制，可以对外界的访问进行过滤和改写。
-	var obj = new Proxy({}, {
	get: function (target, propKey, receiver) {
		console.log(`getting ${propKey}!`);
		return Reflect.get(target, propKey, receiver);
	},
	set: function (target, propKey, value, receiver) {
		console.log(`setting ${propKey}!`);
		return Reflect.set(target, propKey, value, receiver);
	}
	});
	-	上面代码对一个空对象架设了一层拦截，重定义了属性的读取（ get ）和设置（ set ）行为
-	对象有属性就先get 否则先set
##	reflect
-	 Reflect 对象的设计目的有这样几个。
	-	将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty ），放到 Reflect 对象上。
		现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。也就是说，**从 Reflect 对象上可以拿到语言内部的方法。**
	-	让 Object 操作都变成函数行为。某些 Object 操作是命令式，比如 name in obj 和 delete obj[name] ，
		而 Reflect.has(obj, name) 和 Reflect.deleteProperty(obj, name) 让它们变成了函数行为。
	-	不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。
-	Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1
-	Reflect.apply(Math.floor, undefined, [1.75]) // 1
-	Math.floor.apply(undefined, [1.75]) // 1
-	Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
-	const set = new Set([1, 2, 3, 4, 4]);
	[...set]
	// [1, 2, 3, 4]
-	去除数组重复成员的方法。
	-	[...new Set(array)]
-	去除字符串里面的重复字符。
	-	[...new Set('ababbc')].join('')
		// "abc"
-	Set加入值的时候，不会发生类型转换，所以 5 和 "5" 是两个不同的值
-	在 Set 内部，两个 NaN 是相等的。
##	Reflect对象一共有13个静态方法。
-	Reflect.get方法查找并返回 target 对象的 name 属性，如果没有该属性，则返回 undefined
	Reflect.get(target, name, receiver)
	如果 name 属性部署了读取函数（getter），则读取函数的 this 绑定 receiver 。
	 get baz() {
		return this.foo + this.bar;
		},

##	thunk
-	函数的参数到底应该何时求值。
-	一种意见是"传值调用"（call by value），即在进入函数体之前，就计算 x + 5 的值（等于6），再将这个值传入函
	数 f 。C语言就采用这种策略。
-	另一种意见是"传名调用"（call by name），即直接将表达式 x + 5 传入函数体，只在用到它的时候求值。Hskell
	语言采用这种策略。
-	编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 
	Thunk 函数。
-	函数 f 的参数 x + 5 被一个函数替换了。凡是用到原参数的地方，对 Thunk 函数求值即可。
-	这就是 Thunk 函数的定义，它是"传名调用"的一种实现策略，用来替换某个表达式。
-	在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是**多参数函数，将其替换成单参数的版本**，且只接受
	回调
	函数作为参数。
-	任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。
-	var thunk = function(fn){return function(){
	var args = Array.prototype.slice.call(arguments)
	return function(callback){
		args.push(callback)
		return fn.apply(this.args)
	}
	}}



##	es6解构赋值
-	按照一定的模式对数组和对象提取值
	let [a,b,c] = [1,2,3] 
	变量的赋值更加简单清晰明了
	let [x,y,...z] = ['a']
	x-->a   y-->undefined   z-->[]
	let [x, y] = [1, 2, 3];
	不完全解构是可以成功的
	这种类似于模式匹配 要求就是等号两边的模式是要相同的
	若是左边是数组  但是右边不是数组就会报错
	let [a] = 1;-->报错
	模式不匹配的时候就会报错
	解构赋值允许使用默认值
	let [x,y = 'b'] = ['a']
	默认值生效的前提是右边的数据成员严格等于undefined	否则默认值是不会生效的 
	默认值可以引用解构赋值的其他变量 但是变量必须已经声明
	let [x = 1,y = x] = [2]
	解构赋值不仅可以用于数组还可以用于对象
	let {foo,bar} = {foo:'aaa',bar:'bbb'}
	对于数组的解构赋值顺序是有一定次序的  但是对象的解构赋值可以随意决定
	let {foo:baz} = {foo:'aaa'}
	**foo就相当于模式   baz就是变量**
	这种解构赋值的解释就是baz是foo   而foo对应的是aaa   那么baz就是aaa
	先找到同名属性 **再赋值给对应的变量 真正被赋值的是后者**
	**解构赋值可以直接得到模式	使用的时候直接使用模式	不需要调用对象来使用**
	let {p,p:[x]} = obj		得到obj中p的模式直接使用		p.param
	let { loc: { start: { line }} } = node;
	**loc	start是模式**
	**对象的解构赋值可以取到继承的属性。**
	对象数组都可以用于**嵌套解构**
	let x;{x} = {x:1}--》报错因为x已经声明	js**会把{x}理解为一个代码块**  从而发生语法错误
	({x} = {x:1})-->这样就不会报错		圆括号的使用
	数组本质是特殊的对象
	var arr = [1,2,3]
	var {0:first,[arr.length-1]:last}=arr
	字符串的解构赋值
	let [a,b] = 'ok'
	**let {length:len} = 'ok'-->len为2**
	**解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。**
	函数参数解构赋值
	foo([1,2])
	只要有可能就不要在模式中放置圆括号混淆解析
	-	声明语句不可使用圆括号	let [(a)] = [1];let {x:(a)} = {}
	-	函数参数也属于变量声明  因此也不可以带有圆括号 fn([(z)])
	-	赋值语句使用圆括号可能会报错 ({p:a}) = {p:32}		**这里圆括号是属于模式的一部分**
		**可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。**
	-	({p:(d)} = {})
	-	解构赋值还可以交换变量的值		[x,y] = [y,x]
	-	解构赋值对提取JSON对象中的数据十分有用
	-	for(let [key,value] of map){
		}
		for(let [key] of map){}
		for(let [,value] of map){}
-	const {log}  = console		log获取到了console.log方法		之后可以直接使用log来代替console.log

##	es6字符串新增的方法
-	fromCharCode()		用于从unicode返回对应的字符	 但是不可识别码点大于0xFFFF的字符
	String.fromCharCode(0x20BB7)
-	fromCodePoint()弥补了它的缺点  可以识别大于0x20BB7的码点
	String.fromCodePoint(0x78,0x1f680,0x79)  方法中有多个参数会合并为一个字符串返回
-	表示法**只限于码点在 \u0000 ~ \uFFFF 之间的字符**
	-	ES6 对这一点做出了改进，只要**将码点放入大括号**，就能正确解读该字符。
	-	\u{20BB7}
-	UTF-8 标准规定， **0xD800 到 0xDFFF 之间的码点，不能单独使用**，必须配对使用
-	**模板字符串（template string）是增强版的字符串，用反引号 ' ' 标识**。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
-	模板字符串中嵌入变量，需要将**变量名写在 ${} 之中。**
-	模板字符串之中还能**调用函数。**
	-	foo ${fn()} bar   
		// foo Hello World bar

	
##	rmfnginx
-	nginx的功能
	-	托管静态资源文件服务器
	-	api接口服务--》权限控制缓存--》与数据库交流
	-	反向代理服务--》负载均衡
-	nginx优势
	-	高并发高性能
	-	可扩展性好
	-	热部署		--》不停机部署--》不用删除程序 下载程序更新
	-	开源许可证
	-	高可靠性
-	轻量		源代码只包含核心模块	其他非核心功能通过模块实现 自由选择
-	nginx是多进程(单线程)和**多路IO复用模型**		用的是**异步阻塞**
-	一个master进程		多个相互独立的woker进程
-	接收来自外界的信号		向各woker进程发送信号
-	master进程可以监控worker进程的运行状态	当worker进程退出	会自动启动新的worker进程
-	worker的进程数一般设置成cpu核数 因为更多的worker数	只会导致进程的相互竞争cpu	带来不必要的上下文切换
-	使用多进程模式	提高并发率	而且进程之间相互独立	一个worker进程不会影响其他的worker进程
-	IO多路复用
-	用户空间  内核空间
-	内存分开的原因是为了安全	
-	内核空间存在机密数据	
-	进程的上下文切换
-	同步异步(阻塞和非阻塞)	同步阻塞	同步非阻塞	异步阻塞	异步非阻塞
-	轮询
-	异步阻塞--》
-	**IO多路复用**--》多个顾客--》**一个服务员(单线程)**--》多个厨师
	-	多个文件描述符的IO操作都在一个线程里并发交替顺序完成	复用线程
	-	多线程会带来上下文的切换		性能的消耗
-	**CPU的亲和**
	-	一个核上运行一个进程	可以复用缓存	核上有一级缓存	二级缓存
	-	减少CPU的切换并且提高缓存的命中率	提高性能
-	sendfile		**零拷贝传输模式**
	-	读文件发为了两个环节	就是因为内存的分配是分为了内核存储(存储核心数据)
	-	一个就是用户存储	那么读取文件的时候就有了数据准备的步骤	然后再是数据的读取
	-	用户读取文件--》发给用户空间--》用户空间发给内核--》内核读取文件之后就把文件放到自己的缓冲区
	-	自己的缓冲区的文件发给用户空间--》完成文件的读取的操作--》是需要不停拷贝数据的
	-	但是0拷贝模式就不需要不停拷贝文件数据--》内核空间读取文件之后直接把文件扔给了用户空间程序
-	**动静分离**(静态文件		动态内容需要应用程序处理)
-	比如jsp直接交给**Tomact**或者其他Web服务器来处理--》因为nginx并不是servlet容器--》没有办法处理jsp
-	但是js html css直接交给nginx进行缓存处理就行
-	动静分离就是利用不同服务器各自的优势来处理不同文件类型		达到高性能访问的需求
-	实现动静分离就对文件的后缀名进行正则匹配	各自正则匹配的结果就对应各自的目标连接
-	location ~ \.(html|js|css)${root D:/static}-->放在上面	其余的数据文件交给Tomact来处理
-	location	/{	proxy_pass http://}		其余的数据文件有请求	jsp文件等
-	这是实现动静分离的最终文件形式
-	**集群**
	-	同一个业务	部署在多个服务器上面	
	-	upstream tomcatCluster{
		server 127.0.0.1:8000;
		server 127.0.0.1:8001;
		server 127.0.0.1:8002;
		}-->这是一个服务器集群		开启了多个服务器
	-	nginx用来作为代理转发	反向代理	用户只需要记住一个网页地址就行了
	-	location /{proxy_pass http://tomcatCluster}
	
-	**负载均衡**
	-	服务器有着请求的 转发规则在里面
	-	将服务器接收的的请求按照规则分发的过程	就是负载均衡
	-	轮询
		-	轮询是默认的分发规则	每个请求按时间顺序逐一分配到不同的后端服务器 如果服务器down掉 直接剔除
	-	指定轮询几率
		-	weight和访问比率成正比	用于后端服务器性能分配不均的情况下	不分配weight的时候	weight都是1
		-	性能好	那么weight就设置高一点	性能低	那么weight设置低一点
	-	ip_hash
		-	每个请求按访问的ip的hash值分配	**同一个客户连续的请求会被分配到同一服务器进行处理**	
			服务器down	会自动跳转到其他服务器
		-	用户的请求会发送到距离用户最近的服务器进行处理请求
	-	url_hash
		-	nginx本身是不支持url_hash	需要打补丁
		-	nginx按照访问的hash结果	来分配请求 使每个url定向到同一个后端服务器
		-	缺点就是服务器down的时候 不会自动跳转到其他服务器	而是直接返回503错误
	
-	**集群分布式环境下session的解决策略**
	-	分布式--》一个业务拆分为多个子业务--》部署在不同的服务器
	-	集群--》同一个业务分配在多个服务器
	-	为什么要处理session
	-	请求转发到不同的服务器	如果不处理session	**用户就需要重复登录** 用户无法忍受
	-	处理session是必要的
-	**session的处理方式**
	-	session保持--》用户锁定到某一台服务器--》用户一直在一台服务器--》session一直存在
		-	那么就会存在负载均衡的问题--》服务器down--》用户得不到服务
	-	session复制--》每一个服务器里面复制一份用户的session-->任何一台服务器上面的session发生改变的时候
		该节点会把session的所有内容序列化--》然后广播给所有其他节点--》不管其他服务器需不需session，以此
		来保证session同步
		-	优点是可以容错	各个服务器之间的session是可以实时响应的
		-	缺点是将session广播同步给成员	会对服务器造成一定的压力
		-	tomcat本身是支持这功能
			-	tomcat会话复制分为全局复制	非全局复制
			-	非全局复制是将session复制给一个指定的服务器备份节点--》其他需要的时候直接去备份服务器获取
				session
	-	session共享--》和非全局复制相似--》将session放在**resdis cluster**里面--》解决session的共享问题
		spring-session和redis来实现session的共享问题
-	nginx-->cmd来操作
-	nginx.exe -s stop快速关闭nginx	可能不保存相关信息	并迅速终止web服务
-	nginx.exe -s quit平稳关闭nginx	保存相关信息	有安排结束web服务
-	start nginx.exe启动nginx
-	nginx.exe -s reload改变了nginx相关配置	需要重新加载
-	window下面使用nginx才会用到.exe
-	nginx.conf文件的分析
	-	**event块**来设置影响nginx和用户的网络连接	有每个进程的**最大连接数**
	-	events {
			worker_connections  1024;
		}
	-	max_clients-->最大客户端连接数
	-	nginx作为http服务器的时候
		-	max_clients = worker_processes * worker_connections
	-	nginx作为反向代理服务器的时候
		-	max_clients = worker_processes * worker_connections/4
		-	除以4是因为有两个请求和响应	反向代理会转发请求
-	**http块配置**
-	可以嵌套多个server 配置代理缓存日志定义和第三方模块的定义，是否使用sendfile传输文件	连接超时时间
	单连接请求数
-	include       mime.types;
	-	用来配置nginx支持文件的扩展名和文件类型的映射表
-	access_log  logs/access.log  main;
	-	打印日志文件的类型	格式
-	sendfile on
	-	允许sendfile方式传输文件	开启高效传输模式
-	keepalive_timeout长连接超时时间
	-	单位是秒		用户发请求长时间没有反应
	-	keepalive_timeout  65;长连接保持的时间	用户长时间不使用会关闭连接
-	**开启gzip压缩**
-	gzip  on;
-	**nginx服务器访问静态资源文件**
-	在nginx目录下面新建一个static文件夹来放置可能需要访问的文件
-	 location / {
            root   D:/nginx/nginx-1.20.1/static/rmfwenjian;#是静态资源文件的路径
            index  index.html index.htm;
        }
-	项目中的静态资源文件最好都交给nginx部署
-	nginx和tomcat配合使用实现了资源的动静结合
-	nginx配置静态资源文件路径的时候忘记配置相应的index.html文件导报错
-	  location / {
            root   D:/nginx/nginx-1.20.1/nginx-1.20.1/static/rmfwenjian;
            index  index.html index.htm; 
        } 
	-	应该在相应的D盘文件夹下面放置index.html文件
-	我使用正则来实现动静分离		截取文件后缀实现


-	nginx是属于中间件的
-	master和worker的通信
-	
-	apache
	-	
-	事件模型
	-	select	轮询事件完成没有	单个进程最多打开1024个连接		对文件进行线性遍历
		-	后端特别快的时候用select		那么就没有了回调的开销
	-	poll	链表存储事件		没有最大连接的限制	其余的和select是一致的
	-	epoll	每个文件描述符上设置callback来实现	
		-	后端特别慢	就不能一直轮询询问	那么就用回调	回调成本是值得的
	-	本质上都是同步IO	
-	异步非阻塞--》
-	进程间切换--》切换的进程会保存进程状态来完成进程切换--》消耗资源性能
-	IO模式
	-	对于一次IO访问	数据会先被拷贝到操作系统内核的缓冲区	然后才会从操作系统的内核的缓冲区拷贝到
		程序的缓冲区	
-	进程上的多个线程		线程可以在进程里面随便创建的 进程中的线程之间可以相互通信
-	反向代理就是用户的请求--》服务器会自动转发请求到目标服务器来获取响应返回数据
-	使用xshell连接远程服务器ip101.35.143.191-->下载nginx web服务器完成网站的请求的响应--》远程服务器
	centOs--》下载宝塔--》建立网站站点--》在/usr/share/nginx/html里面替换自己想要的页面效果
-	centos
-	是免费的 开源的 可以重新分发的开源操作系统--》是linux发行版之一--》也叫做社区企业操作系统--》源于
	红帽企业规定释出的源代码编译而成
-	nginx访问静态资源文件
-	location /userinfo {
            alias   /www/wwwroot/101.35.143.191/other;
            index  index.html;
        }
    
-	
##	rmf数据库
-	增加
-	insert into user (name,password) values ('rmfrmf','123456')
-	查询
-	select * from user		-->获取所有数据
-	select name from user		-->有选择的查询所需要的数据
-	条件查询
-	使用where来定位查询
-	select * from user where name = 'rmfrmf'
-	select * from user where name = 'rmfrmf' and password = '123456'
-	select * from user where name = 'rmfrmf' or password = '123456'
-	模糊查询		
-	不适应赋值号 	用的只是like进行模糊查询
-	select * from user where name like '%rm%'
-	order排序默认用的是正序查询
-	select * from user where name like '%rm%' order by id
-	desc是说明用的倒叙查询
-	select * from user where name like '%rm%' order by id desc
-	request.query		-->是get请求 express获取数据参数的方法
-	request.body		-->是post请求 express获取数据参数的方法
-	
##	rmfwebpack
-	webpack的基础模块
-	entry output mode loader plugin
-	mode默认打包模式是生产环境打包 代码会被压缩为一行
-	开发环境和生产环境打包是不同的
-	开发环境和生产环境的配置文件可以分为两份	这样打包的时候就不用去配置文件里面改动mode
-	直接运行相应的打包配置文件  
-	webpack.base.config.js		开发环境和生产环境都会用到的webpack的配置文件
-	webpack.dev.config.js		打包开发环境下的文件
-	webpack.prod.config.js		打包生产环境下的文件
-	开发环境和生产环境要合并公共的配置文件		
-	const commonConfig = require('./webpack.base.config')
	const {smart:merge} = require('webpack-merge')-->引入了webpack的内置的模块文件
	并将模块文件更改名字  
	const prodConfig = {mode:'production'}
	module.exports = merge{commonConfig,prodConfig}
	这样就完成了webpack的拆分配置和合并配置的操作
-	如何使用webpack-dev-server
	-	webpack-dev-server的作用就是开发环境的配置  不是生产环境的配置 所有要配置到开发环境当中
	-	webpack.dev.config.js
	-	const devConfig = {
		mode:'development',
		devServer:{
			port:8080,
			contentBase:'./dist',//服务器静态资源文件夹
			progress:true,//打包的时候显示进度条
			open:true,//启动服务器之后自动打开浏览器
			compress:true//开启gzip压缩
		}
	}
		module.exports = merge(commonConfig,devConfig)
	-	package.json里面修改命令
		"dev":"webpack-dev-server --config ./build/webpack.dev.config.js"
	-	这样开发的时候改动文件的时候浏览器会自动显示改动文件之后的相应的版本的显示
	-	
-	记得改变一下package.json里面的script里面的配置命令		来配置开发和生产环境相应的打包的命令
-	"build:dev":"webpack --config ./build/webpack.dev.config.js"
-	"build":"webpack --config ./build/webpack.prod.config.js"

-	loader
	-	处理非js文件 可将所有类型文件转换为webpack可以处理的模块
	-	module:{rules:[{test:/\.txt/,use:'raw-loader'}]}
	-	use:-->使用的loader是哪个
	-	test:-->loader针对使用的类型文件是哪些文件类型	标识loader处理的文件的类型
	-	用于对模块源代码进行转换
	-	npm i css-loader ts-loader
	-	module.exports={module:{rules:[{test:/\.css$/,use:'css-loader'}]}}	以css结尾的文件
	-	使用loader的三种方式
		-	配置		-->webpack.config.js文件中指定loader
			-	module.rules来指定多个loader	是一种简明的方式	有助于代码变得更见简洁
		-	内联		-->在每个import语句中显式指定loader
			-	import	来指定引入使用的loader
			-	import styles from 'style-loader!css-loader?module!./styles.css'
			-	!可以将资源中的loader分隔开来
			-	选项中可以传递查询的参数	例如?ket=value&foo=bar或者一个JSON对象
			-	尽可能使用module.rules的方式来指定loader	减少了源码中的代码量	代码维护的时候
				更加简单   方便维护和开发
		-	cli			-->在shell命令中指定loader
			-	cli使用loader
			-	webpack --module-bind jade-loader --module-bind 'css=css-loader!style-loader'
			-	.jade文件来使用jade-loader   css文件来使用css-loader 和 style-loader
			-	webpack		这个第一个需要使用的文件的指令绑定也是需要书写的 
			-	css=这个类似于赋值的操作要记得		
			- 	module-bind来进行绑定要使用的loader
	-	loader的特性
		-	支持链式传递	一组链式的loader将按照相反的顺序去执行	loader链中的第一个loader的返回值给下一个
			loader 		在最后一个loader  返回webpack所预期的js文件内容
		-	loader可以是同步的		也可以是异步的
		-	loader运行在node.js中	并且可以执行任何可能的操作
		-	plugin可以为loader带来更多的特性
		-	loader压缩  打包  语言翻译和其他更多
	-	允许 webpack来打包除了js之外的任何静态资源
	-	raw-loader 加载文件的原始内容
	-	val-loader 将代码作为模块执行  并将exports转为js代码
	-	file-loader 将文件发送到输出文件夹	并返回相对URL
-	plugin
	-	打包优化和压缩	重新定义环境中的变量
	-	插件的使用步骤
		-	require引入想要使用的插件	--》const HtmlWebpackPlugin = require('html-webpack-plugin')
		-	html-webpack-plugin插件是用来进行html文件的打包优化的插件
		-	可以在一个配置文件里面因为不同目的而多次使用同一个插件
		-	new HtmlWebpackPlugin(template:'./src/index.html')--> new 运算符来创建实例作用与不同的文件
		-	插件是webpack的支柱功能
		-	webpack的插件是一个具有apply属性的js对象 apply属性会被webpack compiler调用
			并且compiler对象会在整个编译周期中访问
		-	consolePlugin.js定义插件的方法
		-	const pluginName = 'consolePlugin'
			class consolePlugin{apply(compiler){compiler.hooks.run.tap(pluginName,compilation=>{
				console.log('plugin work')
			})}}
		-	plugin是一个class 里面compiler调用了apply属性	compiler.hooks.run.xx-->编译器执行的函数
		-	tap函数的第一个参数是插件的名称
	-	使用webpack内部的插件
		-	const webpack = require('webpack')
		-	plugins:[new webpack.optimize.UglifyJsPlugin()]
	-	使用打包优化所需要的插件
		-	plugins:[new HtmlWebpackPlugin({template:'./src/index.html'})]
-	webpack配置是标准的node.js CommonJS模块
	-	require()导入其他文件  使用npm的工具函数
	-	对常用值使用常量或者变量
	-	使用webpack的时候尽量避免编写很长的配置  应该拆分为多个文件
-	webpack除了导出单个配置对象 还有一些其他方式
	-	在生产和开发之间消除webpack.config.js的差异  有两种选项
	-	可选的导出的方式
		-	作为导出一个配置对象
		-	module.exports=function(env,argv){return{}}
		-	webpack将运行由文件导出的函数 并且等待Promise返回 便于异步加载所需要的变量
		-	module.exports=()=>{return new Promise(()=>{})}
		-	导出多个配置对象
		-	module.exports=[{output:{filename:'',libraryTarget:''},entry:'...',},{}]
-	模块热更新
	-	HMR 全称为 Hot Module Replacement ，中文意思为模块热更新，是 webpack 提供的最有用的功能之一。**它允许在运行时替换，添加，删除各种模块**，而**无需进行完全刷新重新加载整个页面**
	-	在vue-cli工程中，**webpack默认是自动启动热更新。**
	

##	table表格来显示
-	tr显示行  	td显示列	border来显示表格的边框		设置border的数值来设置表格边框的大小
##	html语义化的好处
-	在没有css的情况下 页面也可很好显示内容结构 有着清晰的代码结构
-	有利于用户的体验	例如title alt来解释名词或者解释图片信息 
-	有利于SEO 和搜索引擎建立良好的沟通
-	方便其他设备解析  用有意义的方式来来渲染网页
-	利于团队开发  代码更加具有可读性	减少差异化
-	语义元素不会在视觉上有改变 只是提供了 HTML 结构 供计算机和开发者阅读
-	书写html代码的时候的注意事项
	-	尽可能减少没有语义的div  span
	-	在语义不明显的时候  既可以用div 也可以用p 尽量使用p 因为p标签在默认情况下是有上下边距
		对兼容特殊终端是有利的
	-	strong标签  em斜体
	-	每个input标签对应的说明文本都要使用lavbel标签  并且通过input的id属性 在label标签的for属性设置
		一样的属性值 达到相互关联的目的
	-	<label for='inputName'><input id='inputName'></input></label>
##	rmfhtml
-	<abbr> 标签指示简称或缩写，比如 "WWW" 或 "NATO"。 
	The <abbr title="People's Republic of China">PRC</abbr> was founded in 1949.
-	<address> 标签定义文档或文章的作者/拥有者的联系信息。
	<address> 元素中的文本通常呈现为斜体。大多数浏览器会在 address 元素前后添加折行。
	如果 <address> 元素位于 <body> 元素内，则它表示文档联系信息。
	如果 <address> 元素位于 <article> 元素内，则它表示文章的联系信息。
	<address>
	<a href='mailto:3434343@qq.con'>联系我们</a>
	</address>
-	<area> 标签	带有可点击区域的图像映射
	area 元素总是嵌套在 <map> 标签中。
	<img src="planets.jpg" border="0" usemap="#planetmap" alt="Planets" />
	<map name="planetmap" id="planetmap">
	<area shape="circle" coords="180,139,14" href ="venus.html" alt="Venus" />
	<area shape="circle" coords="129,161,10" href ="mercur.html" alt="Mercury" />
	<area shape="rect" coords="0,0,110,260" href ="sun.html" alt="Sun" />
	</map>
-	<article> 标签规定独立的自包含内容。<aside> 标签定义其所处内容之外的内容。
-	<audio> 标签定义声音，比如音乐或其他音频流。
-	<audio src="someaudio.wav">
	您的浏览器不支持 audio 标签。
	</audio>
-	字体样式的元素 <tt><i><big><small><b>
-	<base>标签为页面上所有的连接规定默认地址或者默认目标
	<base href="http://www.w3school.com.cn/i/" />
	<img src="eg_smile.gif" />
-	<bdi> 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。起到一个空白格分隔的作用
-	bdo 元素可覆盖默认的文本方向。
	-	ltr   rtl
-	<blockquote> 标签定义块引用。
	<blockquote> 与 </blockquote> 之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进（增加外边距），而且有时会使用斜体。也就是说，块引用拥有它们自己的空间。
	cite	URL	规定引用的来源。
-	请使用 q 元素来标记短的引用。
-	<samp>定义样本文本		
-	<code>定义计算机代码
-	<em>		<strong>强调内容的标签
-	<cite>定义引用
-	<caption> 元素定义表格标题。
-	<col> 标签为表格中一个或多个列定义属性值。您只能在 table 或 colgroup 元素中使用 <col> 标签。
	<col align='left'/>		html中col没有结束标签
	align   -->		left right center justify char
	width  		-->		20px定义列的宽度
-	<colgroup> 标签用于对表格中的列进行组合，以便对其进行格式化。<clogroup>只可在table标签中使用
-	<data> 标签用于添加给定内容的机器可读翻译。
	<data value='2'>nihao</data>	nihao和2这个编号相互关联
-	<dd>定义列表中定义条目的定义部分
	<dl><dt>计算机</dt><dd>用来计算的仪器...</dd></dl>
-	<del>定义文档中已经被删除的文本		文本会有被划掉的痕迹		l尽量使用del标签 而不是strike标签
-	<dl>定义了列表  <dt>定义了列表中的项目  <dd>描述列表中的项目
-	<kbd>用来定义键盘键入的文字		文字略小
-	<embed>来定义嵌入的内容  比如插件
	<embed src='rmfPlugin.swf'>
-	<figure>规定的独立的流内容	内容应该和主内容相关 
	<figure><p>nihao</p></figure>独立的流内容有着特殊的格式
-	<figcaption>用来定义figure标签的标题
-	<frame>用来定义<frameset>里面的一个特定的窗口
	name用来定义框架的名称  noresize无法调整框架的大小		scrolling是否在框架中显示滚动条
-	<frameset>元素定义一个框架集  用来组合多个窗口  每个框架有独立的文档 
	cols="20%,20%,100%"   rows='20%,20%,100%'
-	<ins>标签定义已被插入的文本
-	<keygen> 标签规定用于表单的密钥对生成器字段。
	<keygen name='rmfkey'>
-	input框中的name表示一类的意思
-	label的for  input的id
-	img的usemap='#mapid'   map的id='mapid'  
	<map><area /></map>  map标签里面带有可以点击的区域的图像的映射
-	<menu>标签定义列表或者菜单  用于上下文菜单  工具栏 以及列出表单控件和命令
-	<menuitem>标签定义用户可以从弹出菜单调用的命令/菜单项目
-	<meta>标签提供页面的元信息		是放在head元素的内部的标签	元数据总是以名称/值的形式被成对传递的
	name  http-equiv来提供键值对中的键
	content来提供键值对中的值
	带有http-equiv属性的meta标签  服务器向浏览器发送文档的时候 会发送许多键值对
	所有服务器都会发送content-type:text/html  告诉浏览器将要接收一个html文档
	服务器将发送给浏览器的内容头部 
	<meta http-equiv='charset' content='iso-8859-1'>
	<meta http-equiv='expires' content='81 Dec 2008'>
	http-equiv		-->可以设置的值		content-type  expires refresh set-cookie
	name  			-->author   description  keywords	generator	
	keywords为文档定义一组关键字	某些搜索引擎遇到这些关键字的时候 会对文档进行分类
	scheme=''-->定义用于翻译content属性值的格式
-	noframes为那些不支持frame的浏览器显示文本提示不可使用frame   noframes在frameset里面使用
-	<noscript>用来定义脚本未被执行时候的替代内容
-	<object>向html代码中添加一个对象	定义一个嵌入的对象	此元素允许你规定插入html文档中对象
	的数据和参数	以及可以用来显示和操作的代码
	<object id='object1'><param name='param1' value='1'/></object>
	对象里面有id   参数里面有参数名  参数值
-	<ol>列表是无序的
-	<optgroup>标签来定义选项组	例如中国菜  外国菜   这些大的菜名下面有着详细的菜品
	<optgroup label='Chinese Food'>   其中label标签是必须的  用来指定详细的说明
-	<select><option>选项一</option></select>
-	<output name='x'>
	form表单里面的输入数据   以及   输出结果数据的相互结合
	<form oninput='x.value=parseInt(a.value)+parseInt(b.value)'>
	<input type='range' id='a' value='30'>+
	<input type='number' id='b' value='39'>=
	<output name='x' for='a b'></output>
	</form>
	input id    output   name
	form表单当中定义数据的计算方式
-	<param>是<object>标签里面的参数标签
-	<picture>标签让web开发更加具有灵活性	常见于响应式设计开发中使用 设计多个图像来更好填充浏览器视口
	picture标签里面还含有source  	img标签
	<source media='(min-width:333px)' srcset='./img/xx.jpg'>
	<picture><source media='(min-width:222px)' srcset='./img/xx.jpg'></picture>
-	<source>为媒介元素定义媒介资源  允许你替换视频/音频文件进行选择
-	<pre>元素通常可以定义预格式化的文本  被包围在pre元素里面的文本通常会保留空格和换行符 但是文本也会显示
	等宽的字体		<pre>标签的常见的应用就是表示计算机源代码		pre元素允许文本包括物理样式
	链接   图像		水平分隔线都可以展示
	pre标签   code标签可以相互结合来使用来展现计算机源码
-	<q>标签来表示短的引用		并且会自动加上引号来表示是引用的字段		长引用是<blockquote>
-	<ruby>一个ruby解释		是中文注音或者字符
	<rp>定义不支持ruby元素的浏览器展示的内容
	<rt>定义字符的解释或者发音
-	<legend>为<fieldset>定义标题
-	<link>标签引入外部资源样式表
-	<main>标签规定文档的主要内容  不包含文档中重复出现的内容
-	<table>标签里面含有<thead>	<tbody>	<tfoot>	<tr>表格行	<th>表格头	<td>表格单元
-	<template>保留页面加载的时候隐藏的内容
	<template><p>hello</p></template>	-->这是隐藏的内容
	function showContent(){
		var temp = document.getElementsByTagName('template')
		var clon = temp.content.cloneNode(true)
		document.body.appendChild(clon)
	}
	这样就可以显示隐藏的内容
-	<textarea>来定义多行文本输入控件
-	<tt>用来展示打字机或者等宽的文本的显示  和<kbd>		<code>标签类似的效果
-	



##	rmfrestful
-	统一资源接口
-	restful遵循统一接口原则 统一接口包含了一组受限的预定义的操作 不管什么样的资源 都是通过使用相同的
	接口进行资源访问  接口应该使用标准的http方法 get post put 并遵循语法的规则
-	


##	rmfNode
-	使用sessionStorage来达到必须先登录才可访问内容的权限
	 sessionStorage.setItem('name',res.data.name)
	 在路由导航守卫的时候来设置判断sessionStorage存在与否  分配页面的访问权限

##	父组件接收slot的传递过来的参数
-	<template scope='val'></template>		-->val接收到的值为一个对象
	slot插槽在其他组件中使用的时候			slot组件的参数想要给其他组件的数据传参的时候会使用scope属性
	scope获取数据val是一个数据对象	是一个对象
	<li>val.msg</li>
-	slot-scope获取插槽组件中的数据			slot='slotName'		slot-scope='val'	val是一个对象



##	webApi

-	window.history.go()		window.history.back()		window.history.forward()

-	window.localStorage			window.sessionStorage

	-	getItem('item')		window.sessionStorage.setItem('item',value)

	-	window.localStorage.clear()

	-	window.localStorage.removeItem('item')

	-	window.localStorage.key(n)		返回存储的第n个键的名称

	-	

##	console	对象
-	console.clear()		清理控制台
-	console.info()		将信息性消息输出到控制台
-	console.table()		将显示的数据显示为表
-	


##	window表示浏览器打开的窗口
-	如果文档包括frame   iframe标签		那么浏览器会为了html文档创建一个window对象
	并且为每个框架创建一个额外的window对象
-	window.frames		返回窗口所有命名的框架
-	window.length		返回窗口中框架的数量
-	window.innerHeight		返回窗口文档显示区的高度
-	window.outerheight		返回窗口的外部高度


##	window对象的方法
-	window.alert('')
-	window.clearTimeout()
-	window.clearInterval()
-	window.close()	
-	window.confirm()		显示一个带有指定消息和ok以及取消按钮的对话框
	-	var r = confirm('press a button')
		if(r == true)document.write('ok')
-	window.focus()		可以把键盘的焦点给与一个新的窗口
-	window.moveBy()		可以相对于窗口的当前坐标把它移动指定的像素
-	window.print()		打印浏览器当前窗口的内容
-	window.prompt()		显示可提示用户输入的对话框
	-	var  name = window.prompt('enter your name')
-	window.setInterval()
-	window.setTimeout()
-	window.scrollTo(100,300)		把内容滚动到指定的位置
##	window		等同于自身		可以是self
##	style对象代表一个单独的样式声明		可以应用样式的文档或者元素访问Style对象
-	document.getElementById('btn').style.color = 'red'
	style.backgroundImage
	style.background
	style.border
##	window.screen		
-	Screen存放有关于显示浏览器屏幕的信息
-	程序的编写可以根据用户的	显示器的尺寸来选择使用大图像还是小图像		
-	还可以根据显示器的颜色深度选择16位色		还是8位色的图形


##	window.location
-	window.location.hash		返回从#开始的URL
-	window.location.host		设置或者返回主机名和当前的URL端口号
-	window.location.href		设置或者返回当前完整的URL
-	window.location.reload()	重新加载当前文档		
-	window.location.replace('http://www.w3school.com.cn')	用一个新的文档来取代当前文档
-	


##	HTMLCollection对象		是html元素类似数组的列表
-	诸如getElementByTagName()	之类的方法返回的HTMLCollection
-	



##	事件对象
-	onblur		用户焦点离开时候的触发的事件
	-	<input id='fname' type='text' onblur='myFn()'>
	-	myFn(){var x = document.getElementById('fname');x.value = x.value.toLocalUpperCase()}
-	onchange	元素值发生改变的时候会发生		
	-	<input onchange='myFn()'>
	-	输入框发生数据改变的时候会触发的事件
-	oncopy	
	-	<input oncopy='myFn()'>
	-	输入框的内容被复制的时候发生的事件
-	oncut
	-	<input oncut='myFn()'>
	-	用户尝试剪切内容的时候发生的事件
-	ondbclick='myFn()'
-	onfocus='myFn(e)'		
	输入字段获得焦点的时候执行
	e.style.background='yellow'
-	oninput='myFn()'
	用户输入的时候发生的事件
-	onhashchange='mgFn()'
	hash改变的时候发生的事件
-	onkeydown		用户正在按下键时候
-	onkeypress		用户按下键后
-	onkeyup			用户松开键的时候触发的事件
-	onload 
	<body onload='fn()'></body>
	页面加载之后执行的触发函数
-	onloadeddata		媒体数据加载之后		发生的事件
	<video onloadeddata='fn()'>
-	onmousedown		onmouseenter		onmouseleave		onmousemove
	onmouseout		onmouseover			onmouseup
-	onsearch='fn()'		提交搜索时候执行
	<input 	type='search' onsearch='fn()'>
-	onseeking='fn()'	当用户开始移动/跳到媒体中的新位置时，发生该事件。
	<video onseeking="myFunction()">
-	onseeked='fn()'		当用户完成移动/跳到媒体中的新位置时，发生该事件。
-	onselect='fn()'		用户选择文本后（对于<input>和<textarea>）发生此事件
	<input type="text" onselect="myFunction()">
-	onsubmit='fn()'		提交表单时执行 JavaScript：

##	属性
-	altKey		确定单击鼠标按钮时是否按下了 "ALT" 键：
	onmousedown="isKeyPressed(event)"
	 if (event.altKey) {
		alert("The ALT key was pressed!");
		} 
-	bubbles	事件属性	搞清楚特定事件是否能冒泡	返回的是boolean值类型
	e.bubbles
-	charCode		返回触发 onkeypress 事件的键的 Unicode 字符代码。
-	code		var x = event.code;			返回触发事件的键的代码。		enter space
-	输入英文字符		得到的结果是keyA		KeyB
-	输入普通普通数据		得到的结果是		Digit1		包括了键值的类型
-	但是使用e.key		就是直接返回的键值		不包括键值的类型
-	composePath()		返回事件的路径。			
	event.composedPath()
-	div-->body-->html-->DOM-->window
-	ctrlKey		确定单击鼠标按钮时是否按下了 "CTRL" 键		event.ctrlKey	返回boolean值
-	currentTarget		返回其事件侦听器触发事件的元素。
	e.currentTarget.nodename
-	data	event.data		返回插入的字符。
-	defaultPrevented		返回是否事件调用了		e.preventDefault()	返回的是boolean值
-	e.deltaX		返回鼠标滚轮水平滚动的距离		e.deltaY		返回鼠标滚轮垂直滚动的距离
-	e.detail		返回鼠标被点击的次数	
-	e.inputType()		返回更改的类型		inserText类型		deleteContentBackward类型
-	e.key		返回事件表示的键的键值		比如f1 enter ctrl alt 1 		输入a输出就是a	
-	e.keyCode		获取按下的键盘按键的 Unicode 值
-	e.location
	location 属性返回一个数字，指示键盘或设备上的按键的位置。

	该数字由 4 个常量表示：

	0. DOM_KEY_LOCATION_STANDARD：
	该键未在键盘的右侧或左侧按下，也未在数字小键盘上按下（该值代表键盘上几乎每个键，例如 "A"、"U"、"SPACE" 或 "5")

	1. DOM_KEY_LOCATION_LEFT：
	按下了左键（例如，标准 101 键美国键盘上的左 "CTRL" 键或左 "ALT" 键）

	2. DOM_KEY_LOCATION_RIGHT：
	按下了右键（例如，标准 101 键美国键盘上的右 "CTRL" 键或右 "ALT" 键）

	3. DOM_KEY_LOCATION_NUMPAD：
	在数字小键盘上按下该键（例如，标准键盘右侧的 "2" 键）
-	e.propertyName	获取与过渡关联的属性名称		width  height
-	e.relatedTarget		返回与触发鼠标事件的元素相关的元素。		onmouseover		e.relatedTarget.tagName
-	e.stopImmediatePropagation()		防止同一事件的其他监听器被调用
-	e.target	返回触发事件的元素
-	e.timeStamp		返回文档加载之后的毫秒数
-	e.type		返回触发事件的类型		onmousedown		onmouseup		onkeydown		onkeyup
-	e.which		返回触发鼠标事件的按下的鼠标按钮		onmousedown
-	e.which		返回键盘键按下的unicode码		onkeypress
##	drag  拖放事件
-	ondragstart		ondrag		ondragend
	ondragenter		被拖放的元素进入放置目标的时候发生
	ondragover		被拖放的元素放置在目标上的时候发生
##	vue.config.js
-	publicPath:process.env.NODE_ENV === 'production' ? '' : '/'
-	NODE_ENV：Node.js 暴露给执行脚本的系统环境变量。通常用于确定在开发环境还是生产环境
  
-	outputDir:'dist'		// 输出文件目录

-	assetsDir:'static'		// 放置静态资源

-	filenameHashing:true
	默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希。
-	pages
	在 multi-page（多页）模式下构建应用。每个“page”应该有一个对应的 JavaScript 入口文件
	其值应该是一个对象，对象的 key 是入口的名字，value 是：
	一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的)；
	或一个指定其 entry 的字符串。
	pages:{
		index:'src/index/main.js',
		subpage:'sub/subpage/main.js'
	}
-	lintOnSave
	是否在开发环境每次都会保存代码都启用eslint验证
-	runtimeCompiler
	是否使用包含运行时编译器的vue构建版本	设置为true之后vue组件中可以使用template选项了
-	productionSourceMap
	不需要生产环境的souce map	设置为false来加速生产环境的构建
-	integrity
	构建的的html中的<link rel='stylesheet'>和<script>标签上启用了Subsource	Integrity
	构建的文件是部署在CDN上	会提供额外的安全性
-	
##	compression-webpack-plugin
-	可以用于文件上线的打包压缩
##	服务器
-	服务器可以根据功能划分	web服务器		ftp服务器	数据库服务器	邮件服务器
-	根据地域划分	国内服务器	 香港服务器	美国服务器
-	服务器类似于加强版的家用电脑	是开展业务功能的不可或缺的设备
##	ip地址
-	ip地址是一台服务器必须的	只有输入正确的ip地址才能找到对应的服务器	ip就像一个人的家庭住址
-	但是如果地址搬迁之后	就正确找不到服务器	为了方便寻找就产生了域名
##	域名
-	如果一台服务器上只有一条ip	但是需要搭建几个网站	只可以通过不同的端口来实现	
-	多条域名可以同时解析一条ip	但是一条域名不可解析多条ip	
-	ipv4-->2**32		ipv6-->2**128

##	全局事件总线
-	组件之间的 通信方式		任何组件之间可以根据全局事件总线来达到通信的目的
-	main.js里面配置全局组件
	-	new Vue({
		beforeCreate(){
			Vue.prototype.$bus = this	//配置总线就是把vm挂载到Vue原型上面
			//使得所有组件对象都可以访问	进而调用$on $emit
		},
		el:'.root',
		render:h=>h(app)
	})
	this.$bus.$emit('addO',this.content)
	this.$bus.$on('addO',this.addO)
##	状态码
-	
##	window.requestAnimationFrame(animationName)
-	动画自动执行		animationName是一个回调函数作为参数
-	
##	事件绑定@   传入参数$event
-	不在vue框架中的时候		就是onEventName 		event
##	h5应用程序缓存
-	web应用进行缓存		在没有英特网连接的情况下进行访问
	-	离线浏览		用户在离线的情况下使用web应用
	-	速度		已经缓存的资源速度加载更快
	-	减少服务器负载		浏览器中从服务器下载更新过的或者更改过的资源
-	<html manifest='demo.appcache'>
	-	带有cache manifest的html文档		提供离线浏览
	-	html中携带manifest属性是应用程序缓存的前提条件
	-	用户对带有manifest页面的访问的时候	都会对这个页面进行缓存		扩展名最好是appcache
-	manifest文件需要配置正确的MIME-type类型
	-	text/cache-manifest		必须在web服务器上进行配置
-	manifest文件包含了三个部分
	-	CACHE MANIFEST		此标题下的文件在首次加载之后会被缓存
	-	NETWORK				文件需要连接互联网才能访问		并且文件不可被缓存
	-	FALLBACK			页面无法访问时候的回退页面
##	webworker
-	html页面中执行脚本的时候	页面的状态是不可响应的	直到脚本完成
-	web worker	是执行在后台的js		独立于其他脚本	不会影响页面的性能	
	用户可以继续做自己的事情	点击	选取内容..
	此时web worker在后台执行
-	检查浏览器支持web worker
	-	typeof(worker) !== 'undefined'
	-	w = new Worker('demo.js')
		w.onmessage=function(e){console.log(e.data)}
		//demo.js文件里面有着postMessage(i)
	-	终止worker		--> 		w.terminate()
-	web worker位于外部文件中		所以是无法访问下列js对象的(window   document  parent)
##	SSE服务器发送事件
	-	是基于webSocket协议的一种服务器向客户端发送事件和数据的单向通讯
	-	h5服务器发送事件允许网页获取来自服务器的更新
-	EventSource对象		是用于接收服务器发送事件通知
	-	var source = new EventSource('demo.php')
		source.onmessage = function(event){console.log(res.data)}
-	检测服务器发送事件浏览器的支持情况 
	-	typeof(EventSource)!=='undefined'
-	服务端的配置
	-	php
		-	header('Content-Type:text/event-stream')
	-	asp
		-	Response.ContentType('text/event-stream')
-	EventSource对象的api
	-	onmessage
	-	onopen
	-	onerror
##	websocket
-	单个tcp连接上的全双工通信协议
-	服务端主动向客户端推送数据
-	只需要一次握手	两者之间就可以创建持久性连接
-	更好节省带宽和服务器资源	更实时进行通信
-	获取web socket连接之后		可以通过send()方法来向服务器发送数据
-	并通过onmessage事件来接收服务器返回的数据
-	var souket = new WebSocket(url,[protocal])
-	socket对象的属性
	-	socket.readyState
		-	0 尚未建立
		-	1 连接建立	进行通信
		-	2 连接正在进行关闭
		-	3 连接已经关闭或者连接不可打开
	-	socket.bufferedAmount
		-	只读属性bufferedAmount已被send()放入队列等待传输
-	socket事件
	-	socket.onopen	连接建立时候触发
	-	socket.onmessage	客服端接收服务端数据触发
	-	socket.onerror		通信发生错误时触发
	-	socket.onclose		连接关闭时候触发
-	websocket本质上是一个基于tcp的协议
-	只是客户端向服务端发请求的时候	包含了一些附加头信息
	-	Upgrade:WebSocket
	-	表明这是一个申请协议升级的http请求
	-	连接中断的条件是某一方主动断开连接
##	rmfJSON
-	浏览器和服务器进行数据交换的时候		数据只可以是文本
	JSON是文本			js对象转换为JSON文本发送给服务器
	也可把从服务器接收到的任何 JSON 转换为 JavaScript 对象
	把数据作为 JavaScript 对象来处理，无需复杂的解析和转译
-	JSON.stringify()
	JSON.parse()
-	JSON让js对象存储为文本成为可能
-	JSON是一种轻量级数据交换格式		JSON独立于语言
-	JSON名称需要双引号		不能是单引号
-	访问js对象			
	-	person.name				-->对象形式
	-	person["name"]			-->数组形式
-	JSON和XML都可用于从web服务器接收数据
-	JSON XML都可以被大量编程语言解析和使用
-	XML必须使用XML解析器进行解析
-	从web服务器接收数据的时候	数据永远是字符串
-	JSON不允许日期对象		不允许函数
	"age":"function(){return 34}"
-	JSON.stringify()会从js对象中删除任何函数		将把任何日期转换为字符串
	JOSN中使用函数		函数会失去作用域
-	for in 遍历对象的key  		数组的key
-	for of 遍历数组的value
-	delete关键词来删除JSON对象的属性			delete myObj.cars.car1
##	jsHTML输入实例
-	按钮
	-	document.getElementById('').disabled
									name
									type
									value			按钮的值value
									innerHTML		按钮显示的文本
									form.id			按钮所属的表单的id
-	表单
	-	submit()
	-	reset()
	-	表单每个元素的值		form.elements[i].value
	-	表单可以接受的字符集	form.acceptCharset
	-	查找表单的action属性		form.action
	-	表单的编码方式			form.enctype
	-	表单元素的数量			form.length
	-	表单发送数据的方法		form.method
-	下拉列表
	-	selection.size = 5		下拉列表转换为5行的列表
	-	下拉列表**选取多个选项**		selection.multiple=true
	-	下拉列表显示选择的选项			selection.options[selection.selectedIndex].text
		-	下拉列表选择的选项
	-	selection.selectedIndex		下拉列表选择的下标
	-	selection.options[selection.selectedIndex].text = 'val'
	-	下拉列表删除选项		selection.remove(selection.selectedIndex)
-	超链接a
	-	a.herf属性标识资源的位置
	-	a.hreflang='zh-cn'
	-	rel属性只有在使用了herf的前提下才可使用
		指定当前文档和被链接的文档的关系			
		rel='nofollow'		搜索引擎不跟踪连接
		rel='start'			集合中的第一个文档 
	-	target='_blank'		在新的窗口打开连接文档
		target='_self'		相同的框架打开被连接的文档
		target='framename'	指定的框架中打开连接的文档
		target='_parent'	在父框架中打开来链接文档
	-	type='mime_type'	规定目标文档的mime类型
-	area
	-	查看area的备用文本		area.alt		<area alt=''/>
	-	区域的坐标		area.coords=''
	-	区域的形状		area.shape='circle'
	-	
##	301 302
-	301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址
-	302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址
-	302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”
##	用到了图片地图
-	<img src='' usemap='#planetmap'/>
	<map name='planetmap'>
	<area id='' coords='' href='' shape='circle' alt='img'/>
	</map>
-	coords是指明了图片上的可以添加事件的区域坐标
-	一张图片使用图片地图  那么一张图片可以划分为多个区域	不同区域可以根据需求去添加相应所需要的事件
	从而达到了不用请求多张图片	优化了页面性能的目的
##	base对象设置的是
-	页面中所以相对URL的基准URL
	-	<base href='https://www.baidu.com' id='baseId'>
	-	页面中的URL的基准URL是base的href
-	页面中所以链接是基准目标
	-	<base target='_blank'>
	-	页面中的URL的统一的 target值
##	 iframe
-	backgroundColor
-	height
-	name
-	src
##	Image
-	alt src	useMap
##	Table
-	border	padding
-	表格单元格的innerHTML	var x = table.rows[0].cells
						   console.log(x[0].innerHTML)
						   cells一行的小牢房是一个数组
-	创建表格标题			table.createCaption().innerHTML = 'Title'	
-	删除表格的行		table.deleteRow(0)-->删除表格的第一行数据
-	表格中添加行		var x = table.insertRow(0)
							var y = x.insertCell(0)
							var z = x.insertCell(1)
							y.innerHTML = z.innerHTML = 'NEW'
	-	插入行  插入行中的列数据		插入列数据的具体数据
##	输入事件
-	onblur		用户离开输入字段的时候
	onblur = 'myFn(this)'
	function myFn(x){x.value = x.value.toUpperCase()}
	html代码中输入的形式		<input onblur='myFunction(this)'>
	this的指针的传入		方便了函数的执行
-	select中的onchange事件		form表单中包含了一个select下拉框选项
	-	onchange='preferedBrowser()'		
	-	preferedBrowser(){
		//获取表单中select下拉框选中的数据		browser是select框的id
		var prefer = document.forms[0].browsers.value
	}
	-	forms是负数的形式
-	onfocus = 'myFn(this)'
	function myFn(x){x.style.background = 'yellow'}
-	输入框有文字被选中的时候会触发的函数
	-	onselect = 'myFn(this)'
		function myFn(x){alert(x.value)}
-	window.forms[0].fname.value
	-	fname是DOM中第一个form中的id为fname的元素	fname是form表单中的元素
		forms注意是复数的形式
-	<input type='reset'>		重置的按钮属性的设置
	<form onreset='message()'>		重置按钮会触发的回调函数		注意的是form表达绑定的函数
	onreset='message()'
-	<form onsubmit='confirmInput()'>	提交按钮点击的时候会触发的回调函数
-	<input type='text' onkeyup='myFn()'>	
	onkeyup			input框中	键盘上按键抬起的时候会触发回调函数
	onkeydown			键盘上按键按下/按住的时候会触发回调函数
-	onkeypress			键盘上按键按下/按住的时候会触发回调函数
	-	onkeypress事件**不能对系统功能键**(例如：后退、删除等，其中对中文输入法不能有效响应)进行正常的响应
	-	onkeydown和onkeyup均可以对系统功能键进行有效的拦截
-	onkeypress事件的keyCode对**字母的大小写敏感**，而onkeydown、onkeyup事件不敏感
-	onkeypress事件的keyCode无法区分主键盘上的数字键和付键盘数字键的，而onkeydown、onkeyup的keyCode对主付键盘的数字键敏感
-	js中传递this    event的事件是不同的
	this	指向的是标签本身
	event	指向的是触发事件的本身		例如keyboardevent
-	html函数中可以传入的参数有		onkeyup = 'myFn(this,event)'
	function myFn(x,y){console.log(x.type,y.keyCode)}
-	当你按下字符键时，你会发现**两个事件都触发了**，但有先后顺序，**先触发KeyDown**,再触发KeyPress。但当你按下非字符键时，就只会触发KeyDown事件，KeyPress则不知所踪。当焦点在文本框时，哪怕你按下的是F5键刷新，onKeyDown也都会触发。
##	onmouseover、onmouseout
-	onmouseover:鼠标进入元素时触发，onmouseout：鼠标离开元素时触发
-	鼠标经过子元素时，其父元素的onmouseover、onmouseout事件也会触发，产生事件冒泡效果;
##	onmouseenter、onmouseleave
-	onmouseenter:鼠标进入元素时触发，onmouseleave：鼠标离开元素时触发
-	鼠标经过子元素时，其父元素的onmouseenter、onmouseleave事件不会触发，不会产生事件冒泡效果;
##	onmousedown/onmouseup - 当按下/释放鼠标按钮时
-	onmousedown = 'whichButton(event)'
	function whichButton(x){console.log(x.button)}
	//直接使用event.button来获取点击的鼠标的按键		0左键 1中键	2右键
##	onload
-	页面 图像加载之后
-	onerror图像加载错误
	-	<img src='' onerror='myFn()'>
		function myFn(){alert()}
-	onresize()窗口调整大小的时候
	-	<body onresize='myFn()'>
		function myFn(){
			var w = window.outerWidth
			var h = window.outerHeight
		}
##	window对象
-	window.open('url')打开新的窗口
-	window.open('url','_blank','scrollbars=yes,resizeable=yes,top=300,left=200')
	_blank   resizeable是新的窗口的配置
-	var myWindow = window.open('','','width=200,height=200')
	myWindow.blur()//窗口失去焦点
	myWindow.focus()//窗口获取焦点
-	窗口关闭		window.close()
-	myWindow.closed判断窗口的打开关闭状态		返回的 是boolean值
-	打开的新的窗口向源(父)窗口写入文本
	-	myWindow.opener.document.getElementById('Id').innerHTML = 'txt'
-	移动新的窗口		移动一个指定的相对位置
	-	myWindow.moveBy(20,20)
-	移动到固定的位置
	-	myWindow.moveTo(300,0)		//距离左边的距离是300px
		myWindow.focus()
-	打印当前页面
	-	window.print()
-	按照指定的像素来调整窗口的大小
	-	myWindow.resizeBy(20,20)	//窗口按照指定的像素来改变大小
-	将窗口调整为指定的大小
	-	myWindow.resizeTo(200,200)		//窗口被指定了指定的大小
-	窗口按照指定的像素来滚动内容
	-	myWindow.scrollBy(0,10)			//窗口指定的滚动像素是10px
-	窗口滚动到指定的位置
	-	myWindow.scrollTo(0,100)		//窗口滚动到了指定的100px的位置
##	document.cookie
-	document.cookie = name + '=' + inputName + ';' + inputExprise
-	document.cookie.split(';')
##	访问者的屏幕的宽度 高度 可用的宽度	可用的高度	色深	像素深度
	screen.width		height availWidth availHeight colorDepth pixelDepth
##	window.location对象
-	返回当前URL的主机名和端口	window.location.hostname
	页面的完整的URL	window.location.href
	URL的路径名	window.location.pathname
	URL的协议部分	window.location.protocal
	加载新的文档	window.location.assign('https://www.baidu.com')
	替换当前的文档	window.location.replace('url')
	跳出框架		window.top.location = 'url'
##	window.history()
-	window.history.length	返回历史列表的URL的数目
-	window.history.go()			.back()		.forward()
	go就是前往历史记录中特定的URL		.go(-2)
##	window.navigator对象
-	浏览器是否启用了cookie		window.navigator.cookieEnabled		返回的是boolean
-	返回浏览器的名称			window.navigator.appCodeName		Mozilla
-	返回浏览器引擎的名称		window.navigator.product			Gecko
-	返回浏览器的版本信息		window.navigator.appVersion			
-	浏览器用户代理信息			window.navigator.userAgent		
-	浏览器的平台				window.navigator.platform
-	浏览器的语言				window.navigator.language		-->zh-CN
-	浏览器中是否启用了Java		window.navigator.javaEnabled	
##	弹出框
-	alert()
-	警告框中换行		window.alert('hello\nhaha')
-	弹出确认框			window.confirm()		返回的是boolean  查看是否点击了确认按钮
	if(!window.confirm('是否离开'))
-	弹出提示框			window.prompt()
	prompt('输入密码')
##	setTimeout(fn(){},delay)  		setInterval()
-	document.getElementById('id').innerHTML
-	clearInerval		clearTimeout
-	getHours()		getMinutes()		getSeconds()
##	Math
-	Math.max(...arr)
-	acos()		反余弦值
-	asin()		反正弦值
-	返回随机数的操作
	-	Math.random()		-->[0,1)		记得获取的随机数需要取得整数
	-	那么返回[n,m)之间的随机数的公式是
		-	Math.floor(Math.random()*(m-n))+n
	-	取得[n,m]之间的整数的方法
		-	Math.floor(Math.random()*(m-n+1))+n
##	Number对象是原始数值的包装对象
-	toPrecision(n)对象的值超出指定位数的时候会将其转换为指数计数法
-	超出代表的是超出	不包含等于的情况
	-	> n
-	var num = new Number(10000111)
	num.toPrecision(8)-->10000111
	num.toPrecision(7)-->1.000011e+7
	num.toPrecision(9)-->1.0000111.0
	num.toPrecision(1)-->1e+7
	num.toPrecision(2)-->1.0e+7
	num.toPrecision(3)-->1.00e+7
-	n >= 有效数字		--》定点计数法
-	n < 有效数字		--》指针计数法
##	HTMLCollection对象
-	是hmtl元素组成的类似于数组的列表		不是数组
-	htmlcollection转换为数组的方法
	-	Array.prototype.slice.call(collection)
	-	Array.from(collection)
	-	[].slice.call(collection)
	-	[...collection]
##	数据之间的转换
-	十进制数据转换为	十六进制	八进制	二进制
	-	var num = 8
		**对number类型的数据**
		num.toString(16)-->转换为16进制的数据	8
		num.toString(8)-->转换为8进制的数据		10
		返回的数据的类型式字符串
-	字符串转换为十进制的数据
	-	var num = 'ff'
		parseInt(num,16)
	-	数据按照16进制的格式来进行转换		
-	数组转换为字符串
	-	arr.join('')
	-	arr.join('-')
	-	join方法可以指定分隔符号	
	-	arr.toString()
	-	toString方法不可指定分隔符号
	-	arr.toLocaleString()
-	字符串转换为数组
	-	string.split(',')
	-	把一个字符串分隔为一个字符串数组
-	
##	router-link
-	to属性		route导航去往的路径名
	-	:to属性使用的时候		记得加上冒号:
		-	当然只是传入对象的形式			:to='{name:"user",query:{aa:"aaName"}}'
		-	/user?aa=aaName
	-	使用params的时候记得		路由配置的参数是动态形式的参数
		-	path:'/user/:username'
		-	<router-link>	里面params的参数的名字要和username是相同的才能够匹配对应的路径
-	tag属性		router-link默认值是a标签	想要router-link渲染为其他标签的时候可以更改tag的值
-	因为默认是a标签		那么字体就会有颜色的变化		那么想要恢复原来的样式的时候	就需要
	添加样式		当然除了添加样式的方法		同样还有就是改变tag值	来改变a自带的样式
-	active-class	链接激活的时候使用的css类名		也就是控制链接激活的时候的样式
	-	默认值可以通过路由的构造选项来设置
		-	linkActiveClass:'is-active'
-	exact-active-class		链接被精确匹配的时候激活的class
	-	统一可以通过路由统一配置默认值		linkExactActiveClass
-	exact	是路由的精确匹配模式	默认值是false
-	append属性		设置之后	在当前路径前面添加基路径
##	props初始属性的设置
-	props:{
	str:{
		type:String,
		default:''
	},
	num:{
		type:Number,
		default:0
	}
}
##	哈希表
-	哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。
-	哈希表也有自己的缺点，哈希表是基于数组的，我们知道数组创建后扩容成本比较高，所以当哈希表被填满时，性能下降的比较严重。
-	哈希表采用的是一种转换思想，其中一个重要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标
-	两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突
-	哈希冲突是不可避免的，我们常用解决哈希冲突的方法有两种「开放地址法」和「链表法」
	-	在开放地址法中有三种方式来寻找其他的位置，分别是「线性探测」、「二次探测」、「再哈希法」
		-	在线性探测哈希表中，数据的插入是线性的查找空白单元，例如我们将数88经过哈希函数后得到的数组下标是16，但是在数组下标为16的地方已经存在元素，那么就找17,17还存在元素就找18，一直往下找，直到找到空白地方存放元素
		-	二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3......，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25......,以此类推，到原始距离的步数平方，为了方便理解，我们来看下面这张图
		-	二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。
		-	双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。
		-	第二个哈希函数必须具备如下特点
			和第一个哈希函数不一样
			不能输出为0，因为步长为0，每次探测都是指向同一个位置，将进入死循环，经过试验得出stepSize = constant-(key%constant);形式的哈希函数效果非常好，constant是一个质数并且小于数组容量
		-	双哈希需要哈希表的容量是一个质数
			假设我们哈希表的容量为15，某个「关键字」经过双哈希函数后得到的数组下标为0，步长为5。那么这个探测过程是0,5,10,0,5,10，一直只会尝试这三个位置，永远找不到空白位置来存放，最终会导致崩溃。
		-	「链表法」来解决哈希冲突。「链表法」相对简单很多，「链表法」是每个数组对应一条链表。当某项关键字通过哈希后落到哈希表中的某个位置，把该条数据添加到链表中，其他同样映射到这个位置的数据项也只需要添加到链表中，并不需要在原始数组中寻找空位来存储。
##	js教程
-	document.getElementById('Id').innerHTML = Date()
-	document.getElementById('Image').src = '/assets/Images/'
-	document.getElementById('div').style.fontSize = '14px'
-	document.getElementById('div').style.display = 'block'
-	脚本可被放置与 HTML 页面的 <body> 或 <head> 部分中，或兼而有之。
-	外部 JavaScript 的优势
	在外部文件中放置脚本有如下优势：
		分离了 HTML 和代码
		使 HTML 和 JavaScript 更易于阅读和维护
		已缓存的 JavaScript 文件可加速页面加载
-	JavaScript 对大小写敏感
-	js中对象函数的使用
	-	obj={fn:function(){console.log('1')}}
	-	第一种形式
			var myFn = obj.fn()
			myFn存储的形式是fn的执行函数的结果
			myFn--->直接就执行了函数
	-	第二种形式
			var myFn = obj.fn
			myFn存储的形式是fn函数的字符串的形式
			不可使用myFn()的形式来执行函数
-	不重复定义函数那么就使用bind
	-	var myFn = person.fullName.bind(null)
		myFn(parameter1)
	-	获取了person的函数
-	var x = new Number(500);             
	var y = new Number(500);
	// (x == y) 为 false，因为对象无法比较
##	Number的方法
-	toString()	方法来进行返回		以字符串的形式返回数值
	-	(100+23).toString()		-->返回的是123
-	toExponential()返回字符串的值	包含已经被四舍五入并且是指数计数的数字
	注意是四舍五入		加上指数计数的方式
	var x = 9.656;
	x.toExponential(2);     // 返回 9.66e+0
	x.toExponential(4);     // 返回 9.6560e+0
	x.toExponential(6);     // 返回 9.656000e+0
	()里面指明的数据是数据**小数后面的位数**
-	toFixed()	包含指定位数小数的**数字**		四舍五入
	toFixed(2)		处理金钱相关的数据
-	toPrecision()	返回的是**字符串**		包含了指定长度的数字
	()里面指定的就是数据的长度
	var x = 9.656;
	x.toPrecision(6)-->9.65600
-	valueOf()		以数值返回数值
	x.valueOf()
	(123).valueOf()
	(100+23).valueOf()
	都是返回的数据123
	js内部使用valueOf()可以将Number对象转换为原始值
-	全局方法
	-	Number()
		-	返回数字	由参数转换来	
	-	parseFloat()
		-	返回浮点数	
	-	parseInt()
		-	返回整数
-	日期转换为数字
	-	Number(new Date('2019-04-15'))
		1506729600000
-	Math.sin()		Math.cos()	使用的参数是弧度值	Math.PI
	Math.round()四舍五入最接近的数据
	[m,n)		-->Math.floor(Math.random()*(n-m))+m
	[m,n]		-->Math.floor(Math.random()*(n-m+1))+m
-	Math.E	Math.SQRT2	Math.LN2	Math.LN10	Math.LOG2E
##	Date对象
-	年	月 日 时 分 秒	毫秒
-	var d = new Date(2018,11,24,10,33,30,0)
-	js将日期**存储为毫秒**	
-	从日期字符串创建一个新的日期对象
	-	var d = new Date('December 13,2014 11:13:00')
		Wed Dec 25 2019 12:46:00 GMT+0800 (中国标准时间)
-	new Date()是1970-1-1-08:00:00的开始
	var d = new Date(10000)
	这句指令的意思是在初始时间的基础**上面添加了**10000毫秒的数据的更新返回
-	js默认将以全文本字符串的格式来输出日期
	-	var d = new Date()来进行日期的展示
	-	d.toString()
		d.toUTCString()	来进行日期的一种显示标准
		d.toDateString()	日期更加容易阅读的方式
-	获取时间对象的响应数据	使用的是get		想要设置时间的时候	使用set替换get来设置时间
-	Date.parse()
	-	解析一个日期的字符串，并返回该日期距**1970年1月1日午夜之间的毫秒数**
	-	Date.parse(2000-8-8)
-	数组里面可以存放	对象	函数 	数组
-	arr[arr.length]=para
	para.concat(arr)
-	数组使用命名索引的时候	js会把数组重定义为标准对象	之后所有数组的方法和属性将产生非正确的结果
	-	arr['firstName'] = 'Bill'
		arr.length-->0		
		arr[0]返回undefined
-	在js中		数组使用的是数字索引			对象使用的是命名索引
-	如果希望元素名为字符串(文本)		就使用对象
	希望元素名为数字		就使用数组
-	new 关键字会使得代码复杂化		还会产生不可预期的结果
	-	var d = new Array(12,2)		//产生包含12 2的数组对象
	-	var d = new Array(49)		//产生包含49个没有定义元素的数组对象
-	Array.isArray(arr)//判断数组是不是数组类型的数据
-	创建自己的判断数组的方法
	function isArray(arr){
		return arr.constructor.toString().indexOf('Array')>-1
	}
-	假如对象由给定的构造器构造而成		那么用instanceof来判断对象是否属于对应的构造函数
	arr instanceof Array
-	数组的排序
	-	arr.sort()--》字母的顺序对数组成员进行排序		默认的排序顺序是升序的
	-	arr.reverse()反转数组中的元素		arr.sort()
		可以巧妙使用reverse来对数组使用过sort函数之后来进行一个数组元素降序数组的获取
-	sort函数会按照字符串顺序对值进行排序
	-	那么对数字数据的排序会出现问题
	-	那么用到了比值函数来解决相关的问题
		-	arr.sort((a,b)=>a-b)		//数据会升序排序
-	获取随机的排序的数组
	-	arr.sort((a,b)=>0.5-Math.random())
-	排序对象数组
	-	arr.sort((a,b)=>a.year-b.year)
	-	arr=[
		{name:'Bill',year:12},
		{name:'Gates',year:13}
	]
	-	arr.sort((a,b)=>{
		var x = a.name.toLowerCase()
		var y = y.name.toLowerCase()
		if(x < y)return -1
		if(x > y)return 1
		return 0
	})
-	arr.forEach()每个数组元素进行一次回调函数的调用
	arr.forEach((item)=>item=item+1)
	arr.forEach(myFn)
	var txt = ''
	-	myFn(item,index,array){
		txt = txt + item + '<br>'
	}
-	map函数是不会改变原来的函数的	只是会基于原来的数组进行一些操作来返回一个新的数组
-	数组的filter函数	过滤一些符合条件的数组元素
	var newArr = arr.filter(function(item,index){
		return item>1
	})
-	arr.every(function(){})所有数组值是否符合要求		返回的是boolean值
-	arr.some(function(){})某些数组值是否通过了测试		返回的是boolean值
-	arr.find()	返回符合元素的值
-	Array.prototype.myEach = function(callback,thisArg){
	if(!Array.isArray(this) || typeof(callback)!=='function'){
	throw new Error('wrong...')
	}
	let T = thisArg
	for(let i of this){
	callback.call(T,i)
	}
	}
##	清除浮动	
-	在浮动元素的父元素上面添加overflow:hidden
-	或者在浮动元素的父元素上面添加::after{
	content:'',
	display:block,
	clear:both
	}
##	create里面的异步操作
##	constructor属性来返回所有js变量的构造器函数
-	"Bill".constructor		-->function String(){[native code]}
-	(3.14).constructor		-->function Number(){[native code]}
-	false.constructor		-->function Boolean(){[native code]}
-	[1,2,3,4].constructor		-->function Array(){[native code]}
-	**可以通过constructor来检测数据的具体类型**
	-	return target.constructor.toString().indexOf("Array") > -1
	-	检查对象的constructor是不是**数组函数**
		-	arr.constructor === Array
-	return myDate.constructor.toString().indexOf("Date") > -1
-	将数值转换为字符串
	-	num.toString()
	-	String(num)
	-	String toString可以将Boolean转换为字符串
##	Date对象的方法
-	获取一个月中的具体日子		获取日期
	-	var d = new Date()
	-		d.getDate()				-->1-----31中的数据值
-	d.getFullYear()		-->获得4位的年		--》2021		
	-	注意由Full
-	d.getDay()
	-	获取的是当前是周几
	-	返回值的类型是number类型的数据
-	获得具体的时间		--》getHours()		-->0--23		-->获得24个小时当中的具体时间	单位是小时
-	d.getMilliseconds()获取毫秒
	d.Fn		-->返回的是函数的字符串代码
	d.Fn()		-->返回的是函数执行的返回值
-	d.getMinutes()
	-	值得一提的是每一个API都有一个get的前缀		后面紧跟的字符串是否是复数的差别	注意区分就行
-	获取月份的时候值得注意的是
	-	d.getMonth()		-->月份的代码值是0--11		那么要想获取准确的月份数据就需要在
		获取的数据上面记得加上1	得到的结果才是准确的数据值
-	获得秒
	-	d.getSeconds		获得秒
-	获得时间
	-	d.getTime()			获取的是1970年1月1日以来的毫秒总数
-	最后总结字符串的复数行为
	-	**拥有复数行为的是**
		-	时Hours   分Minutes 	秒Seconds  	毫秒Milliseconds
-	一元的'+'运算符可以将**变量转换为数字**
	-	var y = '5'
		var x = +y		//x是数字5
	-	如果无法转换变量的话	仍会成为数字		但是值为NaN
	-	var y = 'Bill'
		var x = +y		//x是NaN
-	typeof返回的数据类型是一个全部小写的字符串
	-	typeof number / string / object / boolean / null / undefined / function
	-	注意返回的是字符串
-	把日期转换为数字
	-	var d = new Date()		-->The Nov 18 2021 13:19:02	GMT+0800 (中国标准时间) {}
		Number(d)			-->可以将日期转换为数字		-->返回的是一个值为毫秒数的字符串
		d.getTime()			--》返回的是一个值为毫秒数的字符串
-	+运算符遇到字符串的时候	默认发生的是字符串拼接的方法		而不是自动转换为数字的方法来进行数据的
	加法运算
	-	简称加法运算符遇到字符串运算
-	值得注意的是对象进行toString()运算的返回值
	-	obj.toString()		-->[object Object]
	-	var obj = [1,2];obj.toString()		-->'1,2'
-	Boolean('0')			Boolean('000')
	-	转换之后的结果是true		因为字符串只要不为空		那么返回的结果就是true
-	var x = false
	var y = new Boolean(false)
	x == y  		-->true		值是相等的
	x === y  		-->false	类型是不相等的
-	对象是无法进行比较的
-	字符串之间的比较是按照字母顺序进行比较的
	-	'2' > '1'	'2' > '10'	'2'>'19'		返回的 都是true
	-	'2' > '2'		-->false
	-	非数值字符串进行比较的时候 	字符串将会被转换为false 或者  NaN
	-	2 > 'John'		2 < 'John'		2 == 'John'
		-	'John'返回的是false  	或者是		NaN
##	条件语句
-	if		else 		else if 		switch
	If使用大写字母会产生js错误
	if(){}else if(){}else{}
##	循环语句
-	for
	-	for循环来初始化数据
-	for in 
	-	for in 循环来遍历对象的key			遍历数组的key
-	while
-	do while
##	js的try catch finally代码块
-	try{
	...
	}catch(err){
		...//发生错误之后会执行的代码块
	}
-	js抛出异常
	-	实际上会创建带有两个属性的Error对象
		-	name  和   	message
-	throw允许开发者自定义一个错误
	throw 'error input'
-	var x = document.getElementById('ID').value		//获取输入框的值
-	try{
		if(x == '') throw 'error null'
		if(isNaN(x))throw 'not number'
	}catch(err){
		message.innerHTML = '输入是' + err
	}
	-	err代表的是捕获的异常信息
-	try{}catch(err){}finally{}
	-	无论try   catch代码块如何		finally是最后都会执行的代码块
##	Error对象
-	每一个error对象都有两个属性是name 		和		message
	-	name  返回的是错误名		message返回的 是错误消息
-	name的属性值
	-	EvalError		已经在eval函数中发生的错误
	-	RanageError		发生超出数字范围的错误
	-	ReferenceError	发生的是非法引用
	-	SyntaxError		发生的是语法错误
	-	TypeError		发生的是类型错误
	-	URIError		在encodeURI()中发生的错误
##	正则表达式
-	可以用于文本搜索		文本替换的操作
-	正则表达式常用的两个字符串方法
	-	search()			replace()
	-	search()	返回的是匹配的**位置**
		-	str.search(/okok/i)			-->**返回的是okok的位置**
	-	replace()		返回模式被替换处**修改后的字符串**		只替换第一个匹配的数据
		但是加上g来进行全局匹配的话		就是全局匹配字符串
		-	str.replace(/no/i,'ok')		-->返回的是no被替换为ok的字符串
-	正则表达式可以让搜索更加强大	(例如不区分大小写)
	-	i		是不区分大小写
	-	g		是执行全局匹配
	-	m 		是执行多行匹配
-	正则表达式的模式
	-	[abc]		查找方括号中的任何字符
	-	[0-9]		查找从0-9中的数字
	-	(x|y)		查找由|分隔的任何选项
-	\d		查找的是**数字**
-	\s		查找的是**空白字符**
-	\b		查找的是**单词边界**
-	\uxxx	查找的是十六进制数据xxx规定的unicode字符
-	+		[1,+]	
-	*		[0,+]
-	?		[0,1]
-	test()函数		通过模式来搜索字符串	**返回的是boolean**		
	-	var pattern = /e/
		pattern.test('The best things is life are free!')
	-	test就是**模式匹配字符串**		正则表达式来匹配字符串是否符合规则
	-	/e/.test("The best things is life are free!")
-	exec()通过指定**模式来搜索字符串**		并且**返回找到的字符串**
	-	没有匹配的字符串就会返回null
-	**字符串去重**
	-	'aabbcc'.replace(/(.)\1+/gi,`$1`)
	-	\1匹配的是**第一个代括号的子表达式所匹配的模式**
-	(x) 匹配x保存x在名为$1...$9的变量中 		括号匹配的字符是保存可以保存在模板字符串里的
	-	模板字符串来书写匹配的字符串输出	`$1`
-	[^xyz] **不匹配这个集合中的任何一个字符**		注意是不匹配任何一个字符
-	[\b] 匹配一个退格符 		[]来限制匹配字符
-	\w 匹配一个**可以组成单词的字符**
-	\W 匹配一个**不可以组成单词的字符**
-	正则表达式是一个**描述字符模式的对象。** 
-	[]			()
	-	在正则表达式中,**括号的第二个用途是在完整的模式中定义子模式**
	-	()就是**可有可无的子模式**		有就会匹配出来
		-	\1匹配的是第一个代括号的子表达式所匹配的模式

	-	分组是通过 () 来实现的	比如 beyond{3}	是匹配 d 字母三次	而 (beyond){3} 是匹配 beyond 三次

##	数据类型
-	原始数据类型
	-	string number boolean null	undefined
-	对象是包含变量的变量
-	对象方法是包含	函数定义的 对象属性
-	不同方法来创建对象
	-	定义对象的构造器	然后创建构造类型的对象
	-	定义和创建单个对象	使用对象文字
	-	定义和创建单个对象	使用关键词new
	-	Object.create()
-	js对象是易变的
	-	通过引用来寻址	不是值
	-	var x = preson
	-	比如person 是一个对象		那么这种赋值的方式就是		x person 是指向的同一个引用地址
		值的改变是相互牵连的
-	js属性的获取
	-	obj.propertyName
	-	obj["propertyName"]
	-	var x = "propertyName"
		obj[x]
-	向**对象添加属性**的时候就是简单的赋值操作即可
	-	obj.propertyName = 'property'
-	对象删除属性的操作
	-	delete 	obj.propertyName
	-	delete  obj["propertyName"]
	-	delete操作会同时删除属性的值和属性本身
-	delete删除某个原型属性的时候		会影响所有从原型继承的对象
##	JSON对象
-	键必须要是有效的JSON数据类型
	-	string number boolean null Array Object
-	可以使用**点运算符来访问对象的值**
	-	obj.propertyName
	-	**方括号来访问对象的值**
	-	obj["propertyName"]
	-	**for  in循环来访问对象的属性**
-	嵌套的JSON对象
	-	一个JSON对象的值是另一个JSON对象
	-	myObj = {
		"name":"Bill",
		"age":12,
		"cars":{
			"car1":"name1",
			"car2":"name2"
		}
	}
	-	这种情况来访问嵌套JSON对象的属性的方法
	-	var x = myObj.cars["car1"]
		var y = myObj.cars.car1
-	修改或者删除嵌套json对象中数据就和基本访问JSON数据对象的方法是一样的
##	JSON数组
-	var obj = {"cars":["car1","car2","car3"]}
-	访问数组的值
	-	obj.cars[0]
	-	var x = 0
	-	for(let i in obj.cars){
		x+=obj.cars[i]
	}
	-	for in 循环 遍历数组的值来进行想要进行的操作
	-	for(let i = 0;i < obj.cars.length;i++){
		x += obj.cars[i]
	}
-	JSON对象中嵌套数组
	-	var myobj = {
		"name":"Bill",
		"cars":[
			{"name":"BWM","model":["911","ok"]},
			{"name":"Volvo","model":["M5","X5"]},
		]
	}
-	**嵌套数组的遍历的时候	会用到双重for循环来遍历数组的值**
	-	for(let i in obj.cars){
		x += "<h1>" + obj.cars[i].name + "</h1>"
		for(let j in obj.cars[i].models){
			x += obj.cars[i].model[j]
		}
	}
-	当然**修改和删除**嵌套JSON数组的时候也是会	和普通的JSON数组的操作是一样的
	-	delete obj.cars[1]
	-	obj.cars[1] = "xx"
-	JSON解析
	-	JSON的常规用途是**同Web服务器进行数据传输的**
	-	在从Web服务器接收数据时候		数据永远是字符串
	-	使用JSON.parse()	可以将JSON的数据格式转换为JS对象的数据格式
-	书写一个AJAX请求
	-	var myXHR = new XMLHttpRequest()
			myXHR.onreadystatechange = function(){
				if(this.readyState === 4 && this.status === 200){
					myObj = JSON.parse(this.responseText)
					document.getElementById("demo").innerHTML = myObj.name
				}
			}
		myXHR.open("GET","json_demo.txt",true)
		myXHR.send()
-	AJAX请求的关键点就是
	-	onreadystatechange函数的书写
	-	this指针的应用		this.readyState			this.status		this.responseText
	-	xhr.open('GET',"json_demo.txt",true)
	-	xhr.send()
	-	发送之后就会去响应请求数据
-	JSON当中是**不允许日期对象**的
	-	需要用到日期的时候		把**日期写为字符串的形式**		"2021-1-1"
	-	需要用到日期对象数据的时候		进行一个二次的转换
		-	var obj = JSON.parse(text)
				obj.getDate = new Date(obj.getDate)
		-	这个时候就成功使用日期对象了
-	**JSON是不允许函数的**
	-	需要使用到函数的时候		将函数写为字符串的形式
	-	那么使用函数的时候	就需要将**字符串转换为函数**的形式来使用
	-	**第一种字符串转换为函数的方法使用eval()函数**
		-	eval()函数
			-	eval函数具有**解析表达式的特性**		那么使用eval函数来解析字符串为函数是可行的
			-	但是eval函数可以解析任何字符串		这是不安全的	尽量不要使用eval函数
	-	**第二种方法字符串转换为函数使用的是new Function()**
		-	new Function()	**只接受字符串参数**	其可选参数为方法的入参
		-	function add(a,b){return a+b}
			var add = new Function("a","b","a = a+1;b=b+1;return a+b")
		-	利用最后的方法体参数	直接返回一个函数	那么执行这新的创建函数后得到的就是我们需要的函数
		-	new Function("return "+obj.age)//obj.age		age是objJSON数据格式的字符串函数形式
		-	var changeFn = new Function("return "+obj.age)
		-	那么现在来执行函数
			-	changeFn()(obj.age.parameter)
			-	注意执行函数的形式是双括号的形式
			-	因为new Function()最后返回的是一个函数		那么执行返回的函数就需要加上一个括号
	-	那么现在来进行一个**深度的理解**就是
		-	JSON对象中的函数字符串内是一个完整的函数体	**函数体内没有包含其他的函数**
			那么就可以使用new Function()		和		eval()函数的方法来解析字符串
			-	**var getFn = eval("("+jsonObj.fn+")")**
			-	**var getFn = new Funtion("return "+jsonObj.fn)**
				-	只不过是new Function得到的函数真正在执行的时候会加上一层括号
			-	obj.constructor是**构造函数对象的内置代码**
		-	那么当JSON数据对象函数中不止是一个完整的函数体的时候	还**包含其他函数的时候**
			-	这时候需要对包含的函数和调用的函数的一个作用域进行一个调整	不然会出现问题
				**包含的函数和被调用的函数必须位于同一个作用域下面**
				-	解决方案有两个
					-	将变量和方法声明到window对象	风险就是和window内置属性同名的时候	将覆盖内置的属性
						-	fn('str1')(fn('str2')('parameter'))-->json数据函数字符串
							fn('str2')函数的返回结果不是函数	那么就会覆盖前面一个函数
							由于前面一个函数被第二个函数的执行结果覆盖了 	那么第一个函数就不是一个方法了
							所以就不会继续执行了
						-	要解决方法覆盖的问题		那么方法就不应该被定义为属性	
							而应该是原型		利用继承的特性来解决问题
						-	window._f = fn
							var expStr = `_f('str1')(_f('str2')('parameter'))`
						-	由于是window对象上面的属性		那么就会出现覆盖的问题
					-	将变量和方法作用到**同一个实例对象**下面
						-	创建一个构造方法	存在动态变量的时候	将动态变量放在this对象上	
							实例中通过this.属性名		来获取
						-	构造函数上面的原型方法可以来绑定this
							-	with(this)
							-	成功进行了this指针的绑定
				-	//注册filter
						export const resolveFilter = (id) => {
							if (typeof id !== 'string') {
								return id;
							} else {
								return filters[id]//返回一个函数
							}
						}

						//创建实例对象
						export function createExpInstance(paramsEntity) {
							for (let key in paramsEntity) {
								this[key] = paramsEntity[key]
							}
						}
						createExpInstance.prototype._f = resolveFilter;
						createExpInstance.prototype.getValue = function (exp) {
							let code = `return (()=>{with (this) {return ${exp}}})()`;
							try {
								let func = new Function(code);
								let currentFunc = func.bind(this);//绑定函数this指向，严格模式下this为undefined，非严格模式为window
								return currentFunc();
							} catch (err) {
								// console.log(err)
							}
						}

						let expInstance = new createExpInstance(paramsEntity);
						let expValue = expInstance.getValue(expStr);
##	JSON.stringify()
-	向web服务器发送数据的时候	记得将js对象转换为字符串
-	js----->JSON
	-	JSON当中是不允许存在日期对象的		遇到日期对象会转换为字符串
	-	JSON当中是不允许存在任何函数的		**遇到函数会自动删除函数**
-	php数据库的获取数据的一些简单步骤
	-	dbParam = JSON.stringify(obj)
		xhr.open("GET","demo_json_db.php?x="+dbParam,true)
		xhr.send()
	-	php中的数据的转换JSON
		-	json-->js		json_decode($_GET["x"],false)
			js-->json		json_encode($outp)
##	jsonp
-	var myScript = document.createElement('script')
-	myScript.src = 'xx.php'
-	document.body.appendChild(myScript)
##	json和xml的区别
-	json不使用标签
-	json更短
-	json读写速度更快
-	json可以使用数组
-	xml必须使用**xml解析器**进行解析	而json可以通过js函数进行解析
-	**json类似于xml**
	-	两者都是自描述(人类可读)的
	-	都是分级的(值中有值)
	-	两者都可被大量编程语言解析和使用
-	json比xml更好
	-	xml比json更难解析
	-	json 可以被解析为可供使用的js对象
-	使用XML
	-	读取XML文档
	-	使用XML DOM遍历文档
	-	提取变量中存储的值
##	js中的with函数
-	可以方便用来引用某个对象**已有的属性**		但是不可给对象添加属性
-	with(object)	
	statements
-	with函数的相关例子
	-	x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10) y = Math.tan(14 * Math.E)
	-	使用with函数来简化代码的书写
		-	with(Math){x=cos(3 * PI) + sin(LN10) y = tan(14 * E)}
-	with函数的应用意义
	-	为**逐级的对象访问**提供命名空间式的速写方式	在指定的代码区域	直接通过节点名称来调用对象
	-	with通常被当作**重复引用一个对象中多个属性**的快捷方式	可以不重复引用对象本身
	-	举个例子
		-	var obj = {
			a:1,
			b:2,
			c:3
		}
		-	访问obj对象中的属性的时候会用到的方式
			-	obj.a = 2
				obj.b = 3
				obj.c = 4
		-	但是用了with的方式的时候就简化了重复使用对象obj的情况		
			使得代码更加简洁清晰
		-	with(obj){
			a = 3;
			b = 4;
			c = 5
		}
		-	这就是with函数的快捷方式的用法
		-	代码块的解释	with代码块的内部	每个变量首先会被认为是局部变量
			如果**局部变量和obj对象的某个属性名是相同的**		那么局部变量会指向obj对象属性
-	with函数使用的弊端 
	-	with函数可以简化代码	但是不推荐使用
	-	with函数的使用	在存取对象	和调用方法的时候就**不需要重复指定对象**
	-	with函数的缺点
		-	导致数据泄露
		-	function foo(obj){with(obj){a = 2}}
			var obj1 = {a:3}
			var obj2 = {b:3}
			foo(obj1)--->console.log(obj1.a)--->输出2
			foo(obj2)-->console.log(obj2.a)==>输出undefined
			console.log(a)--->非严格模式下会输出2		a被泄露到全局作用域下面了
		-	obj1中有a 这个属性		那么就会成功赋值
		-	但是obj2中没有这个属性		那么不会创建这个属性	obj2.a保持的 是undefined状态
		-	为什么会造成内存泄漏	牵涉到**JS的LHS查询**
-	**JS中的LHS查询		RHS查询**
-	js被归类为动态的		或者解释执行语言		和传统的编译语言是不同的	它**不是提前编译**的
	编译的结果也**不能在分布式系统上进行移植**
	-	js语言的编译是代码执行前几微秒		甚至更短的时间内执行的
	-	var a = 2		的操作js引擎会把它分为两步来完成
		-	一步是var a				声明在**编译阶段**完成
		-	另一步是a = 2			**赋值声明会被留在原地等待执行阶段**
	-	LHS(Left-hand Side)		RHS(Right-hand Side)是对变量的两种查找方式
	-	通常是值等号左右两边的引用
	-	console.log(a)		-->这是对a的引用是一个RHS引用		**没有对a进行赋值	只是查找并且获取a的值**
	-	a = 2			-->这是对a的一个LHS引用		并不关心a的数据值是多少	只是想要**为赋值操作找到目标**
	-	LHS是寻找目标		那么有多少赋值号		就会有多少个LHS查询
	-	RHS是寻找值		那么赋值号右边有多少个需要寻找的数据	就会有多少个RHS查询
	-	如果LHS  RHS查询在没有找到数据的情况下的操作是有区别的
		-	LHS在没有找到数据的情况下是会自动隐式创建一个全局变量(**非严格模式**下)
		-	RHS在没有找到数据的情况下会抛出异常		ReferenceError
		-	根据此就知道了为什么with函数在obj2对象中找不到a数据的时候会发生**数据泄露的原因**了
		-	严格模式下	with函数是全面禁止的	会抛出ReferenceError		eval函数也被禁止了
-	使用with函数是会导致**性能下降**的
	-	js引擎会在编译阶段进行**数项的性能优化**
	-	其中有**一些优化是要依赖于代码的词法进行静态分析**的	并且预先知道所有变量的和函数定义的位置
		才能在执行过程中快速找到标识符
	-	但是使用with函数的时候		虽然代码看着更加简洁	但是js引擎只是简单假设关于标识符的位置判断是
		无效的 **无法知道传递给with用来创建新的此法作用域的对象**的内容是什么
	-	遇到with的时候就没有办法来进行优化	那么运行的速度自然就会变慢
##	js对象中函数的写法
-	get函数		和		普通函数的对比
-	get函数保存了更好的函数质量
	-	get lang(){return this.language}
		-	使用的时候类似于调用属性的方法直接调用即可
		-	obj.lang			->没有添加括号
	-	普通函数
	-	getLanguage:function(){return this.language}
		-	使用的时候	会是函数的形式调用	
		-	obj.getLanguage()		-->普通的函数形式使用的时候会加上括号来使用
-	使用set函数
	-	set setLanguage(lang){this.language = lang.toUpperCase()}
	-	使用set函数	
		-	obj.setLanguage = 'langType'
-	get  可以对对象的数据进行一次二次包装并返回	
-	get set使用的原因
	-	语法更加简洁
	-	更好的数据质量
	-	利于后台工作
##	您无法为已有的对象构造器添加新属性
-	**无法为已有的对象构造器添加新属性**
	-	构造函数添加新的属性	必须在**构造函数里**添加属性
	-	当然也可以在原型上面添加属性方法
##	Object
-	es5添加新的对象方法
-	以现有的 对象为原型来创建对象
	-	Object.create()
-	添加或者更改对象的属性	
	-	Object.definedProperty(obj,property,descriptor)
	-	Object.definedProperty(obj,'language',{value:'NO'})
		-	定义修改对象的属性		属性名需要加上引号
		-	writable		属性是否可以更改			true
		-	enumberable		属性是否可枚举		true
		-	configurable	属性是否可以重新配置		true
		-	定义get  set的操作
			-	get:function(){}
-	添加或者更改对象的属性
	-	Object.defineProperties(obj,descriptors)
-	返回对象的key
	-	Object.getOwnPropertyNames(obj)
-	返回可以枚举的key
	-	Object.keys(obj)
##	input框来确认是否输入有效数据
-	inputId.checkValidity()-->如果input框包含了**有效数据**		返回true
-	inputId.setCustomValidity()	-->设置input元素的validationMessage属性		-->如果input框没有输入**有效数据**		--》返回--》'请填写此字段'		--》这个**函数的默认值**是'请填写此字段'
	--》当然input框设置了required属性
	--》inputId.setCustomValidity('不填写是不可行的')
-	checkValidity()		setCustomValidity()		注意是**有效的数据**		注意input框的required的填写
-	input框的验证API
	-	inputId.validity
		-	validity是和有效性相关的布尔属性
		-	inputId.validity.valid		---valid		----返回的是元素的有效性	true/false
		-	inputId.validity.rangeOverflow		---rangeOverflow		---输入值大于有效范围
				----返回的 是布尔值


##	fetch	是基于async		await的
-	不再需要xhr		
-	fetch(file).then(x=>x.text()).then(y=>myDisplay(y))
-	Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。
-	当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），**仅当网络故障时或请求被阻止时，才会标记为 reject**
-	fetch() 可以接受跨域 cookies；你也可以使用 fetch() 建立起跨域会话
-	fetch **不会发送 cookies。**
-	文字中划线		text-direction:line-through
-	fetch不是ajax的封装		而是原生的js		没有使用xhr
	-	fetch的配置
		-	Promise fetch(String url [, Object options]);
			Promise fetch(Request req [, Object options]);
		-	你可以通过Request构造器函数创建一个新的请求对象，你还可以基于原有的对象创建一个新的对象。
		-	var req = new Request(url,{method:'GET',cache:'reload'})//cache:'reload'代表的是不会缓存
			响应结果
			现在可以基于这个设置的get请求的 配置来设置post请求
			var reqPost = new Request(req,{method:'POST'})
		-	使用配置好的req对象来进行资源请求
			-	fetch(req).then(function(res){
				return res.json()
			}).then(function(json){
				...
			})
-	fetch返回的是一个promise对象
	-	fetch('url')
		.then(response=>response.json())		
		.then(json=>console.log(json))
		.catch(err=>console.log('error',err))
		-	fetch接收到的response是一个**Stream对象**
			**response.json()是一个异步操作**	**取出response所有内容	并将其转为json对象**
		-	fetch通过**数据流来处理数据**	可以分块读取	提高网站性能	减少内存占用
			在请求大文件或者网速较慢的情况下是相当有用的
			xhr是不支持数据流的		所有数据必须放在缓存里面	不支持分块读取
			必须等待**数据整体全部获取**	再整体一次性吐出
-	**Promise使用await语法	语义更加清晰**
	-	async function getJSON(){
		let url = '...'
		try{
			let response = await fetch(url)
			return await response.json()
		}catch(err){
			console.log('err',err)
		}
	}
	-	**fetch请求成功之后	得到的是一个Response对象**	对应服务器http响应
		const response = await fetch(url)
		-	response包含的数据通过Stream接口异步读取		但是还是**包含一些同步属性**
			对应HTTP响应的标头信息	**可以立即读取**
			response.status				HTTP 回应的状态码
			response.statusText			HTTP 回应的状态信息
			Response.ok					属性返回一个布尔值，表示请求是否成功
			Response.url		属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。
			Response.redirected			属性返回一个布尔值，表示请求是否发生过跳转。
			Response.type				属性返回请求的类型
				-	basic：普通请求，即同源请求。
				-	cors：跨域请求。
-	for of循环obj的时候
	-	for(let [key,value] of Object.entries(obj)){console.log(`${key}:${value}`)}
-	response对象还有一个headers属性		**指向一个Headers对象**		对应http回应的所有标头
	headers常用的方法有		**headers.get()**	指定键名		来返回键值
	headers.keys()		遍历header的标头键名
	headers.values()		遍历header的标头键值
	headers.forEach((value,key)=>console.log(key,':',value))			key ':' value形式
-	var response = fetch(url)
	-	获取内容的方法
		-	response.text()		得到**文本字符串**
		-	response.json()		得到**json对象**
		-	response.blob()		得到**二进制文件**
			-	var blobFile = response.blob()
				//二进制文件转换为了图片路径
				var imgSrc = URL.createObject(blobFile)
		-	response.formData()		主要用在**service worker**里面	拦截用户提交的表单
			修改某些数据之后	再提交给服务器
		-	response.arrayBuffer()	主要用于**获取流媒体文件**
			var buffer = await response.arrayBuffer()
			var audioCtx = new Window.AudioContext()
			const source = audioCtx.createBufferSource()
			//流媒体文件解码
			const decodeData = await audioCtx.decodeAudioData(buffer)
-	**Stream 对象只能读取一次，读取完就没了**
-	Response 对象提供Response.clone()方法，创建Response对象的副本，**实现多次读取**。
-	response.body是response对象暴露的底层接口	返回一个readableStream对象	供用户操作
	用来**分块读取数据**		应用之一就是显示下载的速度
	-	var response = await fetch(url)
		const reader = response.body.getReader()		**getReader()API**
		while(true){
			const {done,value} = await reader.read()		//read方法返回的是本次读取的内容块
			if(done){break}
			console.log(`Received ${value.length} bytes`)
		}
	-	const response = await fetch(url,{
		method:'POST',
		headers:{
			"Content-type":"application/x-www-form-urlencoded;charset=UTF-8"
		},
		body:'foo=bar&lorem=ipsum'
	})
	-	这是fetch配置请求的情况样例
	-	body:JSON.stringify(user)		--body提交的是JSON数据
	-	body:new FormData(form)			--body提交的是表单数据
-	fetch配置对象的完整API
	-	const reponse = fetch(url,{
		method:'GET',
		headers:{
			"Content-Type": "text/plain;charset=UTF-8"
		},
		body:undefined,
		referrer:"about:client",
	})
-	**定制http请求**
	-	因为fetch**底层用的是	Request()对象的接口**		参数完全一样	
	-	cache参数的配置
		-	cache:default		默认值	现在**缓存里寻找匹配的请求**
		-	no-store			**直接请求远程服务器**	并且不会更新缓存
		-	reload			**直接请求远程服务器**	并且会更新缓存
		-	no-cache		协商缓存	服务器资源和本地缓存相互比较	有新的版本才会使用服务器资源
							否则使用缓存
		-	force-cache		**缓存优先**	只有在不存在缓存的情况下	才会请求服务器
		-	only-if-cached		**只检查缓存**		如果缓存里面不存在	将返回504错误			
	-	mode的参数配置
		-	cors	默认值		允许跨域请求
		-	same-origin 		只允许同源请求
		-	no-cors			**方法只限于GET POST	HEAD**	并且只能使用几个简单的标头	不能
			添加跨域的复杂标头		**相当于表单所能发出的请求**
	-	credentials	的参数配置	
		-	same-origin		默认值	同源请求时发送cookie	跨域请求时候不会发送cookie
		-	include			无论跨域还是同源		都会发送cookie
		-	omit			一律不会发送cookie
	-	keepalive		用于页面卸载的时候	告诉浏览器在后台保持连接	继续发送数据
		-	一个典型的场景就是	用户离开网页	脚本向服务器提交一些用户行为的统计信息
			这个时候	如果不使用keepalive属性		那么数据可能无法发送	因为浏览器已经把页面卸载了
			const response = await fetch(url,{
				keepalive:true
			})
	-	redirect属性指定http跳转的处理方法	
		-	follow		默认值		fetch()	跟随http跳转
		-	error		如果发生跳转	fetch()会报错
		-	manual		fetch()不会跟随http跳转	**但是response.url会指向新的url**	
						response.redirected属性会变成true	开发者来指定后续的操作
	-	integrity		指定一个哈希值	**检查http回应传回的数据是否等于这个预先设定的哈希值**
		比如下载文件的 时候		**检查文件的SHA-256哈希值是否相等**		确保没有篡改
	-	referrerPolicy		用于设定Referer标头的规则	
		-	no-referrer-when-downgrade	默认值，总是发送Referer标头，**除非从 HTTPS 页面请求 HTTP 资源时不发送。**
		-	no-referrer		不发送referer标头
		-	origin			**referer标头只包含域名**	不包含完整的路径
		-	origin-when-cross-origin		同源请求referer标头包含完整的路径	**跨域请求只会包含域名**
		-	same-origin		跨域请求不发送referer		同源请求发送
		-	strict-origin		**referer标头只包含域名**	https页面请求http资源是不发送referer标头的
		-	strict-origin-when-cross-origin		同源请求发送完整referer路径	跨域请求只会包含域名
			https向http页面请求资源的 时候不发送referer标头
		-	unsafe-url		不管什么情况下	总是发送referer标头
	-	取消fetch请求
		-	fetch请求中途取消需要用到		**AbortController对象**
		-	let controller = new AbortController()
			controller.singal-->来表示请求是否取消		true代表取消了请求		false代表没有取消请求
			controller.abort()		用来取消请求的函数abort()
			调用abort()函数之后		controller的singal属性会变为true		
		-	一秒之后取消请求的例子
			-	let controller = new AbortController()
					singal = controller.singal
					setTimeout(()=>controller.abort(),1000)
					try{
					var response = await fetch(url,{
						singal:controller.singal
					})}catch(err){
						console.log('AbortError',err)
					}
##	水平居中
-	margin:auto			margin: 0 auto
-	position:absolute		父元素position:relative
	left:50%		transform:translateX(-50%)
	left:calc(50% - width/2)		注意calc函数书写的时候需要在计算数据之间预留空格符号
-	div元素	变为行内块元素		display:inline-block		然后相对于自己进行定位
	position:relative			继续执行left属性进行水平定位		left:50%		因为是相对定位
	那么就相对自身进行定位
-	float:left 		可以将元素转为行内块元素		display:inline-block属性也可把元素转为行内块元素
##	service worker
-	本质
	-	服务器和浏览器之间的**中间人角色**	如果网站注册了service worker	那么可以**拦截当前网站的所有请求**
		进行判断		根据请求来判断	如果需要向服务器发起请求	那么就转给服务器	如果需要直接使用缓存
		就使用缓存	**避免了不必要的请求  大大提高浏览体验**
-	细碎定位
	-	基于web worker
	-	在web worker上增加了**离线缓存**的能力
	-	充当服务器和浏览器之间的**代理服务器**
	-	创建有效的离线体验	不常更新的内容缓存在浏览器	提高访问体验
	-	由**事件驱动**	具有生命周期
	-	可以访问cache		indexDB
	-	支持推送
	-	开发者自己管理缓存的内容和版本
-	注意事项
	-	service worker运行于worker上下文		**不能访问DOM**
	-	**设计是异步的**	同步API(XHR localStorage)不能在service worker中使用
	-	其**生命周期和页面是无关联**的		关联页面没有关闭时候	其是可以退出的	
		没有关联页面的时候	其是可以启动的
-	service worker不需要用户打开web页面	不需要其他交互	**异步执行**在一个完全独立的上下文环境
	也就是说service worker有自己的容器	
	不会对主线程造成阻塞	基于service worker可以实现**消息推送	静默更新**	
-	service worker提供一种渐进增强的特性	可以通过service worker来解决应用程序离线工作
	**存储数据在离线时候使用**的问题
-	service worker没有操作DOM的权限	但是可以通过**postMessage**方法来和Web页面通信	让页面操作DOM 
-	service worker可以**劫持连接	伪造和过滤响应**	为了避免这些问题	只能在https的网页上注册
	service workers		防止加载service worker的时候被人篡改
-	**注册** service worker
	-	告诉浏览器注册这个JavaScript文件为service worker，检查service worker API是否可用，如果可用就注册service worker
	-	if ('serviceWorker' in navigator) {
		navigator.serviceWorker.register('/sw.js').then(function(registration) {
			console.log('ServiceWorker registration successful with scope: ',    registration.scope);
		}).catch(function(err) {
			console.log('ServiceWorker registration failed: ', err);
		});
		}
	-	sw.js文件被放在这个域的根目录下，和网站同源。**这个service work将会收到这个域下的所有fetch事件**。
	-	**如果将service worker文件注册为/example/sw.js**，那么，service worker只能收到/example/路径下的fetch事件（例如： /example/page1/, /example/page2/）。
-	**缓存站点的资源**
	-	var cacheName = 'v1';
		var assetsToCache = [
		'/styles/main.css',
		'/script/main.js'
		];

		self.addEventListener('install', function(event) {
		event.waitUntil(
			caches.open(cacheName).then(function(cache) {
			return cache.addAll(assetsToCache);
			}).then(function() {
			return self.skipWaiting();
			})
		);
		});
-	**从缓存中加载**
	-	service worker成功注册，并且用户浏览了另一个页面或者刷新了当前的页面，service worker将开始接收到fetch事件。
	**拦截网络请求并使用缓存，缓存命中，返回缓存资源，否则返回一个实时从网络请求fetch的结果**。
-	缓存版本管理
	-	版本修改的时候会触发activate，**将旧版本的缓存清理掉**
##	block，inline和inlinke-block细节对比
-	block元素会独占一行，多个block元素会各自新起一行。默认情况下，**block元素宽度自动填满其父元素宽度。**
-	**inline元素设置width,height属性无效。**
-	inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right
	都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。
-	block元素可以包含block元素和inline元素；但inline元素只能包含inline元素。
##	伪元素中的content属性
-	<a href="http://www.baidu.com" style="color: red">
	a::after{
    content:attr(href);//或者获取style的属性值content:attr(style)
	}
-	也就是说
	-	attr()可以获取被添加伪元素的元素的**属性值**		然后将获取的值添加到before 或者after位置
-	还有就是**数据布局的排序显示**
	-	h1::before{
		content:counter(biaoti)"."
		}
		h1{
			counter-increment:biaoti
		}
	-	在h1标签的前面来实现一个**累加器的效果**	
		并且为累加器加上一个对应的**属性名称**
		**这样操作之后只是添加	还没有实现的过程**		//相当于声明
		实现的过程还需要加上counter-increment:biaoti	//相当于执行		counter-increment
	-	content:counter(biaoti)"."				//伪元素的类型是一个累加器	累加器的名称是biaoti
		counter-increment:biaoti				//累加器实现的属性		counter-increment
##	PWA		渐进式网页应用
-	谷歌主导的一种新时代网页(应用)
-	**网页可以通过某种方式达到离线使用**
-	牵扯到两个主要文件
	-	manifest.json
		-	和离线的关系不大	是手机应用的关键		让网页具有类似APP的效果
			**比如logo		启动页面**等
			传统网页是没有启动页面的	提高了用户体验
			**用户可以通过添加常用的webapp到桌面	免去应用商店下载的麻烦**
	-	web app manifest是**web应用程序清单**
	-	manifest.json文件的使用
		-	在html文件中直接link		使用的属性是href=""
		-	<link rel="manifest" href="manifest.json">
	-	pwa是只支持https		http://localhost访问的		为了安全考虑
	-	manifest的具体配置		json文件
		-	name			属性来配置应用的名称
		-	short_name		应用的短名称
		-	icons			应用不同设备的图标
		-	display			web app 的显示模式
			-	fullscreen			应用会全屏配置
			-	standalone			应用的推荐配置	顶部不会遮盖	会有设备自己的信息
			-	minimal-ui			应用看起来像一个应用	但是会有浏览器地址
-	应用场景
	-	脱机游戏	有幸依赖于**Canvas和WebGL**的快速发展，现在**纯js**写出的游戏，不单单浏览器可以运行，并且可以**无缝打包到各个平台运行**，其性能相当不错
	-	加速响应
		以前资源的缓存需要前后端协调，重头戏在后端。现在就可以把**缓存相关的东西，重点放在前端**，前端每次更新自己当然知道什么资源需要更新
	-	应用市场
		臭名昭著的巨硬，在去年还是今年年初来着，正式在win10的应用市场中，**支持PWA应用**

		PC网页版
		手机网页版
		微信网页版（比如公众号）
-	一个 PWA 应用**首先是一个网页**, 可以通过 Web 技术编写出一个网页应用. 随后添加上 **App Manifest** 和 **Service Worker** 来实现 PWA 的**安装和离线**等功能
-	http-server的**全局安装**来运行pwa程序
	-	npm install http-server -g
-	pwa必备条件
	-	https服务器		或者	localhost
	-	manifest.json		应用程序清单
	-	service worker		离线缓存		离线访问体验提升
-	web worker
	-	js单线程	同一个时间只会做一件事
	-	处理复杂耗时任务	处理复杂运算
	-	是一个独立的进程	不能操作DOM BOM		适合大量的运算
	-	worker并**没有阻碍主线程的运行**	**什么时候算完就直接发消息	主线程来接收消息**
	-	主线程可以给web worker发消息		web worker也可给主线程发消息
	-	两边的发送消息	接收消息的 功能函数大同小异
		-	self.postMessage({total:total})
		-	worker.addEventListener('message',e=>{console.log(e.data)})
		-	worker.postMessage()
		-	self.addEventListener('message',e=>{})
		-	work.js文件里面书写的是self来代表消息主体
	-	缺点
		-	不能操作缓存		会重复计算
-	那么service worker的优点就体现出来了
	-	service worker可以操作**cacheStorage**
	-	类似于**代理服务器**
	-	拦截请求响应
	-	一旦被安装	永久存在	除非手动卸载
	-	异步实现	**内部大都是promise实现**
-	**service worker是navigator对象上面的一个属性**
	-	**在window.onload里面去注册service worker**
	-	防止和其他资源竞争
	-	注册service worker **返回的是一个promise对象**
		-	navigator.serviceWorker.register('./sw.js')
		-	window.onload = function(){
			if('serviceWorker' in  navigator){
				navigator.serviceWorker.register('./sw.js')
				.then(resitration=>{console.log(resitration)})
				.catch(err=>{console.log(err)})
			}
		}
	-	service worker最重要要做的东西是**缓存		和网络请求**
-	self是表示当前的意思
-	serviceWorker 的生命周期事件
	-	install事件会在servive worker注册成功的时候触发			主要用于**缓存资源**
	-	activate是service worker注册之后的激活事件		主要是来**删除旧的资源**
	-	fetch	事件会在发送请求的 时候触发		主要用于**操作缓存	或者读取网络资源**
-	service worker里面生命周期包含的情况
	-	当service worker已经成功注册的时候		**再次刷新页面的时候	是不会再次触发install activate事件的**
	-	**sw.js文件发生改变的时候**		install事件是会再次触发的	只执行了install事件
		activate事件是不会触发的		就是说不会再次激活		激活只有一次
	-	因为activate事件是不会激活新的sw.js文件的		一个方法是需要**手动跳过等待前面一个**
		这样才能成功当前的更新的service worker激活		**activate默认是要等待前面一个service worker失活**	才会激活
	-	**还有一个方法是self.skipWaiting()方法来跳过等待**  返回一个promise 对象
		直接进入一个更新之后的service worker的激活		就是**每一次的sw.js文件的更新**
		就触发service worker的install activate事件 的触发
	-	event.waitUntil()会接收一个promise对象	在promsie结束之后才会结束当前的生命周期函数
		**防止浏览器异步操作之前就结束了生命周期**		event.watiUntil(self.skipWaiting())
		等待skipwaiting结束		也就是promise结束		才会进入activate	 
	-	service worker激活之后	会在下一次刷新页面的时候生效	可以通过self.clients.claim()来
		立即获取控制权
##	async await
-	await后面跟一个promsie对象		不是promise对象就会直接返回值
-	await会阻塞async函数的执行
-	await后面的 promise 如果没有成功	那么会抛出异常	使用try catch finally的方法
-	fetch			API
	-	service worker里面只能使用fetch API
-	cache storage
	-	**cacheStorage表示Cache对象的存储**		配合service worker来实现资源的缓存
	-	cache api类似于数据库的操作
		-	caches.open(cacheName).then(function(cache){})		用来打开缓存	返回一个匹配
			cacheName对象的promsie对象	类似于连接数据库
		-	caches.keys()	返回一个	promise对象		包括所有缓存的 key
		-	caches.delete(key)	根据key删除对应的缓存	
	-	cache对象常用的方法
		-	cache接口是缓存request		response对象提供的	存储机制
		-	cache.put(req,res)		把请求当key		把请求的响应存储起来
		-	cache.add(url)		根据url发起请求		**并且把响应结果缓存起来**
		-	cache.addAll(urls)		抓取一个请求数组		并且把结果存储起来
		-	cache.match(req)		获取req对应的response
	-	遇到的问题
		-	cache.addAll(['/'])			**存入的localhost文件直接写入斜杠就可代表**
			但是存储的时候写为了/index.html			出错
			还有就是没有加上await关键字		出错
-	notification		api
-	notification	的**通知接口是向用户配置和显示桌面通知**
	-	notification.permission可以获取当前用户的授权情况
		-	default		默认的	未授权的
		-	denied		用户拒绝	**无法再次请求授权	无法弹窗提醒**
		-	granted		授权的		可以弹窗提醒
	-	notification.requestPermission()请求用户的授权		允许  或者	禁止
	-	new Notification("title",{body:"",icon:""})		可以显示通知
	-	navigator.onLine	返回的是onLine属性		返回的是**用户有没有联网**
##	缓存策略
-	静态资源	缓存优先
-	动态更新资源		网络优先
-	如果service worker缓存了错误的资源	那么web应用会有灾难性的结果		我们需要检查网络是否返回准确	
	-	返回的状态码200		**避免缓存304	404	50x等结果**
	-	响应的类型是basic 	或者	cros	即只缓存同源	或者正确的跨域请求	避免缓存错误响应和
		不正确 的跨域请求
##	微前端
-	类似于一种微服务架构	**微服务的理念应用于浏览器端**		将Web应用由单一的单体应用转变为多个小型
	前端应用**聚合一体**的应用			**各个微小的前端应用可以独立维护	开发	部署**
	**微前端不是单纯的前端框架或者工具	而是一套架构体系**
-	微前端**适用的场景	和解决的技术痛点**
	-	拆分和细化
		-	单页面应用是流行的项目形态之一	但是随着时间的推移	应用功能更加丰富	单页面应用变得庞大
			并且难以维护	开发成本越来越高	**微前端的意义是将庞大的应用拆分**	随之解耦
				每个部分可以单独进行维护和部署
	-	整合历史系统
		-	历史项目所用的老的框架	**旧的系统需要结合到新的框架使用还不能抛弃**	没有必要浪费时间
			重写旧的逻辑	微前端可以将系统进行整合	基本不修改逻辑的同时兼容新老系统并行运行
-	实现微前端的方案
	-	nginx路由转发
		-	通过**nginx配置反向代理**来实现不同路径映射到不同应用	不属于前端的改造	而是运维的配置
	-	iframe嵌套
		-	父应用单独是一个页面	每个子应用嵌套一个iframe	父子之间通信可以使用postMessage
			但是兼容性差
	-	**web components**
		-	<template>样式里面的:host伪类，指代自定义元素本身。
	-	不希望用户能够看到<user-card>的内部代码，Web Component **允许内部代码隐藏起来，这叫做 Shadow DOM**，即这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部。
	-	 var shadow = this.attachShadow( { mode: 'closed' } );
	-	this.attachShadow()方法的参数{ mode: 'closed' }，表示 **Shadow DOM 是封闭的，不允许外部访问**。
	-	**template中获取伪子元素的方法**
		-	var getTemplate = document.getElementById('temId')
			var getTemBtn = getTemplate.content.getElementById('btnId')
			-	**亲测不能addEventListener**		
	-	每个子应用拥有独立的script	css		可以独立部署		历史系统改变成本高
	 	子应用通信复杂
	-	原生js自定义组件		需要使用tempalte		继承HTMLElement
		-	class UserId extends HTMLElement{
			//自定义组件的构造函数
			constructor(){
				super()
				var shadow = this.attachShadow({mode:"closed"})
				var getTem = document.getElementById('temId')
				//复制template里面的全部节点元素
				var cloneTem = getTem.content.cloneNode(true)
				//this代表的是自定义的组件		自定义组件上面可以传入一些属性来完成组件的代码简洁清晰
				//template里面的img标签设置自定义组件传入的参数	进行页面渲染
				cloneTem.getElementById('imgId').setAttribute('src',this.getAttribute('image'))
				//...
				shadow.appendChild(cloneTem)
			}	
		}
		//自定义的组件需要注册在普通元素里面		进行一个关联的作用	不然是无法使用的
		window.customElements.define('user-id',UserId)
	-	自定义(class UserId extends HTMLElement)
	-	构造函数
	-	关闭和外界的来往	this.attachShadow({mode:"closed"})
	-	shadow.appenChild(cloneTem)
	-	和window产生关联		window.customElements.define('user-id',UserId)
	-	可以使用js和template封装为一个js文件	成为独立的组件文件	网页加载这个脚本才能使用这个组件
	-	template			+			js
-	**组合式应用路由转发**
	-	每个子应用独立构建和部署	**运行时由父应用来进行路由管理**	应用加载	启动 卸载和通信机制
	-	一个基座（MainApp）应用和若干个微（MicroApp）应用	
	-	基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问
	-	基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的
-	**微前端的路由分发**
	-	作为微前端的基座应用，是整个应用的入口，**负责承载当前微应用的展示和对其他路由微应用的转发，**
	-	作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要**远程拉取机制**
	-	远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并**将CSS和HTML内容append到基座应用中留给微应用的展示区域**，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程
	-	流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染
-	**对于路由分发而言，以采用vue-router开发的基座SPA应用**
	-	当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。
	-	**最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用**，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收	
-	**微前端的应用隔离**
	-	CSS隔离：当主应用和微应用同屏渲染时，就**可能会有一些样式会相互污染**，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个**微应用模块以特定前缀**，即可保证不会互相干扰，**可以采用webpack的postcss插件，在打包时添加特定的前缀**。
	-	JavaScript隔离	每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外	沙箱机制的核心是让**局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象**
-	微前端的消息通信
	-	要让**多个分离的微应用之间要做到通信**，本质上仍离不开中间媒介或者说全局对象
	-	**在基座应用中会定义事件中心Event**，每个微应用分别来注册事件，当被触发事件时再由事件中心统一分发，这就构成了基本的通信机制
-	微前端有哪些框架
	-	Mooa：基于Angular的微前端服务框架
	-	Single-Spa：最早的微前端框架，兼容多种前端技术栈。
	-	Qiankun：基于Single-Spa，阿里系开源微前端框架。
	-	Icestark：阿里飞冰微前端框架，兼容多种前端技术栈。
	-	Ara Framework：由服务端渲染延伸出的微前端框架。
##	rmf异步
-	因为请求数据是需要时间去请求的		那么这个时候使用异步的操作不会影响主程序的执行
	等到数据请求成功	程序还是可以正常执行		这就是请求数据使用异步方法的原因	
-	js最初是处理表单验证和DOM操作而被创造出来的		所有js使用了简单的单线程模式
	多线程模式更加复杂	比如处理**线程之间资源共享的问题	还需要解决状态同步的问题**
-	常见的异步模式
	-	回调函数
	-	事件监听
	-	发布/订阅模式
	-	promise
	-	generator		yield
	-	async  await
-	promise.resolve().then()	**在宏任务中会立即执行**		宏任务中的微任务会立即执行
-	回调函数来处理异步		callbacks
	-	function myAsync(callback){
		setTimeout(()=>{
			console.log('async')
			callback()
			//另一种执行顺序callback();console.log('async')
		})}
		function mySync(){
			console.log('sync')
		}
		myAsync(mySync)
	-	**一个函数里的参数是一个回调函数callback**		
	-	**里面可以调整执行语句的顺序**		
-	事件监听
	-	异步任务执行不取决代码的顺序	而是取决于，某个事件是否发生
		-	**异步callback** 就是addEventListener()**第二个参数**
		-	回调函数作为一个参数传递给另一个函数时，**仅仅是把回调函数定义作为参数传递过去** — 回调函数并没有立刻执行，回调函数会在包含它的函数的**某个地方异步执行**，包含函数负责在**合适的时候执行回调函数**。
	-	回调函数用途广泛 — 他们不仅仅可以用来**控制函数的执行顺序和函数之间的数据传递**，还可以根据环境的不同，将数据传递给不同的函数，
-	通常会使用 **worker 在主线程之外运行昂贵的进程，以便不会阻止用户交互**	一个主要的问题是他们**无法访问DOM**	**基本上可以只做数字运算**。
-	requestAnimationFrame()在浏览器**下一次重绘显示之前**执行指定的代码块，允许动画以合适的帧率运行，而不管它在什么环境中运行。
	-	function draw() {
		requestAnimationFrame(draw);
		}
		draw();
	-	cancelAnimationFrame()
-	setTimeout(fn, 0)一旦堆栈为空，**类似的代码就会执行**
	-	setTimeout(()=>{console.log('3')},3000);setTimeout(()=>{console.log('1')},1000)
	-	//1  3
	-	不会等待前面一个setTimeout	setTimeout是异步非阻塞的	函数动作的执行是在3秒1秒之后执行
-	a标签的#默认是到达顶部		<a href='#'>top</a>


-	发布/订阅模式
	-	又称为观察者模式
-	虽然现在的网络很快。这意味着下面的伪代码可能不能正常工作
	-	var response = fetch('myImage.png');
		var blob = response.blob();
	-	因为你**不知道下载图片会多久**，所以**第二行代码执行的时候可能报错**（可能间歇的，也可能每次）因为图像还没有就绪。取代的方法就是，**代码必须等到 response 返回才能继续往下执行**
-	
##	fn()
-	var a = fn		//拿到的是fn的字面代码		
	var a = fn()		//拿到的是fn的执行结果
-	function taskAsync = function(){
	var result = setTimeout(function(){
	console.log('异步任务的结果')
	}, 3000)
	return result
	}

	var result = taskAsync() // result 不是异步任务的结果，而**是一个 timer id**
-	异步意味这**不等待任务结束**	
	-	如果**同步任务计算十分耗时**那么异步任务是会延时的
##	geolocation对象
-	获取用户地理位置
##	ajax请求是浏览器网络请求模块组成的		
##	const
-	const arr = []			//const不是定义常量数组	而是**定义常量引用**
-	一个函数里面包含一个setTimeout()		setTimeout(fn,1000)
	setTimeout里面调用了这个函数		那么调用这个函数的时候相当于执行了一个setInterval函数
-	
##	indexedDB
-	大量数据储存在客户端，这样可以**减少从服务器获取数据**，直接从本地获取数据。
-	IndexedDB 就是**浏览器提供的本地数据库**，它可以被网页脚本创建和操作
-	IndexedDB 允许储存大量数据，提供查找接口，还能建立索引
-	IndexedDB **不属于关系型数据库（不支持 SQL 查询语句）**
-	IndexedDB的特点
	-	**键值对储存**。 IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误
	-	**异步。** IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
	-	**支持事务**。 IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，**只要有一步失败，整个事务就都取消**，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
	-	**同源限制 IndexedDB 受到同源限制**，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
	-	储存空间大 IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限
	-	支持二进制储存。 IndexedDB 不仅可以储存字符串，**还可以储存二进制数据**（ArrayBuffer 对象和 Blob 对象）。
	
##	原生操作cookie
-	cookie 参数配置
	-	path		默认是当前文档目录
	-	domain		cookie的作用域名	不同的域名会有不同的cookie
	-	max-age		cookie存在的时长		单位是秒
	-	expires		存活的截至时间
	-	secure		通过https传输
-	cookie是不可跨域的
##	js性能
-	循环每迭代一次，**循环中的每条语句**，包括 for 语句，都会被执行。
-	**能够放在循环之外的语句或赋值会使循环运行得更快**。
-	**与其他 JavaScript 相比，访问 HTML DOM 非常缓慢。**
	var myDom1 = document.getElementById('domId')
	假如您期望访问某个 DOM 元素若干次，那么只访问一次，并把它作为本地变量来使用：
-	**缩减 DOM 规模**
	请尽量保持 HTML DOM 中较少的元素数量。
-	**避免不必要的变量**
	请不要创建不打算存储值的新变量。
	var fullName = firstName + " " + lastName;
	document.getElementById("demo").innerHTML = fullName; 
	document.getElementById("demo").innerHTML = firstName + " " + lastName//更加优秀
-	**延迟 JavaScript 加载**
	请把脚本放在页面底部，使浏览器首先加载页面。
	一个选项是在 script 标签中使用 defer="true"。defer 属性规定了脚本应该在**页面完成解析后执行**，但它只**适用于外部脚本**。
##	AJAX
-	ajax是组合了浏览器内建的xhr		js     htmlDOM
-	**从web 服务器获取数据来异步更新网页		可以更新网页的一部分		而不是重新加载整个页面**
-	对于PUT、DELETE以及其他类型如application/json的POST请求，**在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受**
	-	服务器必须响应并明确指出允许的Method
	-	**浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method**，才会继续发送AJAX，否则，抛出一个错误。
	-	返回的数据格式可以是字符串responseText		或者XML格式的数据responseXML
##	js严格模式
-	声明严格模式
	-	**脚本或者函数的开头**		"use strict"	
	-	可以只在特定函数内部声明严格模式		"use strict"
		-	function fn(){"use strict";...}
-	严格模式语法
	-	为了**兼容更早版本的js**
-	**为什么使用严格模式**
	-	js代码更加安全
-	普通模式
	-	普通模式		会有**全局变量意外产生**		但是严格模式会报错
	-	普通模式		**向不可写属性赋值**		开发者没有反馈
-	严格模式
	-	严格模式		**向不存在	不可写变量赋值**	会抛出错误
	-	严格模式		**删除变量或者对象是不允许的**			delete x			delete obj
	-	删除函数是不允许		delete fn
	-	**函数中的重复参数名报错**		**八进制文本报错**		var x = 010
	-	**转义字符是不允许的**
	-	**arguments是不可作为参数的**		**with语句是不允许的**
-	arguments	在函数的应用中代表参数列表	是以参数数组的形式生成的 [args1,args2,args3]	
-	获取参数的时候记得辨识 fn([1,2])		[1,2]获取的方式是二维数组的方式	arguments[0][0] arguments[0][1]
##	nodelist对象
-	从文档中提取的**节点列表**
-	NodeList   HTMLCollection
-	所有浏览器会为childNodes属性返回NodeList 对象
-	**大多数浏览**器会为querySelectorAll()返回NodeList 对象
-	NodeList 中的元素**可通过索引号进行访问。**
-	NodeList 对象与 HTMLCollection **对象几乎相同**。
-	HTMLCollection 与 NodeList 的**区别**
	-	HTMLCollection（前一章）是 **HTML 元素的集合**。NodeList 是**文档节点的集合**。
	-	HTMLCollection 和 NodeList 对象都是**类数组的对象列表**（集合）
	-	无法对节点列表使用数组方法，比如 **valueOf()、push()、pop() 或 join()。**
##	nodelist htmlcollection区别
-	节点类型
-	NodeList
	一个节点的集合，**既可以包含元素和其他节点(注释节点、文本节点等)**。
	NodeList对象是由**childNodes属性，querySelectorAll方法**返回的一组节点的集合，它保存着一组**有序的节点**。注意区别的是，由childNodes属性返回的NodeList对象是一个**动态的集合**（live collection）， 而由**querySelectorAll方法返回的则是一个静态的集合**（static collection）
	**NodeList的元素是Node,**

	-	**元素作为nodelist列表中元素返回的时候**
		<div>
		<!-- Comment -->
		<p>This is Some Text</p>
		</div>

		一个<div>和注释间的断行和空格（或tab）作为text node（没错，标签之间的空白符号也可以被解析为text node）
		注释作为comment node
		注释和<p>之间的断行和空格（或tab）作为text node
		p作为element
		</p>和</div>之间的断行和空格（或tab）作为text node
	-	这就是node 和element的区别
	-	如果是HTMLCollection	**只有<p>这一个元素**，这也是比较符合大多数人直觉的结果
	-	**NodeList对象有个length属性和item()方法**
		-	item()可以传入一个**索引**来访问Nodelist中相应索引的元素。
	-	NodeList对象的一大特点是它返回的内容是**动态的（live）**



-	HTMLCollection
	元素集合, 只有Element	包含一组**有序（in document order基于文档结构顺序）的动态集合**。
	**HTMLCollection的元素是Element**
	**Element继承自Node，是Node的一种**
	**Node作为父类，除了Element还有一些其他子类**，比如HTML元素内的文本对应的**Text**，文档对应的**Document**，注释对应的**Comment**
	**HTMLCollection里，只有Element，而NodeList里可以有Element、Text、Comment等多种元素**
-	NamedNodeMap
	-	获取元素上的attributes属性		其返回值是NamedNodeMap
	-	document.getElementById('Id').attributes		-->返回的是NamedNodeMap对象
	-	与NodeList相同的是它也是一个**动态的集合**（live collection），与NodeList不同的是，NamedNodeMap中保存的是一组**无序的属性节点的集合**。
-	在**获取原生DOM元素的时候，主要涉及这几个DOM API**
	-	 Node及对应集合NodeList
	-	 Element（继承Node）及对应集合HTMLCollection
	-	 Document(继承Node)
	-	**计划取代NodeList和HTMLCollection的Elements目前并无广泛实现**
-	使用方法
	-	<div>
		<!-- Comment -->
		<p>This is Some Text</p>
		<img name="test" src="test.jpg">
		</div>
	-	**假设得到了这个div的子元素构成的HTMLCollection**，叫做list，那么使用list.namedItem("test")就可以直接得到里面的img元素。
	-	namedItem('name')		**这个api来获取元素**	
		-	可以返回集合中**name属性和id属性**值得元素
	-	**也可以通过elements.item()传入元素索引来访问**
	-	HTMLDocument 接口的**许多属性都是 HTMLCollection 对象**
		-	document.images.namedItem('image1')
		-	**images这个api**返回的是HTMLCollection对象
-	这**两个类都是“live”的。对其中元素进行操作，会实时反映到DOM中**
-	**item和namedItem都可以通过[]的缩写进行调用**，有的浏览器还支持用()的缩写进行调用
-	HTMLCollection的集合和NodeList对象一样也是动态的，**他们获取的都是节点或元素集合的一个引用**。
-	我们有时要**迭代一个NodeList或HTMLCollection对象**的时候，我们通常会选择生成当前对象的一个**快照或静态副本**
	-	var staticLists = Array.prototype.slice.call(nodeListorHtmlCollection, 0)
	-	slice函数的使用		快照和静态副本的生成
##	废除对象的所有引用时要当心。如果一个对象有两个或更多引用，则要正确废除该对象，必须将其所有引用都设置为 null。
##	早绑定和晚绑定
-	所谓绑定（binding），即把**对象的接口与对象实例结合在一起的方法**
	-	早绑定（early binding）是指在**实例化对象之前定义它的属性和方法**，这样编译器或解释程序就能够提前转换机器代码			**ECMAScript 不是强类型语言，所以不支持早绑定**
	-	晚绑定（late binding）指的是**编译器或解释程序在运行前**，不知道对象的类型。使用晚绑定，**无需检查对象的类型，只需检查对象是否支持属性和方法即可**。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。
##	ECMAScript 对象类型
-	一般来说，可以创建并使用的对象有三种：**本地对象、内置对象和宿主对象**。
	-	ECMA-262 把**本地对象**（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 **ECMA-262 定义的类**（引用类型）。它们包括
	-	根据定义，**每个内置对象都是本地对象**
		由 ECMAScript 实现**提供的、独立于宿主环境的所有对象**，在 ECMAScript 程序开始执行时出现”。这意味着**开发者不必明确实例化内置对象，它已被实例化了**
		-	Global对象
			-	全局属性和全局函数
				-	Infinity		NaN			undefined
				-	encodeURIComponent()		decodeURIComponent()
					isNaN() 	parseInt()		parseFloat()...
			-	**全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象**。
			-	全局对象就是 **Window 对象**
	-	所有 BOM 和 DOM 对象都是宿主对象。	所有非本地对象都是宿主对象（host object）
	-	**全局对象的预定义属性都是不可枚举的**

-	**全局环境的fn输出this是window**
	**对象环境输出的this是对象**
-	js对象的**可枚举性**
	-	Object.keys(obj)		不包含不可枚举的属性
	-	Object.getOwnPropertyNames(obj)			包含不可枚举的属性
	-	for in循环**包含了对象继承自原型对象的属性**		Father.prototype.parameter
		-	但是Object.keys(obj)		是**不包含原型上面的属性的**
-	构造函数中的属性		使用的是this指针来初始化属性
##	ECMAScript 对象作用域
-	ECMAScript 只有公用作用域
-	由于**缺少私有作用域**，开发者确定了一个**规约**，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线
	-	下划线并**不改变属性是公用属性的事实**，它只是告诉其他开发者，应该把该属性看作私有的。
	-	静态作用域**定义的属性和方法任何时候都能从同一位置访问。**
	-	**构造函数只是函数。函数是对象，对象可以有属性和方法。**
##	rmfpromise
-	Promise 也**还是使用回调函**数，只不过是把**回调封装在了内部**，使用上一直通过 **then 方法的链式调用**，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。
##	excution函数
-	执行上下文就是代码的**执行环境或者作用域**
-	**全局上下文有且只有一个**，程序中其他任意的上下文都可以访问全局上下文。
-	当一个浏览器第一次load你的代码的时候，**首先它会进入到一个全局执行上下文中**。如果在你的全局代码中，你**调用了一个函数，那么程序的执行流程会进入到被调用的函数中，并创建一个新的执行上下文，并将这个上下文推入到执行栈顶**
	-	如果在**当前的函数中，你又调用了一个函数，那么也会执行同样的操作。执行流程计入到刚被调用的函数内部，重新创建一个新的执行上下文，并再次推入到执行栈顶**。浏览器会一直执行当前栈顶的执行上下文，一旦函数执行完毕，该上下文就会被推出执行栈
-	**一个执行上下文从概念上可以视为一个包含三个property的Object**
	-	创建作用域链.
	-	创建变量，函数和参数
	-	决定"this"的值
-	在**创建阶段除了形参参数进行了定义和赋值外**，**其他只定义了property的名称，并没有赋值**。一旦创建阶段完成，执行流程就进入到函数内部进入激活/代码执行阶段
-	**创建阶段**的上下文
	-	fooExecutionContext = {
		scopeChain:{...},//作用域链
		variableObject:{
			...//创建变量	函数参数
		},
		this:{...}
		}
-	**执行上下文分类**
	-	只有一个全局执行上下文。
	-	函数执行上下文环境。
	-	Eval Execution Context Eval 执行上下文	**eval 函数执行代码的时候，会新建一个 eval 执行上下文**。
##	赋值号和判断相等号混淆
-	promise代码出错		耗费3小时
##	this指针		严格模式			非严格模式
-	函数
	-	函数作为**普通函数在全局环境使用**			this指针指向**全局函数window**
	-	函数作为**对象的方法调用**					this指针指向的是**对象**
		-	var obj = {}
				obj.a = 1
				function test(){console.log(this.a)}
				obj.m = test	//拿取的是函数的定义
				obj.m()		//1
	-	函数作为**构造函数调用**		指向构造的对象
	-	apply改变this指针		不改变箭头函数的指针
-	一般情况下，**this代指的是调用它的那个对象**（闭包和箭头函数除外，稍后讲解）
-	对象的方法执行是一个定时器的执行	定时器中的回调函数使用普通函数书写		那么this指针指向的是window
	回调函数使用箭头函数书写	那么this指向的是当前对象
	或者普通函数使用bind函数来改变普通函数的this指向性问题
	function xiaosan(){}.bind(this)
-	箭头函数不会创建自己的this，只会从**作用域链的上一层继承this**	当前层是obj
	这里的作用域上一层为window对象，所以，this指向了window。
	let obj = {
    getName: () => {
      console.log(this === obj) // false
    },
    getAge: function () {
      console.log(this === obj) // true
    }
    }
-	对象中的普通函数的this指针指向的是对象本身			箭头函数的this指向是window对象
	-	对象函数里面有一个定时器		定时器的回调函数是箭头函数		this指针的指向是上面一层
		当前层是当前函数作用域		那么上面一层就是对象作用域
	-	**函数在对象中是作为属性看待的**		this指针指向的是当前对象
-	匿名函数自调用的this指向的是window
	里面可以缓存其他环境的this
	-	**匿名函数来模拟块级作用域**
		function fn(){
		(function(){
			var la="啦啦啦！";
		})();
		console.log(la);//报错---la is not defined
		}
		fn();
		-	**减少全局变量**
		-	执行完匿名函数，**存储在内存中相对应的变量会被销毁，从而节省内存**
	-	var obj = {}
		(function(){
			var fn1 = function(){}
			var fn2 = function(){}
			obj.fn1 = fn1
			obj.fn2 = fn2
		})
		fn1	fn2是局部变量	但是全局变量可以取出局部变量供自己使用	使用的返回的取用的对象本身
		这样全局变量中是没有fn1	fn2	减少了全局变量的使用	
		**类似于一个局部仓库		其他对象可以取出自己想要的属性或者方法	只提供给取出的对象使用**
	-	通过**优先表达式**(**圆括号**)的方式 , 由于**Javascript执行表达式是从圆括号里面到外面**，所以可以用圆括号强制执行声明的函数
	-	用**void操作符**去执行一个没有用圆括号包围的一个单独操作数
		-	void function(){cosole.log('void')}()
	-	当 调用 People();时 this 输出为 Window对象		**People函数的环境是window环境**
		但一旦调用new People('xx')时, this 输出为 {name:'xx'}
		其实也很好理解,**一旦new ,便新建了一个对象**		new 操作符会新建一个对象	
		那么**window环境变为了新的对象环境**

-	**闭包允许内层函数引用父函数中的变量**，但是该变量是**最终值**	
-	-function(x,y){ 
    alert(x+y); 
    return x+y; 
	}(3,4); 
	//-7
	~function(x, y) { 
    alert(x+y); 
	return x+y; 
	}(3, 4);
	//-8
-	js概念
	-	JavaScript一种**直译式脚本语言**，是一种**动态类型、弱类型、基于原型**的语言，**内置支持类型**。**它的解释器被称为JavaScript引擎**，为浏览器的一部分，**广泛用于客户端的脚本语言**，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。
-	JavaScript及其特点
	-	JavaScript是一种**基于对象(Object)和事件驱动(EventDriven)**并具有安全性能的脚本语言。**使用它的目的是与HTML超文本标记语言**、Java脚本语言（Java小程序）**一起实现在一个Web页面中连接多个对象**，与Web客户交互作用。从而可以开发客户端的应用程序等。它是通过嵌入或调入到标准的HTML语言中实现的。它的出现弥补了HTML语言的缺陷，
	-	JavaScript特点之一它是一种安全性语言，它**不允许访问本地的硬盘**，**并不能将数据存入到服务器上**，**不允许对网络文档进行修改和删除**，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失。
	-	**JavaScript是依赖于浏览器本身，与操作环境无关**，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可正确执行
##	js设计模式
-	策略模式**定义了一系列算法**，从概念上来说，所有的这些算法都是做相同的事情，只是实现不同，他可以以相同的方式调用所有的方法，**减少了各种算法类与使用算法类之间的耦合**。
	-	单独定义算法类，也**方便了单元测试**
	-	**不仅可以封装算法，也可以用来封装几乎任何类型的规则**，是要在分析过程中需要在不同时间应用不同的业务规则
-	装饰者模式是**为已有功能动态地添加更多功能的一种方式**，**把每个要装饰的功能放在单独的函数**里，**然后用该函数包装所要装饰的已有函数对象**，因此，当需要**执行特殊行为**的时候，调用代码就可以根据需要**有选择地、按顺序地使用装饰功能来包装对象**。优点是**把类（函数）的核心职责和装饰功能区分开了**。
	-	tree.RedBalls = function () {
		this.decorate = function () {
			this.RedBalls.prototype.decorate(); 
			console.log('Put on some red balls');
			}
		};
	-	为了RedBalls装饰了一个函数	**添加了RedBalls自身独特的代码**		并且调用了原有的装饰器
-	var $ = function (id) {
    return document.getElementById(id);
	};//自定义一个选择器	表示一个函数	传参是传递的id参数
-	所谓的工厂模式，是指**可以返回一个对象的方法**
	-	Object就是一个工厂，**根据参数不同会构造出不同的对象**
		-	var obj = Object(), 
				num = Object(1), 
				str = Object('s'), 
				boo = Object(false); 
	-	与构造函数方式写一个类的区别在于**没有使用this**，而是**每次都构造一个空对象**，然后给其添加属性。创建对象方式不是使用new，而是使用函数调用方式
		-	Person(name, age) { 
			var obj = {} 
			obj.name = name 
			obj.age = age 
			return obj 
			} 
			var p1 = Person('jack', 25) 
			var p2 = Person('lily', 22) 
-	观察者模式(Observer)
	-	有一个观察者可以管理所有的目标，等到有**状态发生改变的时候发出通知**。
-	单例模式(Singleton)
	-	保证**一个类仅有一个实例**，并提供一个访问它的全局访问点
	-	**有一些对象我们往往只需要一个**，比如线程池、全局缓存、浏览器的window对象
-	优势
	-	可以用它来划分命名空间
	-	借助单例模式，可以把**代码组织的更为一致**，方便阅读与维护
	-	防止其它来源代码的修改
		-	可以**定义一个包含自己所有代码的对象**。
-	**如果某些变量需要保护，那么可以将其定义在闭包中。**
-	最简单的单例其实就是**一个对象字面量。它把一批有一定关联的方法和属性组织在一起**
-	由于**单例模式提供的是一种单点访问**，所以它有**可能导致模块间的强耦合**。因此也就不利于单元测试了。
综上，单例还是留给定义命名空间和实现分支型方法这些用途
##	js引擎
-	在**JavaScript引擎运行脚本期间**,浏览器渲染线程都是处于挂起状态的,也就是说被”冻结”了. 
所以,**在脚本中执行对界面进行更新操作**,如添加结点,删除结点或改变结点的外观等**更新并不会立即体现出来**,这些操作将保存在一个队列中,待JavaScript引擎空闲时才有机会渲染出来. 
-	**JavaScript脚本的执行不影响html元素事件的触发**,在t1时间段内,首先是用户点击了一个鼠标键,点击**被浏览器事件触发线程捕捉**后形成一个鼠标点击事件,由图可知,对于JavaScript引擎线程来说,这**事件是由其它线程异步传到任务队列尾**的,由于引擎正在处理t1时的任务,这个**鼠标点击事件正在等待处理**. 
-	**xhr请求确实是异步**的,不过**这请求是由浏览器新开一个线程请求**(参见上图),当请求的**状态变更**时,如果先前已设置回调,这异步线程就**产生状态变更事件**放到JavaScript引擎的**处理队列中等待处理**,当任务被处理时,JavaScript引擎始终是**单线程运行回调函数**
##	rmfthis
-	var obj = {
    fun:function(){
       console.log(this) ;
    }}
	setTimeout(obj.fun,1000);      // this指向window对象
	-	**setInterval(obj.fun,1000)** 的第一个参数是obj对象的fun ，因为 JS 中函数可以被当做**值来做引用传递**，实际就是将这个**函数的地址当做参数**传递给了 setInterval 方法，换句话说就是 setInterval 的第一参数接受了一个函数，那么此时1000毫秒后，函数的运行就已经是在window对象下了，也就是函数的调用者已经变成了window对象，所以其中的this则指向的全局window对象；
	-	setInterval		setTimeout使用**函数的引用**		this指向了window对象	
	-	**setInterval('obj.fun()',1000)** 中的第一个参数，实际则是传入的一段可执行的 JS 代码；1000毫秒后当 JS 引擎来执行这段代码时，则是通过 obj 对象来找到 fun 函数并调用执行，那么函数的运行环境依然在 对象 obj 内，所以函数内部的this也就指向了 obj 对象
	-	使用引号		和		不使用引号调用函数的区别
		-	不使用引号	调用的是地址	得到当前环境下执行内容	
		-	使用引号	得到原环境执行内容
	-	学习setTimeout		setInterval执行函数的新的方式		**加引号执行需要执行的函数**
		函数的执行环境	是原来函数的执行环境	加引号执行函数的时候	函数需要加上括号执行
		-	setTimeout('fn()',time)		setInterval('fn()',time)
##	刷新页面
-	history.go(0) 
-	location.reload() 
-	window.navigate(location) 
-	location.replace(location)
-	document.URL=location.href
-	关闭窗口时刷新或者想开窗时刷新
	-	<body onload="opener.location.reload()">//开启窗口时候刷新页面
		-	window.opener.document.location.reload()
	-	<body onUnload="opener.location.reload()">//关闭窗口时候刷新页面
##	isNaN
-	NaN当算术运算导致产生值 **未定义或不可表示的值**。这些值不一定代表溢出条件。
-	isNaN() 在判断参数是否为数字之前，会**首先使用 Number() 对参数进行数字类型的转换**
##	
-	对象中的函数返回的是普通**匿名函数**(箭头函数是除外的	其**指针指向是上面一层对象**)	其中的this指向是window		**匿名函数是从根对象window生成的**
	是属于window的
##	js控制弹出窗口
-	window.open   ('page.html',   'newwindow',   'height=100,   width=400,   top=0,   left=0,   
	toolbar=no,   menubar=no,   scrollbars=no,   resizable=no,location=n   o,   status=no')
    //这句要写成一行    
	-	'newwindow'   **弹出窗口的名字**（不是文件名），非必须，可用空''代替；      
-	函数控制弹出窗口
	-	function fn(){window.open()}
-	10秒后**自动关闭**
	-	<body   onload="closeit()">
	-	setTimeout('self.close()',10000)
-	窗口的关闭按钮
	-	window.close()
-	**页面只需要弹出窗口一次**	那么加上**If语句判断条件**	符合条件不会再次弹出窗口	否则弹出窗口
##	重定向
-	基于浏览器的版本，或者**名字不同的页面，也可以根据不同的国家**，而不是用服务器端网页重定向，**可以使用客户端页面重定向到登陆用户在相应的页面。**
-	当你点击一个URL来**访问一个网页X，但在内部你被定向到另一页Y**
-	html文件的head部分直接书写
	-	window.location='url'
-	可以进行**时间延迟重定向**		经过一定时间之后	页面地址才会进行重定向
	-	setTimeout('redirectHtml()',3000)
		function redirectHtml(){window.location = 'url'}
	-	之后是没有回退键	返回前面跳转的页面的
-	**根据浏览器的不同		访问不同的页面文件**
	-	navigator.appName
		-	Netscape
		-	Microsoft Internet Explorer
-	常用javascript重定向跳转方法
	-	window.location.href="http://shanghepinpai.com"; 
	-	history.back(-1)		history.forward()
	-	self.location = 'url'			top.location = 'url'
##	Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。
-	耗时一天知道		**一旦创建直接运行**
##	websocket
-	前端
	-	open
	-	close
	-	error
	-	message	
		-	前端接收后端的 数据来进行处理
		-	ws.addEventListener('message',this.handleWsMessage.bind(this),false)
			-	handleWsMessage(e){
				//e是后端传递的数据
				var msg = JSON.parse(e.data)
			}
-	后端
	-	open
	-	close
	-	error
	-	message
	-	connection
	
-	vue
	-	const  ws = new WebSocket('ws://localhost:8000')
		ws.addEventListener('open',this.handleWsOpen.bind(this),false)
		//this.handleWsOpen在ws中直接执行的时候	函数的this指向是ws实例对象		但是bind函数可以改变函数
		  this指针的指向问题		
		//函数的执行作用域是vue实例		那么bind改变之后的指向是vue实例对象
		ws.send(JSON.stringify({
			name:'ok'
		}))
-	server
	-	const Ws = require('ws')
	-	const server = new Ws.Server({port:8000})
		server.on('connection',handleConnection)
		function handleConnection(msg){
			Ws.on('message',handleMessage)
		}
		//WebSocket开启一个server服务		这个服务来监听函数connection	
		//connection函数就是连接成功的数据交流经过的函数
		//connection函数里的服务开启的监听数据函数来得到前端传回的数据
		//**这个监听message的服务是由Ws来监听		不是实例化对象来监听**
		//Ws.on('message',handleMessage)
		//监听前端传回的数据	handleMessage是接收数据之后执行的回调函数
		//websocket的用户获取server.clients		向用户发送处理数据
		function handleMessage(e){server.clients.forEach((c)=>{
			c.send(msg.toString())
		})}
##	event对象			this传入的是标签自身
-
##	vw和vh的与px的区别及应用场景？
-	
	




	





	





		



	







						
	












