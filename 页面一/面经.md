##  箭头函数

-    箭头函数没有prototype(原型)，所以**箭头函数本身没有this**
-    箭头函数的this在定义的时候继承自外层第一个普通函数的this。
-    如果箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)
-    箭头函数本身的this指向不能改变，但可以修改它要继承的对象的this。
-    箭头函数的this指向全局，使用arguments会报未声明的错误。
-    箭头函数的this指向普通函数时,它的arguments继承于该普通函数
-    使用new调用箭头函数会报错，因为**箭头函数没有constructor**
-    箭头函数不支持new.target
-    **箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名**
-    箭头函数相对于普通函数语法更简洁优雅
-    箭头函数不能当做Generator函数,不能使用yield关键字(python)
-    箭头函数不能绑定arguments，取而代之用rest … 参数
    -   let C = (...c) => {
            console.log(c);
            }

##  rmf宏任务和微任务

-   ”JS是单线程的”指的是JS 引擎线程。
-   在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。
    Node环境中，只有JS 线程。
-   当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。

-   Event Loop
-   **JS引擎常驻于内存中，等待宿主将JS代码或函数传递给它**。
    也就是等待宿主环境分配宏观任务，反复等待 - 执行即为事件循环
    Event Loop中，每一次循环称为tick，每一次tick的任务如下：
    执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；
    检查是否存在微任务，有则会执行至微任务队列为空；
    如果宿主为浏览器，可能会渲染页面；
    开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。

-   在ES3以及以前的版本中，JavaScript本身没有发起异步请求的能力，也就没有微任务的存在。在ES5之后，JavaScript引入了Promise,
    不需要浏览器，JavaScript引擎自身也能够发起异步任务了。

-   ES6 规范中，microtask 称为 jobs，macrotask 称为 task
    宏任务是由宿主（Node、浏览器）发起的，而微任务由JavaScript自身发起。

-   宏任务
    -   1. script (可以理解为外层同步代码)
        2. setTimeout/setInterval
        3. UI rendering/UI事件
        4. postMessage，MessageChannel
        5. setImmediate，I/O（Node.js）

-   微任务
    -   1. Promise
        2. MutaionObserver
        3. Object.observe（已废弃；Proxy 对象替代）
        4. process.nextTick（Node.js）

-   async和await是如何处理异步任务的
    -   async是通过Promise包装异步任务。
    -   async function async1() {
		await async2()
		console.log('async1 end')
		}
		async function async2() {
		console.log('async2 end')
		}
		async1()
    -   当调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 **await的时候会就让出线程**开始执行 
        async1 外的代码（可以把 await 看成是让出线程的标志）。

-   Node.js是运行在服务端的js，虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一
    些I/O，比如新的网络连接等，所以与浏览器Event Loop不太一样。
-   Node里面对setTimeout的特殊处理：setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)。

-   Promise，process.nextTick谁先执行？
-   process.nextTick() 是一个特殊的异步API，其不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进
    行，会马上停下来执行process.nextTick()，这个执行完后才会继续Event Loop。
-   nextTick和Promise同时出现时，肯定是nextTick先执行，原因是nextTick的队列比Promise队列优先级更高。

##  取反运算符（补码全部位置取反  包括符号位）

-   ~正数补码
    -  取反变为负数 被认为是负数的补码
    -   负数补码还原回源码的样式输出
-   ~负数补码
-   ~x = -(x+1)
    -   对原来数据取反减去1
-   可以用来取整    去除小数位数
    -   ~~x
##  flex布局        (容器和项目对应)

    它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

-   容器

    flex-direction  **属性决定主轴的方向（即项目的排列方向）**
        row（默认值）：主轴为水平方向，起点在左端。
        row-reverse：主轴为水平方向，起点在右端。
        column：主轴为垂直方向，起点在上沿。
        column-reverse：主轴为垂直方向，起点在下沿

    flex-wrap   **属性定义，如果一条轴线排不下，如何换行。**
        nowrap（默认）：不换行。
        wrap：换行，第一行在上方。
        wrap-reverse：换行，第一行在下方。

    **flex-flow**属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap

    justify-content 属性定义了**项目在主轴上的对齐方式。**
        flex-start（默认值）：左对齐
        flex-end：右对齐
        center： 居中
        space-between：两端对齐，项目之间的间隔都相等。
        space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

    align-items 属性定义**项目在交叉轴上如何对齐**
        flex-start：交叉轴的起点对齐。
        flex-end：交叉轴的终点对齐。
        center：交叉轴的中点对齐。
        baseline: 项目的第一行文字的基线对齐。
        stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

    align-content   属性定义了**多根轴线的对齐方式**。如果项目只有一根轴线，该属性不起作用。
        flex-start：与交叉轴的起点对齐。
        flex-end：与交叉轴的终点对齐。
        center：与交叉轴的中点对齐。
        space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
        space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
        stretch（默认值）：轴线占满整个交叉轴。

-   项目

    order属性定义项目的**排列顺序**。数值越小，排列越靠前，默认为0。
    flex-grow属性定义**项目的放大比例**，默认为0，即如果存在剩余空间，也不放大
    flex-shrink属性定义了**项目的缩小比例**，默认为1，即如果空间不足，该项目将缩小。
    flex-basis属性定义了在分配多余空间之前，**项目占据的主轴空间**（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
    **flex属性是flex-grow, flex-shrink 和 flex-basis**的简写，默认值为0 1 auto
    align-self属性允许**单个项目有与其他项目不一样的对齐方式**，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
-   flex总结
    -   容器
        -   flex-flow:row               nowrap;
                        ^                   ^
                    项目排列            项目换不换行
        -   justify-content     -->     项目**主轴**怎么对齐（center(居中)flex-start(项目靠左对齐)space-between(居中等间距))
        -   align-items         -->      项目**交叉轴**怎么对齐 (center(居中对齐)baseline(项目第一行文字的基线对齐))
        -   align-content   -->     多根轴线的对齐方式(flex-start(交叉轴起点对齐))

##  meta标签设置网页的元数据   一般用来告诉浏览器如何解析网页
							--》name设置属性的名字
							-->content设置属性的内容
							--》description用于告诉搜索引擎网页的主要内容
##  p标签不放任何块元素
##  ##	base64 用来将图片转换为字符串   直接在页面加载时候就可以用   提升速度	不可读	
##  iframe  src  引入外部网页   iframe不会被爬虫解析

##  选择器
##  span + p{}兄弟元素
        span ~ p{}选择后面的所有p兄弟元素
        div>p+tab //就生成了div 里面有个 p
##  +  {1,}   x + y{}同级别的兄弟       x ~ y{}x后面的兄弟
##  div p:first-child{}//div的第一个子元素必须并且是p 才成立 
    div p:first-of-type{}//div的p类型中的第一个
##  属性选择器   [title]{}//有title 这个属性的 时候就执行内容
        [title='hello']{}//title为hello
        [title^='h']{}//title以h开头
-   内联1000>id100>类和伪类10>元素1
##  visibility:hidden;			-->不显示元素但是占领位置
    但是 		display		-->不显示元素且不占领位置
##  <a>里面什么都可以放</a>
##  box-shadow-->设置阴影		和轮廓一样		就是加上一个特效
    box-shadow:（inset）20px 20px 10px #ffe;-->第一个值正值向右移动
                                    --》第二个值正值向下移动
                                    --》第三个值越大阴影就越模糊
                                    --》inset  表示内部阴影  	默认外部阴影
                                    --》可以设置多重阴影
##  脱离文档流的元素全是块元素

##  BFC是元素的一个隐藏属性		一旦元素开了BFC他将会开启一个独立的布局区域
-   设置元素浮动可以开启BFC
    CLEAR   来清除浮动元素的影响
    .clearfix::before,
    .clearfix::after{
        content:'';
        display:table;
        clear:both;
    }			
##  z-index:1..   父元素层级再高不会盖住子元素
##  opacity:		-->用来设置元素的不透明度
##  元素设置了		absolute，那么margin:0 auto;就不管用了 	除非设置的时候left top right bottom 设置为0   	
    margin:auto;-->就会水平居中
-   **元素设置了定位** 		那么就多了left bottom right top 这几个值
    -   元素定位之后   多了left		right
				-->记住left:0;right:0;
				-->margin:0 auto;-->这样才会居中

-   position  	默认值是static 	表示没有开启定位
-   text-align:-->left		左对齐
                -->right		右对齐
                -->center
                -->justify		文本两端对齐
    vertical-align-->baseline		沿基线对齐
                    --》sub		下标
                    --》super	上标
                    --》bottom	沿父元素底部对齐
                    --> top		沿父元素顶部对齐
                    --》middle	相对于小写子母的middle对齐
##  min-width 	max-width		最小宽度		最大宽度
    --》浏览器缩小放大的时候不改变框的大小
##  line-through		文本删除线
    over-line 		上划线
##  CSS Sprite(CSS精灵),雪碧图
                -->有效降低了发送请求的速度，提升用户的体验，降低图片的总大小
                -->降低加载的速度
                -->只适用于背景图片background-image
##  第一次刷新的时候为什么会闪烁呢
                因为图片这些外部资源只会在页面在加载之后，有页面请求的时候在来加载
                图片需要使用的时候才来加载就会闪烁这种叫做懒加载
##  小三角
    .div_9{
    width: 0;
    height: 0;
    border: 10px solid black;
    border-color: transparent transparent black transparent;
    }
##  transition:all 4s 1s;		-->第一个值是执行动画的属性
        -->第二个值执行动画的时间
        -->第三个值要延迟多久才来执行动画
-   transition实现了过渡效果		交互效果		类似动画效果但不是动画

##  ico文件就是web网站标签的图标
##  transform:translateX();		-->沿着x轴方向平移
				translateY()	-->沿着y轴方向平移
				translateZ()	-->沿着z轴方向平移	元素距离用户的距离
##  perspective		-->视距  设置人的眼睛和网页之间的距离	让视觉有3D效果
-   perspective:100px;-->不宜过小
    transform-style: preserve-3d;		-->**添加3D效果**
    perspective: 800px;                 --》眼屏距离
##  npm可以下载和上传
    **cnpm只可以下载**
##  darken()函数用来加深颜色
    background-color:darken(yellow,20%);	-->加深了黄色


##  less
-   @a:10px;
    .box1{
        width:@a;
        height:10px;
        .box2{}
    }	
-   .box1{
	width:160px;
	height:$width;
    }
            -->使用$符号来直接引用其他的值
            -->使用变量的时候就近原则
-   .box2{
	.box1();
        }								-->box2里面来使用box1的样式*
-   .hello(@a,@b){
	width:@a;
	height@b;
	background-color:#f00;
    }			--->简化了开发 		要引入的时候就引入
    -   .wrapper{
            .hello(300px,500px);	}	
                    -->简化了开发		减少了代码量
-   @import "demo02";		-->将外部的less文件来导入当前less文件

##  var age;		-->undefined		-->定义变量未赋值	-->里面存的就是undefined
-   null		-->空类型		var obj = null;-->一般定义对象的时候来使用	用于对象初始化或者删除一个对象的时候来使用
-   !==			--->不全等于
-   num+1		-->是一个表达式 
-   Number();			-->强转类型函数		若字符串看起来不是一个数字	那么转换为NaN		而不是数字		true->1		
    false->0        undefined-->NaN
-   parseInt(a)		-->提取整数		--》a="123adf"-->a==123
								-->a="asf123"-->a==NaN
-   1/0			--》infinity	-->无穷大
##  栈结构			--》先进后出	有序的	栈底	栈顶	栈是独享的
    堆结构			--》随意增删		堆是共享的
##  预解析只会解析带var的变量,不带var的,不进行预解析
-   预解析优先级		
			--》先去解析函数	函数如果有同名会发生覆盖
			-->再去解析var变量
-   匿名函数	不会发生预解析
##  Object是原型对象的原型对象
    对象找属性的过程形象地成为原型链
##  一般我们等待页面加载完成后		--》才去操作dom元素
-   window.onload		-->页面加载完成事件
##	textContent		innerText	的区别
    textContent	可以获取隐藏元素的文本		包括换行和空白**visible:hidden	的元素可见**
    innerText		不可获取隐藏元素的文本
##  keyup		keydown		键盘抬起	键盘按下
    inputNode.onkeyup = function(event){}
    keyCode		键盘键码
##  document.body.appendChild(ulNode);

##  DOM0 DOM1 DOM2 DOM3
-   **dom0事件取消浏览器的默认行为**直接在函数里面return false;
-   **dom2事件取消默认行为**event.preventDefault();

**onmouseenter onmouseleave		如果是父子元素模型		当鼠标移入父元素的子元素的时候事件没有移出再移入		事件没有切换**
**onmouseover	onmouseout		如果是父子元素模型		鼠标移入父元素的子元素的时候事件会移出再移入		事件有切换**

##  location		window.location		页面地址
    window.location.href		重定向地址

##  clientX	clientY             相对于**视口**左上角的位置
-    offsetX	offsetY         相对于**元素**左上角的位置
     pageX 		pageY           相对于整个页面左上角的位置	带上**滚动条滚动**的距离
     screenX	screenY         相对于**屏幕**左上角的位置

##  针对的是元素
    offsetWidth	-->拿的是盒子	        content  	padding border
    clientWidth	-->盒子                 content	    padding
    scrollwidth	-->内容比盒子小的时候	拿的是clientWidth
                -->内容大于盒子的时候	拿的是OffsetWidth加上盒子一侧的内边距
    clientLeft	    clientTop		拿到盒子边框的大小
    offsetLeft		offsetTop		拿到盒子的水平偏移量和垂直偏移量
    scrollLeft		scrollTop		拿到滚动条滚动的距离

## 视口宽高求法
    document.documentElement.clientWidth
    document.documentElement.clientHeight
##  系统滚动条有两个		body和document
    body 或者 html单独设置overflow:scroll	滚动条打开的全是document的
    body 和 html 都设置overflow:scroll	那么Html打开document身上的滚动条		body打开自己身上的滚动条
    禁止系统滚动条
##  __proto__   -->  prototype
## 	变量提升	函数提升
1.	js引擎正式执行代码之前	会预解析
2.	找var function
-	**全局的预解析在定义函数的时候不关心函数是否被使用**
-	**函数局部预解析的时候如果内部函数没有被使用就不会提前定义**
-  	执行上下文栈
	执行上下文式动态创建的	针对函数	函数每调用一次就创建一次执行上下文		执行完就销毁	
-   作用域
    只有全局作用域	函数作用域		**没有对象作用域**
##	rmf作用域
-	局部作用域
-	全局作用域
-	作用域决定了这些变量的可访问性（可见性）。
-	JavaScript 只有声明的变量会提升，初始化的不会
-	严格模式
-	消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
	消除代码运行的一些不安全之处，保证代码运行的安全；
	提高编译器效率，增加运行速度；
	为未来新版本的Javascript做好铺垫。
-	函数内部定义的变量从函数外部是不可访问的（不可见的）。
-	在 JavaScript 函数中声明的变量，会成为函数的局部变量。
-	由于只能在函数内部识别局部变量，因此能够在不同函数中使用同名变量。
-	如果您为尚未声明的变量赋值，此变量会自动成为全局变量。
-	在“严格模式”中不会自动创建全局变量。
-	在 HTML 中，全局作用域是 window。所有全局变量均属于 window 对象。
-	JavaScript，全局作用域形成了完整的 JavaScript 环境。
-	作用域嵌套的查询规则：
	首先，JS引擎从当前的执行作用域开始查找变量。
	然后，如果找不到，引擎会在外层嵌套的作用域中继续查找。
	最后，直到找到该变量，或抵达最外层的全局作用域为止。
-	function foo(b) {
    console.log(a + b) // 4
	}
	foo(2)
	var a = 2
-	NaN			因为foo函数前面没有a的赋值	那么就获取不到a的值	那么就得到答案NaN
-	如果对未声明过的变量进行赋值：
	在非严格模式下，JS引擎会为其自动创建一个全局变量且进行赋值。
	如在严格模式下，会导致 ReferenceError 异常
-	词法作用域（静态作用域）
	词法作用域就是定义在词法阶段的作用域，简单说就是函数的作用域在函数定义的时候就决定了。
	词法作用域查找规则是：作用域查找是从内到外进行查找的，直到找到第一个匹配的标识符时停止。
-	函数中的参数是局部作用域
-	function foo(obj) {
    with (obj) {
        b = 4
        a = 2
		}
	}
	var obj = {
		b: 3
	}
	foo(obj)
	console.log(obj.a) // undefined
	console.log(obj.b) // 4
	console.log(a)  // 2，a被当前全局变量泄露到全局作用域上了
-	使用关键字 let 或 const 定义块级作用域的变量。
-	a = 10
	var a
-	var a 和 a = 10 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务
-	if语句中的变量会预解析	变量提升
-	函数声明和变量声明都会被提升，但是出现在有多个“重复”声明的代码中，函数会首先被提升，然后才是变量。
	函数没有方法重载，存在两个相同的函数名，后面的函数会覆盖前面的函数。
-	函数前面调用执行的是函数重复的结果		函数后面调用执行的是函数变量提升之后的结果
-	foo() // 3
	function foo() {
		console.log(1)
	}
	var foo = function () {
		console.log(2)
	}
	function foo() {
		console.log(3)
	}
	foo() // 2 函数表达式的提升情况
-	函数预解析的情况是
-	foo(){console.log(3)}
	var foo
	foo()
	foo = function(){console.log(2)}
	foo()
-	function fn(){
        console.log(a);
        var a=45;
        console.log(a);
    }
-	undefined-->45		首先是变量提升		声明但是未定义
-	var obj = {
        val:2,
        dbl:function(){
            var val = 45;
            console.log(this);
            this.val*=2;
            console.log(val);
            console.log(this.val);
        }
    }
    var ff = obj.dbl();
    var fn=obj.dbl;
    fn();
-	{val:2,dbl:f}	45 4 window  45 NaN
-	var x = 10;
	function fn() {
		console.log(x)
	}
	function show(f) {
		var x= 20;
		f();
	}
	show(fn);
-	结果是10		原因是每个函数都有自己独立的执行环境		调用函数来帮忙		但是函数依照自己定义的地方来执行函数结果
-	var obj = {
            fn2:function () {
                console.log(fn2);
            }
        }
        obj.fn2();
-	对象里面调用要用到this指针 的指向问题		这里没有用到this指针出现问题
-	用了this指针会输出fn2的函数形式
-	当函数与变量同名时，函数会覆盖掉变量
-	由于JavaScript是单线程的，只有一个执行栈，如果每次都要等的话是很不好的，所以会先把setTimeout函数先放进一个任务队列中，等到执行栈中执行完了之后再完成任务队列中的任务。
-	for(let i = 0;i < 5;i++){
	}
	console.log(i);
-	i is not defined
-	块级作用域里面用let和const声明的变量就不会被外部访问到
-	for(var i=0;i<=5;i++){
	console.log("hello");
	}
	console.log(i);
-	相同的函数名	变量名	声明的时候会函数优先	预解析使用的时候是函数优先的
-	let没有变量提升		但是有暂时性死区	就是说使用let const变量在声明之前使用是会报错的
-	var变量提升是首先赋值为undefined		但是let const 是没有赋值的	存在暂时性死区状态	只有定义赋值之后才可使用let const变量
-	其实let const 变量是提升了的		但是规定不可再其声明前使用变量而已		索引这一特性称为暂时性死区
-	用const声明恒定变量	声明的同时就必须赋值	否则会报错
-	在if或则for语句里面定义的函数，函数名变量会同步到和函数同一个作用域下	同步作用域会影响全局变量的使用
-	同步作用域的时候记住函数实际的位置		若相同的变量名在前面赋值了	变量的值会同步到相应的if for所在的作用域的下面
-	function foo() {
	var val = 'hello';
	function bar() {
		function baz() {
		val = 'world;'
		};
		baz();
		console.log(val); //=> world
	};
	bar();
	};
	foo();
-	var doc = document;
	for(var i = 0; i < 10000; i++){
		var but1 = doc.getElementById("but1");
	}
-	先把全局对象的变量放到函数里面先保存下来，然后直接访问这个变量
-	数组数据的插入比较快的方法
-	arr[arr.length] = target
-	[target].concat(arr)
-	用splice向中间插入元素是最快的
-	a < b?a:b比起使用Math.min()速度会更加快
-	return function(){}	在循环里面使用是相互独立的返回数据		数据可以独立维护
-	(function(i){return function(){console.log(i)}})(i)
-	封装成函数。在封装函数的时候，善用运用回调函数
-	flex子元素宽度超出父元素的时候		超出宽度ow		子元素宽度sw1 sw2..
-	子元素宽度	sw1 = sw1 - ow*(sw1*sw1Shrink1/(sw1*sw1Shrink+sw2*sw2Shrink))
-	自身宽度(200px)- A减小的宽度(100px * (200px * 3/(200 * 3 + 300 * 2))) = 150px
-	flex布局就是子元素宽度超出父元素就会缩小	用到缩小公式
-	父元素有所剩余就是会根据数值来按照一定比例来分配所剩下的数据值
-	flex-basis优先级是大于width
#	闭包
-	闭包就是一个引用关系	引用关系存在于内部函数中	引用的是外部函数的变量的对象 
##	如何产生闭包
-	函数嵌套
-	内部函数引用外部函数的局部变量
-	使用内部函数
##	闭包的作用
-	延迟外部函数变量对象的生命周期(既是优点也是缺点)
	(占内存，如果不及时清除容易造成内存溢出，泄露)	那么使用完闭包之后就应该快速清除释放设置为null
-	让函数外部可以间接操作到函数内部的数据
##  console.log(1,console.log(2));-->2 1 undefined
-	**console.log()是一个函数 没有返回值**
##  #	工厂函数模式
-   	工厂函数
    function person(name,age){
        return{
            name:name,
            age:age
        }
    }
    -	构造函数
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
##  Person.call(this,name,age)
-    Child  复用	Person的代码
##  进程 线程
-	进程是程序的一次执行，占有一定的内存空间	是程序**分配**和执行管理资源的基本单位	是计算机资源的基本单位
-	线程是CPU的基本**调度**单位	多个进程之间的数据是不可共享的	是进程的一部分
##  钩子函数就是回调函数	轮询机制
-   当主线程上所有的同步任务执行完毕会通过轮询机制来询问callback queue是否有可执行的回调函数	
-   setTimeout后面**不要写运算量大的代码**	定时器是非阻塞的 会继续询问后面的可执行代码	耽误定时器执行	导致不准时
-   **定时器不准时因为js是单线程的**
##  webworker
    worker.prototype.onmessage	用于接收另一个线程的回调函数
    worker.prototype.postmessage	向另一个线程发送信息


## 	ES5的扩展的静态方法		
-   **Object.create()**
    --》指定地去创建一个新的对象。并指定原型对象
    var obj2 = Object.create(obj);指定obj为obj2的隐式原型对象_proto_
    当然还可以添加obj2的新属性
    var obj2 = Object.create(obj,{
        sex:{value:'nan',
        `writable:true`//**属性可以修改**},
        age:{value:43}
    });
    `writable:true`//**标识属性可以修改**
    `configurable`-->**标识属性可以被删除true**
    `enumerable`-->**标识属性可以用for in俩枚举**
-    **Object.defineProperies	**配置对象****
-	get方法的作用	提供**扩展属性的值**
-   set方法在修改扩展属性的时候会自动调用	用来**监视扩展属性**	不可在set方法当中修改扩展属性	否则出现死循环	可以借助第三方变量来修改
-   添加的key必须是字符串	**加上引号''**
    var obj = {
        name:'kobe',
        age:42
    }
    Object.defineProperties(obj,{//配置对象
        sex:{get:function(){
            console.log('get()');
            return '男';
        },
        set:function(msg){
            console.log('set()',msg);//set有引号
        }}
    })
-	**obj2数据复制到obj3里面**
var obj2 = {name:'kobe',age:42}
var obj3={};
for(var item in obj2){//in来遍历对象
	if(obj2.hasOwnProperty(item)){
		console.log(item,':',abj2[item]);
		(function(item){
		Object.defineProperties(obj3,{
			[item]:{
				get:function(){//获取
					return obj2[item];
				},
				set:function(msg){//设置
					obj2[name] = msg;
				}
			}
		})
		})(item)
	}

##  rmfArray
-	arr.forEach(function(item,index){})-->遍历数组  不改变原来数组      只有抛出异常才会中止    break不可中止   不返回fi数据
-	arr.map(function(item,index){})-->遍历数组返回加工后的数组      返回数据    
-	arr.filter(function(item,index){})-->返回符合条件的数组
-	arr.join('')		数组里面的元素连接成字符串
-	arr.concat(arr2)	不会改变原来数组	而是会返回新的数组
-	arr.slice()		不会修改原数组 返回新的子数组	左闭右开	slice(-1)代表的是倒数第一个
-	arr.splice(start,count,[value1,value2,..])
-	arr.reverse()	直接修改原来数组
-	arr.sort()	修改原来数组	将数组字典序排序
-	arr.indexOf(target)	arr.lastIndexOf(target)		返回target在数组中第一次出现的位置	最后一次出现的位置
-	arr.forEach((value,index)=>{})	循环数组	没有返回值
-	arr.map((value,index)=>{})	循环数组	有返回值
-	arr.toString()	类似于arr.join(',')		注意是用','连接形成的字符串
-	arr.unshift('value1','value2',...)	数组开头插入元素
-	arr.shift()	弹出数组最开头的元素	修改原数组	返回被弹出的元素
-	arr.push()	返回数组的length
-	arr.pop()	返回被弹出的数组元素
-	let a = arr.every(item =>{return item>0});console.log(a);//数组全部元素满足条件返回true
-	let a = arr.some(item => {return item>3});console.log(a);//数组中遇到符合条件的就会退出循环	有一个符合就返回true	
-	否则返回false
-	let a = arr.filter(item => item>20);console.log(a)//过滤出大于20的元素		组成一个新的数组
-	let a = arr.reduce((total,value,index,arr)=>{return total+value})
-	value是可选的	不指定初始值	会将数组中的第一个元素作为初始值	index不传入初始值	index是从1开始	总的循环的次数是数组的
	长度减去1		传入初始值	index是从0也就是第一个元素开始	
-	index传入就是0		不传入就是1
-	value index两个都不指定		return x		返回的就是数组元素的第一个元素
-	arr.reduceRight
	reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低（从右到左）处理数组。
-	arr.find		let a = arr.find(item => {return item.id === 2})
-	arr.findIndex()
	找出第一个符合条件的数组成员，没找到返回 undefined。
-	1.find()与findIndex()参数与用法相同，不同的是find返回元素，findIndex返回索引；找不到时find返回undefined，findIndex返回-1.
	2.findIndex()与indexOf()，findIndex比indexOf更强大一些，可以通过回调函数查找对象数组，indexOf只能查找数组中指定的值，不过indexOf可以指定开始查找位置的索引
-	find findIndex里面的参数是回调函数(item,index)=>{}	而indexOf(item)参数就是需要查询的值
-	arr.indexOf(23,5)//从5的位置开始查找23
-	arr.includes()
	表示某个值是否在数组里，includes() 不接受函数参数。
-	arr.copyWithin(target,start,end)	start end之间是复制的值		target是复制的值去往的目的地
-	end没有的话	复制到target的位置为止
-	arr.entries()	创建并返回数组可迭代的对象	var x = arr.entries()
-	x.next().value		可迭代对象迭代输出数据的方法		.next().value
-	实现二维数组	new Array(n).fill(0).map(()=>new Array(n).fill(0))
-	实现函数对象数据的赋值		就是直接用var变量 来赋值	不需要this	
-	var fn = function(){var stack = []}		不需要用this来指定数据变量的数据的设置
-	



##  let提升的变量在**没有赋值**之前那**不允许被使用**
-   a is not defined        **NG**
-   而var变量的是       可以使用不过是undefined
-   变量提升
	-	全局变量提升
		-	会创建一个**变量对象(script)**用来收集全局作用域下let定义的变量		但是没有赋值	不会成为window对象的属性	script是window的下级		因为压栈是不会平行去压栈的
	-	局部变量提升
		-	会将var let定义的变量全部放到当前函数的变量对象中
		-	但是**只有使用var关键字声明的变量才会被初始化undefined值**，而let和const声明的变量则不会被初始化值。
-   let的应用	**变量的解构赋值**	按需索取
    -   let obj2 = {username:'kobe',age:42};
        let {username,age} = obj2;
	-->**方便了变量的声明使用**--》全局来用	
## 	...运算符	可以打包	解包
-	用来取代arguments	比arguments更加灵活
##  Object.prototype.toString.call(target).slice(8,-1);
##	2D变换
-   transform:translate(200px) scale(0.5);//盒子平移200px 再缩放0.5倍
    transform: scale(0.5) translate(200px)//盒子先缩放0.5倍 再来平移100px
-   **scale在translate前面**   那么translate会随着scale的倍率来平移
##	响应式的好处 		写得好可以适配所有情况
	响应式的坏处		代码量大	维护成本高	
##  window.onkeydown=function(e){
	console.log(e.keyCode);
    }
##  document.querySelector('.search');
##  e.target当前元素的子元素	target属性
##  save()保存		restore()恢复在canvas画布里面很重要
##   清除画布很重要
      ctx.clearRect(0,0,1000,1000);
##  git是基于linux的
-   是一个微型的linux的虚拟机
-   git分为三个区域
-   工作区	暂存区	版本区
-  	git add xx.txt	添加指定文件到暂存区
-	git status	工作区状态	文件绿色代表在暂存区	红色在工作区
-	git reset --hard HEAD^	回到上一个版本
-	git reset --hard HEAD^^	回到上两个版本
-	git reset --head 版本号		回到指定的版本号
-	git checkout --x.txt	暂存区指定文件区替换工作区的指定文件
-	git rm -- cached x.txt  取消暂存区刚刚的提交文件
-	git rm x.txt	删除文件
-	git rm  -r xxx	删除文件夹
##  style标签是html解析器来异步解析的	那么就会有闪屏可能
-   link引入css样式就会避免闪屏	css解析器是同步的	就不会有闪屏
-   无论css js阻塞都不会阻塞外部资源的请求
-   defer的作用	defer紧随dom解析之后	使用之后可以知道dom解析什么时候解析完
##  前端优化
-	使用cdn节点进行外部资源加速
-	css进行压缩
-	减少http请求数	多个css文件进行合并
-	优化样式表代码
##	缓存机制
-	浏览器在本地磁盘上将用户之前请求的数据存储起来	用户再次改数据的时候无需再次发送请求	直接从浏览器本地获取数据
-	缓存的好处
	-	减少请求的个数
	-	节省带宽	减少浪费不必要的网络资源
	-	减轻服务器压力
	-	提高浏览器网页的加载速度	提高用户体验
-	缓存的分类	请求成功的资源状态码是200ok
	-	强缓存
		-	不会向服务器发送请求	直接从本地缓存中获取数据
	-	协商缓存
		-	向服务器发送请求	服务器根据请求头的资源判断是否命中协商缓存
		-	如果命中	则返回304状态码通知浏览器从缓存里读取资源
	-	强缓存和协商缓存的共同点
		-	都是从浏览器读取数据
	-	强缓存和协商缓存的不同点
		-	强缓存不会请求服务器
		-	协商缓存会请求服务器	根据服务器返回的信息决定是否使用缓存
-	强缓存里的header参数
	-	expires		指定具体日期强缓存到期
	-	cache-control:max-age=..(可以强缓存的时间)
	-	cache-control优先级高于expires
-	协商缓存
	-	Last-Modified上一次修改的时间是什么时候
	-	if-Modified-Since和Last-Modified一起控制协商缓存
	-	Etag解决了last-modified难解决的问题
	-	etag和if-none-match	一起解决协商缓存
		-	一些文件也许会周期性更改	但是内容并不会改变	
		-	某些文件修改频繁	一秒内修改n次
		-	某些服务器不能精确得到文件的最后修改时间
##  单线程处理不好cpu密集型任务
###	浏览器的js由哪几部分组成
-	BOM		window浏览器对象模型	很多的API(location,history)
-	DOM		document文档对象模型	很多的API(对DOM的增删改查)
-	ES规范		ES5	ES6	
###	node端的js由及部分组成
-	没有了BOM	因为服务器不需要	服务器没有浏览器对象	没有window
-	没有了DOM	没有浏览器窗口	就是没有document
-	几乎包含了所有的ES规范
-	没有了window 取而代之的式一个global的全局变量	node中禁止函数指向global		而是指向了一个空对象
##	node事件循环模型	有六个阶段	1.timers 2.pending callbacks	3.idle,prepare	4.poll	5.check	6.close callbacks
-	timers()	定时器阶段	计时	setTimeout	setInterval	执行定时器的回调
-	pending callbacks()	系统阶段	准备系统内置的东西
-	idle,prepare	准备阶段
-	poll	轮询阶段式核心	
	-	如果回调队列有待执行的回调	那么就去回调函数	同步执行	
	-	如果回调队列为空	
	-	如果有设置过setImmediate	进入下一个check阶段
	-	如果没有设置setImmediate	则停留 等待回调函数插入回调队列
	-	若定时器到点了	进入下一个check阶段		原因式为了走阶段	直到下一个阶段
-	check	专门用于执行setImmediate所设置的回调
-	close callbacks()	关闭回调阶段
-	process.nextTick()-----用于设置立即执行函数()---'人民币玩家'	在任意阶段都优先执行	但还是怕主线程
###	setImmediate设置立即执行函数		clearImmediate
-	**回调函数天生是要等其他忙完再执行的**	不是定时器
-	这里涉及到计时速度和轮询的速度关乎到定时器和setImmediate的先后顺序
-	**在主线程上加了代码	影响了轮询速度和定时器速度**	因为线程消耗的时间为定时器争取了时间		否则就只看轮询时间和计时开始时间	
###	process.nextTick()	是用来设置立即执行函数		process.nextTick高于定时器	是特殊的
##	commonJs是双端的js模块化规范	服务器端	浏览器端	只有commonjs是双端的
###	commonjs引入模块必须按顺序引入	服务器端比较敏感	干活有顺序
-	暴露模块
	-	module.exports = value;
	-	exports.xxx = value;
	-	export是es6里面的语法
	-	module1.js	对象
		-	module.exports = {data:..,test(){}}
	-	module2.js	函数
		-	exports.haha = function(){
		}
	-	module3.js	数组
		-	exports.perqi = [1,2,34,5,6];
	-	可以引入对象	函数	数组...
	-	创建了module1.js	modules2.js	module3.js来暴露对象	函数...
	-	app.js里面来引入module1.js....
		-	let module1 = require('./modules/module1');..
		-	let {data,test}=require('./modules/module1');
		-	引入的同时	进行解构赋值
		-	'./'必须写清楚	要加上
		-	let xx = ..来引入
		-	这里写了路径	就是说不是在node_modules里面去找	而是去自定义那里去找
		-	let a = require('uniq');//当然在npm i uniq之后这样来引入	默认去node_modules里去找
		-	uniq([1,2,3,45,6,7,12,23,45,12,34])
		-	这样写是字典排序并且去重1 12 2 23 3.. 
###		commonJs模块化内置的一个关系	module.exports ={} exports ={}		{}暴露出的对象	module.exports和exports以module.exports为主
##	不使用模块化的缺点
-	文件冲突
-	不便于维护
-	不便于按需加载
##	浏览器里面没有require	window.require
-	服务器	和	浏览器里运行js可能有天壤之别
-	浏览器不认识require		那么会用browserify
	-	npm i browserify -g			全局安装在c盘		4048表示权限不够	要以管理员身份打开9
	-	有些东西是不可全局安装的
	-	**browserify js/src/app.js -o js/dist/peiqi.js**	borwserify将A目录下的js翻译到了B目录		使得浏览器认识翻译后的js文件
#	ES6		相应的暴露方式对应各自的引入方式	es6可以混合暴露
-	暴露模块
	-	结构
	-	js
		-	src
			-	module1.js..
			-	app.js
	-	index.html
	-	分别暴露
	-	统一暴露
	-	默认暴露	优点写法简单	import uniq from 'uniq'
-	module1.js	分别暴露
	-	export let data = ''
		export funtion demo(){}..
-	module2.js	统一暴露
	-	let arr = []
		function demo2(){}
		function test2(){}
		export{demo2,test2}//统一暴露函数	精简版写法
		export{demo2 as h1,test2 as h2}		完整版写法
-	module3.js	默认暴露		只能暴露一次	只能写一次	否则报错
	-	export default {
		name:'',age:,speak(){}
	}
-	app.js	汇总modulexxxx.js的js文件
-	引入模块
	-	分别暴露的引入
	-	import {data,demo1,test1} from	'./module1'
	-	分别暴露引入的另一种方式	import * as haha from './module1'
	-	统一暴露的引入
	-	import {demo1,test1} from	'./module2'
	-	统一暴露引入的另一种方式	import * as haha from './module2'
	-	默认暴露的引入
	-	import module3 from './module3'
	-	默认暴露引入的另一种方式	import * as haha from './module3'	但是尽量不要用这种方式
	-	混合暴露	包含分别暴露	统一暴露	默认暴露
	-	再来引入	import {} from ''	import module from ''
	-	当然两种引入方式也可以一起用	import module,{} from''
	-	上面默认暴露的	应该写在最前面
##	浏览器不认识es6模块化语法	那么要用到 babel来翻译转换
-	babel是facebook的
-	babel可以把es6==》es5
-				jsx==>js	jsx必须闭合
##	cli:command line interface	命令行接口工具	babel的'经纪人'
-	npm i babel-cli -g	**babel体积大**
-	npm install babel-preset-es2015	--save-dev
-	创建.babelrc文件	rc = run control	运行控制	在包里直接创建这个运行时控制文件
-	babel在干完		babel xxx.js -d xx.js
-	只是转换后的js文件可能是commonjs模块规范的 	那么就还要操作
-	browserify xx.js -o xx.js	这样才能转换成功	浏览器才认识
#	AMD-RequireJS
-	结构
	-	js
		-	lib//放一些第三方的库
		-	modules
		-	定义没有依赖的模块
-	定义没有依赖的模块
-	define(function(){
	//数据只读
	let data = 'atguigu'
	function getDataL(){
		return data.toLowerCase()
	}
	return {getDataL};
})
-	定义一个有依赖的模块
-	define(['module1'],function(module1){
	let msg = '',
	function getDataAndMsg(){}
	return getDataAndMsg
})
-	app.js里面来设置requirejs
	-	requirejs.config({

	})
-	AMD模块化中	也要用特殊的引入方式	移入require.js
-	AMD模块化用jquery	不用jQuery
-	baseUrl:''	//开始的根目录就是index.html所在的目录
-	404请求资源未定位
#	CMD模块化
-	module1.js
	-	define(function(require,exports,module){})
-	module2.js
	-	define(function(){})
-	module3.js
	-	define(function(){
		//引入module2	同步引入
		let module2 = require('./module2')
		//异步引入
		require.async('./module1',function(m3){})
		module.exports = {}
	})
-	汇总js配置	main.js
	-	define(function(require){
		let module1 = require('./module1')..
	})
-	index.html里面来引入sea.js
-	`<script>seajs.use(./../main)</script>`
##	buffer缓冲器
-	buffer是和数组类似的对象		不同的是buffer是专门来保存二进制数据的
-	buffer大小一旦确定就不可修改
-	buffer效率很高	存储和读取很快	直接对计算机的内存进行操作
-	每个元素占用内存的大小为1字节		就是8bit
-	buffer是node 的核心模块	无需下载
##	node里面的文件操作
-	**简单文件写入(异步文件写入)**
-	fs是node的核心模块	无需下载 但是要引入
-	let fs = require('fs')//引入内置的fs
-	fs.writeFile('路径','写的内容',{mode:0o444},(err)=>{
	if(err){

	}else{

	}
})//调用writeFile方法
-	sync是同步的		async是异步的
	-	fs.writeFile(file,data[,options],callback)
	-	file是要写入的文件路径
	-	data要输入的数据
	-	options	可选参数
		-	encoding	设置文件的编码方式	默认似乎utf-8
		-	mode	设置文件的操作权限
					默认值是0o666=0o222+0o444
					0o111是文件可被执行的权限
					0o222文件可被写入的权限
					0o444文件可被读取的权限	mode:0o444
		-	flag	打开文件要执行的操作	默认值是'w'
			-	w写入
			-	a追加		flag:'a'
	-	callback	回调函数
	-	err	错误对象
##  关系型数据库只能使用硬盘
###	如何判断对象是否为空对象
-	JSON.stringify(errMsg !== '{}')//true为不是空对象
##	rmfcookie
-	存储cookie是浏览器提供的功能。cookie 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 cookie 文件夹来存放各个域下设置的cookie
-	存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销
-	身份认证信息就特别适合放在cookie中
-	每个域名下的cookie 的大小最大为4KB
-	JS 原生的 API提供了获取cookie的方法：document.cookie	这个方法只能获取非 HttpOnly 类型的cookie
-	cookie选项来设置的，cookie选项包括：expires、domain、path、secure、HttpOnly
-	expires其实是cookie失效日期，expires必须是 GMT 格式的时间（可以通过new Date().toGMTString()	如果没有设置该选项，则默认有效期为session，即会话cookie。这种cookie在浏览器关闭后就没有了
-	expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替
-	max-age 的值是一个以秒为单位时间段
-	max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age
-	domain是域名，path是路径，两者加起来就构成了 URL
-	所以domain和path2个选项共同决定了cookie何时被浏览器自动添加到请求头部中发送出去。
-	“baidu.com”其子域如“api.baidu.com”、“dev.api.baidu.com”
-	“/ ”子路径“/home”、“/home/login”
-	发生跨域xhr请求时，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下cookie也不会自动被添加到请求头部中
-	secure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie才能被发送至服务器。
-	默认情况下，cookie不会带secure选项(即为空)。所以默认情况下，不管是HTTPS协议还是HTTP协议的请求，cookie 都会被发送至服务端。但要注意一点，secure选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 cookie。
-	httpOnly
这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。
-	一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。
-	XSS 攻击，有一段恶意的script脚本插到了网页中。这段script脚本做的事情是：通过document.cookie读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了
-	cookie既可以由服务端来设置，也可以由客户端来设置。
-	response header中有一项叫set-cookie，是服务端专门用来设置cookie的
-	一个set-Cookie字段只能设置一个cookie
-	cookie其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码		encodeURIComponent/decodeURIComponent
-	大多数XSS攻击都是针对会话cookie的盗窃。后端服务器可以通过在其创建的cookie上设置HttpOnly标志来帮助缓解此问题
##	rmfxss
-	防止 cookie信息泄露		服务端设置set-cookie		httponly		限制用js来获取用户cookie并用获取的cookie来操作非用户本意的操作
-	手机验证码来设置登录
##	分类
-	会话cookie	关闭浏览器	会话cookie会自动消失	存在内存里
-	持久化cookie	有有效期	到期自动销毁	存储在用户的硬盘上
##	工作原理
-	cookie是服务器给浏览器的	服务器拿到cookie	分析里面的内容	校验cookie的合法性	根据cookie内容	进行具体的业务逻辑
##	应用
-	解析http无状态问题	7天免登录
-	cookie不一定只由服务器生成	前端同样可以生成cookie但是毫无意义 
##	cookie   当前讲的是基于node 下的express
-	给客户端种cookie不需要任何的库
	res.cookie('mignzi',JSON.stringify(obj))//会话cookie
	res.cookie('ming','hello',{maxAge:1000*30})//持久化30秒的cookie	到点会自动销毁
-	let cookieParser = require('cookie-parser')//是一个中间件
	app.use(cookieParser)
	req.cookies
	res.clearCookie('cookieName')//清除cookie
-	浏览器模板引擎
##	cookie和session配合
-	session会话存储是存储在服务器内存里面的	避免服务器断电影响	那么就要做session持久化
#	session
-	session就是会话
	-	前端通过浏览器去查看cookie时候	会看到cookie的过期时间是session	
	-	后端人那员通常把session会话存储		简称为session存储
-	特点
	-	存储在服务端
	-	存储的是浏览器和服务器之间沟通产生的一些信息
-	工作流程
	-	第一次浏览器请求服务器	服务器开辟内存空间	供session会话存储
	-	返回响应的时候	自动返回一个cookie	
	-	以后请求的时候	会自动携带这个cookie	给服务器
	-	服务器从cookie中拿到对应的session的id	去服务器中匹配
	-	服务器匹配信息	决定下一步逻辑
##	令牌盗取	就是	cookie被他人盗取
#	AJAX就是JS和XML
-	无刷新获取数据	纯数据
-	是一种使用现有标准的新方法
##	XML可扩展标记语言
-	被设计用来传输和存储数据
-	AJAX工作原理是相当于用户和服务器之间加了一个中间层(AJAX引擎)使得用户操作和服务器响应异步化
##	AJAX的缺点
-	没有浏览历史	不可以回退
-	存在跨域问题	用代理解决跨域问题
-	SEO不友好	搜索引擎优化
###	post请求注意加上有一句
-	xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')//设置特殊的请求头
-	用于解析post请求请求体参数	参数的编码类型是
-	Content-Type 标头告诉客户端实际返回的内容的内容类型。
-	app.use(express.urlencoded({extend:true}))
-	ie发送get请求问题就是会总是走缓存	那么就要用欺骗Date.now()		来每次都是不同的字符串
-	res.send(123)不可以只返回数字	要数字.toString()
##	跨域	ajax请求可以发送	但是不可以获取数据	
-	跨域对服务器没有影响	对浏览器有影响
-	浏览器为了安全	而采用同源策略
##	同源策略是一个安全策略		netspace网景公司提出
-	web是构建在同源策略之上的
-	所谓同源	也称为同域	是指协议	域名	端口都要相同
###	非同源受到哪些限制
-	cookie不可以读取
-	dom无法获得
-	ajax请求不可获取数据
###	form表单跨域不会被拦截
-	ajax发的请求------ajax引擎-------听从同源策略
-	form发请求--------浏览器其他模块------不听从同源策略
#	promise
-	promise抽象表达:
-	promise是一门新的技术	ES6规范
-	promise是js中进行异步编程的新解决方案
-	promise具体表达:
-	promise是一个构造函数
-	promise对象用来封装一个异步操作并且可以获取成功和失败的结果值
###	promise初始状态是pending 表示是初始的	未确认的
-	var promise1 = new Promise(function(resolve,reject){
	//excutor执行器函数	同步回调函数
	console.log('excutor()')
	setTimeout(function(){
		resolve('foo')
	},1000)
})//promise封装了一个定时器的异步操作
promise1.then(function(value){//异步执行成功的回调函数
	console.log(value)
})
###	使用promise封装异步ajax请求
-	function myAsyncFunction(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest()
		xhr.open('GET',url)
		xhr.onload = () => resolve(JSON.parse(xhr.responseText))//成功回调
		xhr.onerror = () => reject(xhr.statusText)//出错的回调
		xhr.send()
	})
}
**自己写promise封装**
	function promiseAjax(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest()
		xhr.open('GET',url)
		xhr.send()
		xhr.onreadystatechange = () => {
			if(xhr.readyState!==4)return
			if(xhr.status >= 200 && xhr.status < 300){
				resolve(JSON.parse(xhr.response))//resolve交出正确数据
			}else{
				reject(new Error('request error status:'+xhr.status))//交出错误数据
			}
		}
	})
}
	promiseAjax('url')
	.then(
		data => {
			console.log('yes',data)//正确数据的输出
		},
		error => {
			alert(error.message)//错误数据的输出
		}
	)
**async/await	解决回调地狱的终极解决方案	更加精简**
-	async function request(){
	try{
		const result = await doSimething()
		const newResult = await doSomethingElse(result)
		const finalResult = await doThirdThing(newResult)
		console.log('Got the final result:' + finaResult)
	}catch(error){
		failureCallback(error)
	}
}
###	改变promise状态(resolve reject)和指定回调函数(.then .catch)谁先谁后	常规是先指定回调函数	指定不是执行	后来改变状态
-   状态改变一次之后不会再改变了    状态只改变一次  分先后顺序
-   没有定时器的时候	就是先改变状态	后指定回调函数
-   先是回调    还是状态    看定时器的时间设定  短的优先
-   fn (){}//在类里面放在原型对象上面
-	fn = () => {}//放在实例对象上面
##	async和await作用
-	简化promise对象的使用	不要通过then指定回调函数去结果数据
-	是回调地狱的终极解决方案
##  宏队列和微队列
-	宏队列
	-	dom事件回调
	-	ajax回调
	-	定时器回调
-	微队列
	-	promise回调
	-	mutation()回调
##  await在console.log()之前执行
async function async1(){
	console.log('async start')
	await async2()//相当于.then 函数来执行  
	console.log('async end')//放进微队列
}
###	AJAX请求和http请求的关系	AJAX请求是特殊的http请求
-	AJAX请求获取数据	不需要整个页面的刷新
-	只有XHR或者fetch发出的才是ajax请求	其他所有的都是非ajax请求
###	浏览器端收到响应
-	一般请求	浏览器会直接显示响应体数据	也就是刷新/跳转页面
-	ajax请求	浏览器不会对界面进行任何更新操作	只是调用监视的回调函数并传入响应相关数据
###	axios处理链流程
-	添加请求拦截器	在发请求之前执行
-	作用
	-	对请求的配置做一些处理	data header 
	-	对请求进行检查	不满足就不发请求
-	axios.interceptors.request.use(function (config) {
	console.log('req interceptor onResolved()')
	return config//必须返回config
})
-	**后面的请求拦截器会先console.log**
-	添加响应拦截器	得到响应后执行的回调函数
-	作用
	-	对请求成功的数据
	-	对请求失败的数据
-	axios.interceptors.response.use(
	function(response){
		console.log('res interceptor1 onResolved()')
		return response;
	},
)
#	webpack	模块打包器(构建工具)	遵循CommonJS规范的文件
-	webpack看来	前端所有资源文件作为**模块处理**
-	webpack不支持三点运算符的解析
##	五个核心概念
-	Entry	入口起点	指示webpack应该使用哪个模块	作为构建内部依赖图开始
-	Output	告诉webpack再哪里输出它所创建的bundles	以及如何命名这些文件	默认值是./dist
-	Loader	本身是运行在node.js里的js模块 让webpack能够去处理那些非js文件		webpack自身只能解析js json
-	Pulgins	插件可以用于执行范围更广的任务	打包优化和压缩	定义环境中的变量等
-	Mode	生产模式production和开发模式development
-	优点:
-	webpack可以编译打包js和json文件
-	可以将es6的模块化语法转换为浏览器可识别的语法
-	可以压缩代码
-	缺点:
-	不可编译打包css img等文件
-	不可将js的es6基本语法转化为es5以下的语法
##	打包样式文件中的图片资源
-	npm i file-loader url-loader -D
-	import img from './image.png'
-	图片编码格式base64
-	图片<8kb	转为base64		图片>8kb	不转为base64
-	file-loader和url-loader是一对兄弟
-	用的时候url-loader是对file-loader的上层封装
-	那么使用的时候都要安装
#	自动编译打包运行	webpack-dev-server
-	安装loader
-	npm i webpack-dev-server -D
-	自带了自动刷新效果	但是是整个页面刷新
-	那么避免页面复杂的时候	耗资源	
-	**那么用到了局部刷新	叫做热模替换HMR	是webpack提供的最有用功能**
-	不会在本地生成打包文件		只会在内存里面生成
	那么在devServer里面加上hot:true就实现了局部刷新
-	**html不支持热模替换	css支持**
-	npx webpack --watch	//内部启动服务器来监视文件的变化 但是	不会自动刷新浏览器	热模替换	代理	
##	消息订阅和发布机制	
	-	适用于任意组件之间通信
	-	缺点是乱像菜市场	没有集中式管理
##	VM是ViewModel	模板视图	
	-	完成了Data Bingdings	数据绑定
	-	DOM Listeners			DOM监听
##  -	(function(){})()//这是立即执行函数表达式
##	for in 可以遍历到myObject的原型方法method
##	person.constructor === Person
-	Object.getPrototypeOf(person) === Person.prototype
##	分页存储管理
-	页面和页表
-	例如32位的	操作系统	页的大小是2**12		则0---》2**20页逻辑地址
-	物理块的大小和页的大小一致
-	页表是记录逻辑空间（虚拟内存）中**每一页在内存中对应的物理块号**。
-	页号 P=逻辑地址/页大小
	页内地址 F=逻辑地址%页大小
	根据页表查得 2 号页对应着 25 号物理块
	物理地址 A=物理块号*页大小 + 页内地址
##	for循环头部的let不仅将i绑定到for循环快中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值。
##	数据的存储结构就是		数据的逻辑结构在计算机里面的表示
-	逻辑运算符两侧的运算对象可以是任何数据类型
-	在C程序中，函数调用能出现在表达式语句中
-	c程序中,外部类型的变量只能定义一次，但可在不同地方声明多次
-	磁盘上物理结构为**链接结构**的文件只能**顺序存取**；
##	ul li+li 表示ul下的第一个li的所有兄弟li节点
-	**内联**是将style写在<head></head>标签里面的，可以写很多标签的样式，**行内是将style写在目标标签里面**(比如说<p>标签)
##	箭头函数和非箭头函数的效率的比较
-	 handleClick = () => {
    console.log('this is:', this)
	}
-	构造函数来绑定函数	返回函数
-	 constructor () {
        super(props)
        this.handleClick = this.handleClick.bind(this)
    }
    handleClick () {
        console.log('this is:', this)
    }
-	结果是非箭头函数的效率更加高效
##	箭头函数没有自己的this		this的指向只有一个
-	function fun () {
	return () => {
	return () => {
	return () => {
	console.log(this.name)
	}
	}
	}
	}
-	**所有的内层函数都是箭头函数**，都没有自己的this，它们的this其实都是最外层函数的this。
##	某进程创建的若干个线程，这些线程不能共享的是
-	程序计数器
-	某线程的栈指针
##	标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。
-	但是，如果**模板字符里面有变量**，就不是简单的调用了，而是会将**模板字符串先处理成多个参数**，再调用函数
-	function getPersonInfo (one, two, three) {
	console.log(one)
	console.log(two)
	console.log(three)
	}
	const person = 'Lydia'
	const age = 21
	getPersonInfo `${person} is ${age} years old`
-	[“”, “ is ”, “ years old”] “Lydia” 21
-	.push(...)返回新数组的长度
##	Promise.all(iterable) 允许在 iterable 中使用 **non-promise 的“常规”值**
	通常，Promise.all(...) 接受含有 promise 项的可迭代对象（大多数情况下是数组）作为参数。但是，如果这些对象中的任何一个不是 promise，那么它将被“按原样”传递给结果数组。
-	但是race()不可以
-	typeof *  返回的是字符串形式  --》string
-	利用 sourcemap 可以定位到具体的出错代码文件的行、列信息
-	目标站点由wordpress搭建-->做渗透测试-->使用wpscan对网站进行扫描
##	相邻兄弟选择器+和~的区别：+会选取符合条件的**一个元素**进行获取（即3）		不可选择前面	
-	~会选取符合条条件的**所有元素**（即3和4）
##	max-height会覆盖掉 height, min-height又会覆盖掉max-height		
-	顺序是max-height-->height-->min-height
-	 while (cnt<N)
    {
        i = i + 2;
        cnt = cnt + i;
    }
-	cnt以2为基础来不断接近值		时间复杂度是O(N**(1/2))
-	var a  =10;
	(function(){console.log(a);let a = 20})()		//let换为var的时候结果是不一样 的
-	let a是cannot access a 		var a是undefined
##	let var 在for循环里面的作用域是不同 的
-	const fn = function(){}
	const res = JSON.stringify(fn)--》undefined		
-	document.body.style = 'background-color':'#fff'
-	document.body.style.setProperty('background-color','#fff')
##	slice() 方法可从已有的数组中返回选定的元素。
-	但是返回的数据类型是 **array** 不是 string 这点要注意一下！
##	数组里面最后一个元素
-	slice(-1)		pop()		arr[arr.length-1]
-	slice不会改变原来数组		是浅层复制
-	slice是左闭右开的		返回的数据类型是array数据类型的
##	http1 rmfhttp2
-	http1
-	高延迟 — 队头阻塞(Head-Of-Line Blocking)
-	队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。
-	解决方案就是
1.	将同一页面的资源分散到不同域名下，提升连接上限。虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。
2.	减少请求数量
3.	内联一些资源：css、base64 图片等
4.	合并小文件减少资源数
-	无状态特性 — 阻碍交互
-	无状态是指协议对于连接状态没有记忆能力。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。上一次请求验证了用户名密码，而下一次请求服务器并不知道它与上一条请求有何关联，换句话说就是掉登录态。
-	明文传输 — 不安全性
-	不支持服务端推送
-	http2
-	二进制分帧 - HTTP2 性能增强的核心
	多路复用 - 解决串行的文件传输和连接数过多
-	二进制分帧
	首先，HTTP2 没有改变 HTTP1 的语义，只是在应用层使用二进制分帧方式传输。因此，也引入了新的通信单位：帧、消息、流。
	分帧有什么好处？服务器单位时间接收到的请求数变多，可以提高并发数。最重要的是，为多路复用提供了底层支持。
-	多路复用
	一个域名对应一个连接，一个流代表了一个完整的请求-响应过程。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。
-	HTTP2 的缺陷
-	TCP 的队头阻塞并没有彻底解决
-	TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。
-	多路复用导致服务器压力上升
-	多路复用容易 Timeout
-	大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。
##	Object.defineProperty()
-	Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
-	直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用
-	const object1 = {};
	Object.defineProperty(object1, 'property1', {
	value: 42,
	writable: false
	});

	object1.property1 = 77;
	// throws an error in strict mode

	console.log(object1.property1);
	// expected output: 42
-	configurable
	当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
	默认为 false。
-	enumerable
	当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。
	默认为 false。
##	rmfVue
-	computed 和 watch 有什么区别及运用场景
-	computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计
	算 computed 的值。
-	watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。
-	当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。
-	当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们
	执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。
-	为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？
-	Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来
	实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。
-	Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。
-	Vue 中的 key 到底有什么用？
-	key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快
-	diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点
-	因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导
	致之前节点的状态被保留下来,会产生一系列的 bug。
-	key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1)
-	谈一谈 nextTick 的原理
-	JS 执行是单线程的，它是基于事件循环的。
-	所有同步任务都在主线程上执行，形成一个执行栈
-	主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
	一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
-	消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结
	束后，都要清空所有的 micro task。
-	Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
-	如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。
-	事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
-	为了协调异步任务，Node 提供了四个定时器，让任务可以在指定的时间运行		后两个是 Node 独有的
-	setTimeout()
	setInterval()
	setImmediate()
	process.nextTick()
-	node.js 核心特性
-	单线程
-	非阻塞I/O
-	事件驱动
	浏览器端把鼠标点击、键盘按键等定义为事件，而node把网络请求、I／O操作等也看作事件，严格来说，一切动作都是事件，这就是事件驱动的思想
	在程序启动时，便进入事件循环，不断遍历执行事件队列中产生的事件，而在执行过程中，又会产生新的事件，因此称为事件循环
-	宏任务队列包含任务: A1, A2 , A3
	微任务队列包含任务: B1, B2 , B3
-	首先执行宏任务队列开头的任务，也就是 A1 任务，执行完毕后，在执行微任务队列里的所有任务，也就是依次执行B1, B2 , B3，执行完后清空
	微任务队中的任务，接着执行宏任务中的第二个任务A2，依次循环。
-	 宏任务 Macrotask队列真实包含任务：
	script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering
-	Vue 组件 data 为什么必须是函数 ?
-	因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。
-	所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在
	以上问题。
-	base64图片的使用是src='base64图片的数据'
##	v-model
-	一方面modal层通过defineProperty来劫持每个属性，数据劫持,一旦监听到变化通过相关的页面元素更新。另一方面通过编译模板文件，为控件的v-model绑定input事件，从而页面输入能实时更新相关data属性值。
-	首先在页面初始化时候，vue的编译器会编译该html模板文件，将页面上的dom元素遍历生成一个虚拟的dom树。再递归遍历虚拟的dom的每一个节点。当匹配到其是一个元素而非纯文本，则继续遍历每一个属性。
??如果遍历到v-model这个属性，则会为这个节点添加一个input事件，当监听从页面输入值的时候，来更新vue实例中的data想对应的属性值。
-	同样初始化vue实例时候，会递归遍历data的每一个属性，并且通过defineProperty来监听每一个属性的get，set方法，从而一旦某个属性重新赋值，则能监听到变化来操作相应的页面控制。
-	v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：
	text 和 textarea 元素使用 value 属性和 input 事件；
	checkbox 和 radio 使用 checked 属性和 change 事件；
	select 字段将 value 作为 prop 并将 change 作为事件。

-	Object.defineProperty(data,"name",{
	get(){
		return data["name"];
	},
	set(newVal){
		let val=data["name"];
		if (val===newVal){
			return;
		}
		data["name"]=newVal;
		// 监听到了属性值的变化,假如node是其对应的input节点
		node.value=newVal;
	}    
})
-	vue数据绑定是通过 数据劫持和观察者模式 的方式来实现的
##	rmf虚拟DOM和diff算法
-	什么是虚拟DOM（virtual DOM）：
	所谓的虚拟 dom，也就是我们常说的虚拟节点，它是通过JS的Object对象模拟DOM中的节点，然后再通过特定的render（渲染）方法将其渲染成真实的DOM的节点。
-	真实DOM和虚拟DOM的区别：
	虚拟DOM不会进行排版与重绘操作
	真实DOM频繁排版与重绘的效率是相当低
	虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分，最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗
	虚拟DOM有效降低的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部
diff算法
-	diff算法的原理：
	逐步解析newVdom的节点，找到它在oldVdom中的位置，如果找到了就移动对应的DOM元素，如果没找到说明是新增节点，则新建一个节点插入。遍历完成之后如果oldVdom中还有没处理过的节点，则说明这些节点在newVdom中被删除了，删除它们即可。
-	delete add move
-	1、产生两个虚拟DOM树：newVDom，oldVDom。
2、oldVDom和真实DOM保持一致
3、操作的newVDom
4、操作完毕后，通过diff算法对比newVDom和oldVDom的差异，并在oldVDom标注哪些节点要删除，哪些节点要增加，修改
5、根据oldVDom操作真实的DOM，让真实Dom和oldVDom保持一致
-	解决浏览器性能
-	使用原生js  jQuery操作DOM	不用VDOM导致代码耦合性高难以维护	频繁重绘重排	消耗性能
-	那么VDOM来操作	减少了重绘重排	提高渲染效率
-	虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI	
-	虚拟 DOM 到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。
-	{
	tag: 'div',
	props: {
		id: 'app'
	},
	chidren: [
		{
		tag: 'p',
		props: {
			className: 'text'
		},
		chidren: [
			'hello world!!!'
		]
		}
	]
	}
-	观察主流的虚拟 DOM 库（snabbdom、virtual-dom），通常都有一个 h 函数，也就是 React 中的 React.createElement，以及 Vue 中的 render 方法中的 createElement
##	组件编写方式与 Vue 实例的区别：
1 	data是个函数（面试题）
	一个组件的 data 选项必须是一个函数,且要有返回object，只有这样，每个实例（vue组件对象）就可以维护一份被返回对象的独立的拷贝，否则组件复用时，数据相互影响,也就是说，组件的作用域是独立的。
2	组件模板（html代码）只能有一个根标签
3	组件名不可和html官方的标签名同名
4	组件没有el选项，只有根实例存在el
5	书写：组件名如果小驼峰，那么使用时，用短横线（羊肉串的写法），或者组件名直接都用大驼峰。
##	动态创建dom
-	vue更新dom是异步队列的方式。vue的数据更新后，不会理解更新dom。如果想在dom更新后，做些事情，就用nextTick。
-	this.$nextTick(回调函数);这个函数里是知道什么时候处理dom的，当你传入回调函数时，nextTick内部会在处理完dom后，调用该回调函数
-	this.$nextTick(()=>{
	new myObject('ObjectName',{config})	
	})
##	
-	Fetch：
	fetch是ES6新增的，Fetch是基于promise设计的。fetch不是ajax的进一步封装，而是原生js。Fetch函数就是原生js，没有使用XMLHttpRequest对象。
##	rmfString
-	查找字符串中的字符串	indexOf() 方法返回字符串中指定文本首次出现的索引（位置）
-	lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引
-	search() 方法搜索特定值的字符串，并返回匹配的位置
-	search() 方法无法设置第二个开始位置参数。
-	indexOf() 方法无法设置更强大的搜索值（正则表达式）。
-	slice(start, end) 提取字符串的某个部分并在新字符串中返回被提取的部分。slice(-1)是倒数第一个数据	start end
-	substring() 类似于 slice()。	不同之处在于 substring() 无法接受负的索引。	start end
-	substr() 类似于 slice()。	不同之处在于第二个参数规定被提取部分的长度。	start length
-	replace() 方法用另一个值替换在字符串中指定的值	不会改变调用它的字符串。它返回的是新字符串。
-	默认地，replace() 只替换首个匹配	replace() 对大小写敏感。
-	toUpperCase() 把字符串转换为大写
-	通过 toLowerCase() 把字符串转换为小写
-	所有字符串方法都会返回新字符串。它们不会修改原始字符串。
-	trim() 方法删除字符串两端的空白符
-	charAt(index) 方法返回字符串中指定下标（位置）的字符串		str.charAt(0)
-	charCodeAt(index) 方法返回字符串中指定索引的字符 unicode 编码	
-	如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串。
-	它是只读的。str[0] = "A" 不会产生错误（但也不会工作！）
-	当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
	当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
-	两个typeof返回的是不一样的	一个返回的是Object		一个是string
-	toLocaleLowerCase()		toLocaleUpperCase()
-	sup() 方法用于把字符串显示为上标		str.sup()		sub()下标
-	strike()用删除线来显示字符串
-	link()将字符串显示为链接
-	small()小字号来显示字符串		big()大字号来显示字符串
-	match()		str.match(pattern)	返回匹配的符合的正则的数据数组
-	str.fontsize(3)使用指定的尺寸来显示字符串
-	bold()粗体来显示字符串
-	str.fontcolor('green')
-	去除字符串的最后一个字符		str.substr(0,str.length-1)		str.substring(0,str.length-1)
-	var str2 = new String("http://www.xyz.com");
	两者的值相等，但不全等，因为类型不同，前者为string类型，后者为object类型
	console.log( str2.valueOf() === str2 );   // false
-	valueOf() 方法返回指定对象的原始值。
-	!==	 不绝对等于（值和类型有一个不相等，或两个都不相等）		
##	rmfvuex
-	组件之间的共享数据的方式
-	父向子传值		v-bind属性绑定
-	子向父传值		v-on事件绑定
-	兄弟组件之间共享数据		EventBus
-	$on		接收数据的组件
-	$emit	发送数据的组件
-	Vuex
-	vuex的核心概念		state   mutations    action  	getter
-	组件全局状态(数据)管理的机制		实现组件之间数据的共享
-	vuex管理共享的数据	易于开发和后期维护
-	高效实现组件之间的数据共享	提高开发效率
-	存在vuex里面的数据都是响应式的	可实时保持数据与页面同步
-	组件之间的共享数据是适合存在vuex中		但是对组件的私有数据存在自身的data里面
-	npm i vuex
-	弄个store.js文件
-	import Vuex from 'vuex'
-	Vue.use(Vuex)
-	const store = new Vuex.Store({
	state:{}
	})
-	export default new Vuex.Store({
	state:{count:0}
	})
-	store挂载到vue实例中
-	所有的组件可以从store中获取全局的数据
-	state
-	state提供唯一的公共数据源	所有的共享数据都统一放到store里面的state存储
-	组件访问state中数据的方式
-	this.$store.state.全局数据名称
-	也可以用另外一种方式访问state里面的数据
-	import {mapState} from 'vuex'
-	computed:{...mapState(['count'])}-->拿到了state里面的count数据
-	vuex不允许组件直接修改全局的state里面的数据		this.$store.state.count++-->错误，直接改变全局数据
-	mutations用于变更store里面的数据		可以集中监控数据的变化	不用去很多组件里面寻找变化 的位置
-	mutations:{add(state){state.count++}}
-	methods:{handlel(){this.$store.commit('add')}}-->组件里面methods来使用store里面的数据mutation方法
-	记得使用commit('xxx')
-	触发mutation里面的函数的时候不止可以使用state里面的数据还可以传入参数this.$store.commit('add',args1)
-	commit是触发mutaion里面的函数的一种方式		
-	还有一种方式是mapMutations
-	import {mapMutations} from 'vuex'
-	组件里面使用methods:{...mapMutations(['add','addN']),handler1(){this.add()}}-->调用mutations里面
	的方法
-	使用了add  addN函数
-	mutations里面不可以写异步的代码setTimeout()
-	Action用于异步操作 不可用mutations			但是在Action中还是要通过触发mutation来间接改变数据
-	actions:{addAsync(context){setTimeout(()=>{context.commit('add')},1000)}}	context可以理解为
	new出来的store		就是this
-	组件里面使用actions里面的异步操作		this.$store.dispatch('addAsync')
-	触发actions的方式
-	import {mapActions} from 'vuex'		省略了
-	组件里面使用methods:{...mapActions(['addAsync']),methodhandler(){this.addAsync()}}
-	mapActions   mapState  mapMutations是把全局的方法和属性映射为组件自己的方法和属性
-	getter	来对store里面的state数据进行加工处理形成新的数据		类似于vue的计算属性
-	getter  不改变store里面的数据   只是加工包装state里面的数据来展示
-	getters:{showNum(){return "当前最新的数量['+state.count+']"}}
-	使用getter
-	this.$store.getters.showNum
-	import {mapGetters} from 'vuex'
-	computed:{...mapGetters(['showNum'])}
-	<Input @change='inputChange'>
-	methods:{inputChange(e){e.target.value}}		-->e.target.value是文本框的数据
-	
-	
-	
-	
-	
-	








-	js实现indexOf方法
-	idnexOf		字串在父串首次出现的位置		indexOf要求传入起始位置		否则从0开始匹配
-	function myIndexOf(str1,str2,n){//target是开始匹配的位置
    let i
    let len1 = str1.length
    let len2 = str2.length
    if(n === undefined || n === null || n <= -1){
    i = 0//i是输入 的起始位置       特殊情况分为undefined null   -1
    //起始位置也要和父串的长度进行比较  不可超过len2-1
        }else if(n > len2){
    return -1
    }else{
    i = n
    }
    //开始比较字串父串的长度   len1  len2
    if(len1>len2){
    return -1
    }else{
    for(var j = i;j < len2;j++){
    if(str1 === str2.substr(j,len1))
    return j
    }
    }
    return -1
    
}
       
let str1 = 'mf'
let str2 = 'rmf123'
let res  = myIndexOf(str1,str2,0)
console.log(res)
-	js实现rmf栈实现队列
-	//两个栈实现队列的操作
//先进后出实现先进先出
//设置一个入队栈stack1   一个出队栈stack2
//入队是push       出队是pop
//出队的 时候将入队的顺序倒序
let stack1 = []
let stack2 = []
function add(node){
    while(stack2.length){
    stack1.push(stack2.pop())
}
stack1.push(node)
}
function poll(){
    if(stack2.length === 0){
    while(stack1.length !== 0){
    stack2.push(stack1.pop())
}
}
return stack2.pop() 
}
-	var myQueue = function(){this.stack = []}
	myQueue.prototype.add = function(node){this.stack.push(node)}
	myQueue.prototype.poll = function(){
		var temp = []
		for(var i = 0;i < this.stack.length;i++)temp.push(this.stack.pop())
		let res = temp.pop()
		for(var i = 0;i < this.stack.length;i++)temp.push(this.stack.push(temp.pop()))
		return res
	}

-	队列实现栈
## rmfcall rmfapply rmfbind
-	数组取得最大的数据值		Math.max.apply(null,arr1)
-	如果 apply() 方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。

-	实现bind函数
-	//实现bind函数	在Function的原型对象上面定义bind函数
	Function.prototype.myBind = function(obj){
	if(typeof this !== 'function'){
	throw new Error('Function.prototype.bind-what is trying to be bound is not callable')
	}
	var _this  = this
	let objArgs = Array.prototype.slice.call(arguments,1)
	var fn = function(){}
	var bound = function(){
	var params = Array.prototype.slice.call(arguments)
	return _this.apply(this.constructor === _this ? this:obj,objArgs.concat(params))
	}
	fn.prototype = this.prototype
	bound.prototype = new fn()
	return bound
	}
-	构造函数实例的constructor属性永远指向构造函数本身
-	bind函数的作用
-	如果某些函数，前几个参数已经 “内定” 了，我们便可以用 bind 返回一个新的函数。也就是说，bind() 能使一个函数拥有预设的初始参数。
-	ployfill填充物
-	什么时候容易丢失 this 指向？恩，setTimeout 是一个场景，很容易把 this 指向 window，当然，setInterval 也是一样。当使用对象的方法时，需要 this 引用对象，你可能需要显式地把 this 绑定到回调函数以便继续使用对象。
-	window.setInterval(canvas.render, 1000 / 60);
-	var canvas = {
	render: function() {
		this.update();
		this.draw();
	},}
-	this指向指向了window		丢失了this指向	那么解决问题
-	window.setInterval(canvas.render.bind(canvas),1000/60)
-	bind函数来绑定指向的问题		解决了this指向丢失的问题
-	伪数组转换为真数组
-	Array.prototype.slice.apply(arguments)
-	bind可以用来封装绑定一些函数
-	var mySlice = Array.prototype.slice;var slice = Function.prototype.call.bind(mySlice)
-	slice(arguments,1)		使用的时候直接使用函数名
-	var myForEach = Array.prototype.forEach;var forEach = Function.prototype.call.bind(myForEach)
-	使用自定义的bind函数的时候		let bound = fn.myBind(obj,1);bound是obj绑定函数fn的函数名;
-	var person = new bound();		person绑定了函数有着obj的指向
-	bind函数的使用有俩个步骤	首先是绑定函数的指向的问题		然后就是函数的new的操作	一个变量名去承接这一个绑定函数
-	let fn  = function(){console.log(this)}		fn()	-->window{}
-	let bound = fn.myBind(obj);bound()		-->obj的内容
##	rmfh5
-	var canvas = document.getElementById('myCanvas');
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = '#FF0000';
    ctx.fillRect(0, 0, 100, 100);
-	<input list="browsers">			定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。
	<datalist id="browsers">
	<option value="Internet Explorer">
	<option value="Firefox">
	<option value="Chrome">
	<option value="Opera">
	<option value="Safari">
	</datalist>
-	<article>	定义页面独立的内容区域。
	<article>
	<h1>Internet Explorer 9</h1>
	<p>rmf</p>
	</article>
-	<aside>	定义页面的侧边栏内容。
-	<details>		<details> 标签规定了用户可见的或者隐藏的需求的补充细节。
	<summary>Copyright 1999-2011.</summary>
	<p> - by Refsnes Data. All Rights Reserved.</p>
	<p>All content and graphics on this web site are the property of the company Refsnes Data.</p>
	</details>
-	<dialog> 标签定义一个对话框、确认框或窗口。
-	<dialog open>This is an open dialog window</dialog>
-	<figure> 标签规定独立的流内容（图像、图表、照片、代码等等）。
	<figure> 元素的内容应该与主内容相关，同时元素的位置相对于主内容是独立的。如果被删除，则不应对文档流产生影响。
-	<figcaption> 标签为 <figure> 元素定义标题。
	<figcaption> 元素应该被置于 <figure> 元素的第一个或最后一个子元素的位置。
-	<footer> 标签定义文档或者文档的一部分区域的页脚。
	<footer> 元素应该包含它所包含的元素的信息。
-	<header> 标签定义文档或者文档的一部分区域的页眉。
	<header> 元素应该作为介绍内容或者导航链接栏的容器。
-	<mark> 标签定义带有记号的文本。
-	<p>Do not forget to buy <mark>milk</mark> today.</p>
-	<meter> 标签定义度量衡。仅用于已知最大和最小值的度量。	比如：磁盘使用情况，查询结果的相关性等。	
-	<meter value="2" min="0" max="100">2 out of 10</meter><br>
	<meter value="0.6">60%</meter>
-	<nav> 标签定义导航链接的部分。
-	<nav>
	<a href="/html/">HTML</a> |
	<a href="/css/">CSS</a> |
	<a href="/js/">JavaScript</a> |
	<a href="/jquery/">jQuery</a>
	</nav>
-   <progress> 标签定义运行中的任务进度（进程）。
-	<ruby> 标签定义 ruby 注释（中文注音或字符）。
	在东亚使用，显示的是东亚字符的发音。
-	<rp>在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。
-	<section> 标签定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。
-	<time> 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。t该元素能够以机器可读的方式对日期和时间进行编码，这样，举
	例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果。标签不会在任何浏览器中呈现任何特殊效果。
-	<wbr> 标签可以用来定义HTML文档中需要进行换行的位置，与<br>标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 
	<wbr> 标签的位置进行换行
-	<bdi> 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。
-	h5中删除的元素
-	<big><center><strike><font><dir>标签表示一个目录
##	rmfCss3
-	多列布局方式
-	column-count	column-width	column-gap		column-rule
-	将 div 元素中的文本分为三列	column-count:3
-	column-width:20px		列的宽度
-	column-gap:20px		列之间的宽度
-	column-rule:3px outset #000		用来指定列之间的规则	宽度	样式	颜色
-	column-count及column-width属性可以合并起来使用，columns
-	样式的规则		hidden(隐藏)	dotted(点状)	solid(实线)		double(双实线)	dashed(虚线)
-	宽度的规则		thin(细边框)	medium(中等边框)	thick(粗边框)	length(指定宽度)
-	CSS3提供rgba来支持为元素设置透明度
-	rgba(255, 0, 0, 0.75)
-	还有提供透明度的属性
-	display(none会从dom树中移除 动态改变此属性时会引起重排)	绑定元素的事件任然存在
-	opacity(影响子元素 元素隐藏	依然占据空间 会被继承 但是绑定元素的事件依然会被触发)			
-	rgba(不影响子元素 依然可以触发绑定的事件)
-	visibility(hidden  元素会隐藏但是不会消失 依然占据空间 会被子元素继承	不会触发该元素已经绑定的事件 引起重绘)
-	z-index(元素要保证脱离文档流的前提下,才会生效z-index:-1 会被继承  无法响应已经绑定的事件)
-	opacity属性将某元素及其所有的子元素都应用透明样式，而rgba只在被设置的元素应用透明样式并不影响其子元素。
-	border-radius是四个属性的缩写
-	border-top-left-radius、border-top-right-radius、border-bottom-right-radius，和 border-bottom-left-radius
-	线性渐变和径向渐变
-	linear-gradient	linear-gradient(135deg, black, white);
-	渐变轴是相对笛卡尔坐标系的y轴来设置deg的
-	radial-gradient	 radial-gradient(#000, #fff);
-	多背景图片支持
-	box-sizing设置盒模型	content-box		border-box
-	content-box  是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到
	最后绘制出来的元素宽度中。
-	border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px
	会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。
-	text-shadow		box-shadow
-	text-shadow为文字添加阴影		每个阴影值由元素在X和Y方向的偏移量、模糊半径和颜色值组成。
-	text-shadow: 2px 2px 2px green;
-	box-shadow 属性用于在元素的框架上添加阴影效果。
-	box-shadow: 5px 5px 2px  green;
-	inset
	如果没有指定inset，默认阴影在边框外，即阴影向外扩散。
	使用 inset 关键字会使得阴影落在盒子内部，这样看起来就像是内容被压低了。 此时阴影会在边框之内 (即使是透明边框）、背景之上、内容之下。
-	该属性可设置的值包括阴影的X轴偏移量、Y轴偏移量、模糊半径、扩散半径和颜色。
-	CSS3提供@font-face特性为页面自定义字体的展示提供支持。
-	@font-face { 
    font-family: BorderWeb; 
    src:url(BORDERW0.eot); 
	}
-	使用的时候的样式	font-family: "BorderWeb";
-	媒体查询（media queries）可以让你为不同的设备基于它们的能力定义不同的样式。
-	@media all and (max-width:480px){#sidebar {   float: none;   clear: both;  }   }
-	@media是关键字（可以将其理解成css的一种语法糖，跟@import类似）
-	screen，这个关键字就是我们所说的媒体类型（这里screen其实就是电脑屏幕
-	all	screen print(打印模式)	是常用的媒体类型		handheld(手持设备)	projection	演示模式、幻灯片等	tv电视媒体
-	speech	 听觉设备，应用于屏幕阅读器等发声设备。
-	not或者only这两个关键字修饰媒体类型		不是这种媒体		只是这种媒体
-	可以自动识别屏幕宽度、并做出相应调整的网页设计。
-	@media only screen and (min-width: 768px) {
    .col-1 {width: 8.33%;}
    .col-2 {width: 16.66%;}
    .col-3 {width: 25%;}
	}
-	transition(过渡) transform(变化) animation(动画)
-	transition主要包含四个值，transition-property（执行变换的属性），transition-duration（执行变换的持续时间）,
-	transition-timing-function(变换的速率变化模式),transition-delay(变换延迟时间)。
-	ease（逐渐变慢）linear（匀速）ease-in（加速）ease-out（减速）ease-in-out（加速然后减速）
-	transform的所有变换都是围绕着x轴,y轴，中心点来进行变换的
-	transform属性允许你旋转，缩放，倾斜或平移给定元素
-	transform:rotate(30deg)旋转	
-	transform:translate(-50%,-50%)		translateX()	translateY()
-	transform:scale(0.5)x,y轴的缩放		scaleX()		scaleY()
-	transform:skew(20deg)		skewX()		skewY()
-	backface-visibility该属性用于隐藏内容的背面。默认情况下，背面可见的，也就是当翻转后，背面内容仍然可见。但是当	
	backface-visibility设置为hidden的时候，旋转后内容将会被隐藏
-	animation		animation-name(动画名，也就是keyfram中定义的动画名)		animation-duration（动画持续时间）
-	animation-timing-function（动画变化的速率）			animation-delay（动画延迟播放的时间）
-	animation-iteration-count（动画循环的次数，infinite是无限次）  
-	animation-direction（动画的方向）(alternate(动画正向反向交替进行) reverse normal)
-	animation-play-state动画的播放状态	
-	animation: 3s ease-in 1s infinite reverse both running slidein;
-	选择器
-	p:first-child	选择属于父元素的第一个子元素的每个 <p> 元素
-	p::first-letter	选择每个 <p> 元素的首字母
-	:first-of-type	p:first-of-type	选择属于其父元素的首个 <p> 元素的每个 <p> 元素。元素不一定是第一个	只要类型是第一个
-	:in-range	input:in-range	选择其值在指定范围内的 input 元素。min=''  max=''
-	:invalid	input:invalid	选择具有无效值的所有 input 元素。
-	input:invalid {
	border: 2px solid red;
	}
-	:lang(language)	p:lang(it)	选择 lang 属性等于 "it"（意大利）的每个 <p> 元素。
-	p:lang(en)
	{ 
	background:yellow;
	}
-	:last-child	p:last-child	选择属于其父元素最后一个子元素每个 <p> 元素。		元素必须是最后一个
-	:last-of-type	p:last-of-type	选择属于其父元素的最后 <p> 元素的每个 <p> 元素。	元素类型是最后一个
-	:link	a:link	选择所有未访问过的链接。
-	a:link
	{
	background-color:yellow;
	}
-	:not(selector)	:not(p)	选择非 <p> 元素的每个元素。
-	:not(p)
	{
	color:#ff0000;
	}
-	input:not([type = radio]) {
	border: 1px solid #ccc;
	}
-	:nth-child(n)	p:nth-child(2)	选择属于其父元素的第二个子元素的每个 <p> 元素。
-	p:nth-child(2)
	{
	background:#ff0000;
	}
-	:nth-last-child(n)	p:nth-last-child(2)	同上，从最后一个子元素开始计数。
-	:only-child	p:only-child	选择属于其父元素的唯一子元素的每个 <p> 元素。	父元素有且只有一个p元素	不可容纳其他任何元素
-	:only-of-type	p:only-of-type	选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。父元素p元素的类型有且只有一个
-	:optional	input:optional	选择不带 "required" 属性的 input 元素。
-	input:optional {
	background-color: yellow;
	}
-	:out-of-range	input:out-of-range	选择值超出指定范围的 input 元素。
-	input:out-of-range {
	border: 2px solid red;
	}
-	::placeholder		input::placeholder	选择已规定 "placeholder" 属性的 input 元素。
-	:read-only	input:read-only	选择已规定 "readonly" 属性的 input 元素。
-	input:read-only {
	background-color: yellow;
	}
-	:required	input:required	选择已规定 "required" 属性的 input 元素。
-	input:required {
	background-color: yellow;
	}
-	:root	:root	选择文档的根元素。
-	:root
	{
	background:#ff0000;
	}
-	::selection	::selection	选择用户已选取的元素部分
-	::selection
	{
	color:#ff0000;
	}
-	:target	#news:target	选择当前活动的 #news 元素。			#news是一个元素的id		是a超链接的href		
-	id='news'		href='#news'
-	:target
	{
	border: 2px solid #D4D4D4;
	background-color: #e5eecc;
	}
-	:valid	input:valid	选择带有有效值的所有 input 元素。
-	input:valid {
	background-color: yellow;
	}
-	相邻兄弟选择器		+
-	选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器。
-	这个也会循环查找，即当两个兄弟元素相同时，会一次循环查找
-	li + li {
        color:red;
    }
-	<li>List item 1</li>
    <li>List item 2</li>
    <li>List item 3</li>
-	循环查找		那么2 3就会变色
-	~ 选择器
　　作用是查找某一个指定元素的后面的所有兄弟结点。
-	如果需要在内联的场景下使用flex布局，则需要设置display: inline-flex。
-	order的用法如下
	用整数值来定义排列顺序，数值小的排在前面。默认值为0，且可以设置为负值。
-	background-image属性添加背景图片。
	不同的背景图像和图像用逗号隔开，所有的图片中显示在最顶端的为第一张。url(img_flwr.gif), url(paper.gif); 
-	background-size指定背景图像的大小	 background-size:80px 60px;
-	background-origin 属性指定了背景图像的位置区域。  background-origin:content-box;	背景图片的相对位置
-	content-box, padding-box,和 border-box区域内可以放置背景图像。
-	background-clip背景剪裁属性是从指定位置开始绘制。
-	text-shadow并不是在CSS3中新增的的新属性，在CSS2.0时就已经有了这个属性了，之后在CSS2.1不知何故被移除了，最终在CSS3中又重新收纳
	了这个属性。
-	text-shadow还是box-shadow，都是支持多重阴影的
-	box-reflect	box-reflect：包括3个值
-	direction 定义方向，取值包括 above 、 below 、 left 、 right。
-	 offset定义反射偏移的距离，取值包括数值或百分比，其中百分比根据对象的尺寸进行确定。默认为0。
-	mask-box-image定义遮罩图像，该图像将覆盖投影区域。如果省略该参数值，则默认为无遮罩图像。
-	-webkit-box-reflect:below 10px -webkit-linear-gradient(transparent,transparent 50%,rgba(0,0,0,.8)); 
-	border-radius
-	设置1个值时，四个方向都使用同一个值
	设置2个值时，左上和右下使用第一个值，右上和左下使用第二个值
	设置3个值时，左上使用第一个值，右上和左下使用第二个值，右下使用第三个值
	设置4个值时，分别对应左上、右上、左下、右下的顺序进行赋值
-	border-top-left-radius，左上角
	border-top-right-radius，右上角
	border-bottom-right-radius，右下角
	border-bottom-left-radius，左下角
-	若设置一个值，则表示水平半径和垂直半径相同
	若设置两个值，则表示分别按顺序设置水平、垂直半径
##	rmf浏览器内存泄露
-	setInterval用多了，会占用大量的内存，要我们必须及时清理		否则，运行时间一长，极有可能导致浏览器崩溃！
-	几种常见的js内存泄露
-	**意外的全局变量**
-	haorooms ="这是一个全局的haorooms"
-	生成了一个全局的haorooms		我们在编程中尽量少的避免全局变量！
-	全局变量可能由this创建
-	function foo() {
	console.log(this)
	}
	foo()
	// Foo 调用自己，this 指向了全局对象（window）
-	**没有及时清理的计时器或回调函数**		setInterval定时器的清除直接在定时器里面循环进行即可
-	function b() {
    var a = setInterval(function() {
        console.log("Hello");
        clearInterval(a);
        b();                
    }, 50);
	}
	b();
-	不断创建定时器		和		清除定时器		setTimeout()函数是在返回的函数里面直接调用返回的函数
-	返回的函数里面第一步就是清除定时器		clearTimeout()
-	function time(f, time) {
    return function walk() {
     clearTimeout(aeta);
        var aeta =setTimeout(function () {
            f();
            walk(); 
        }, time);
    };
	}
	time(updateFormat, 1000)();
-	**脱离 DOM 的引用**
-	保存 DOM 节点内部数据结构很有用。
-	var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image'),
    text: document.getElementById('text')
	};
-	 DOM 元素存在两个引用：一个在 DOM 树中，另一个在elements字典中。
-	决定删除这些行时，需要把两个引用都清除。
##	变量的声明
-	var a = 1,
		b = 2,
		now = new Date();
-	插入迭代值	var name = values[i++];
-	不提倡new Array()  new Object()		而是const a = [1,2,3]	直接赋值
-	数字转换为字符串速度最快的是	num+''--->string 
-	parseInt()是用于将字符串转换成数字
##	rmf算法
-	从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程
	思想。
-	构成递归需具备的条件：
	子问题须与原始问题为同样的事，且更为简单；
	不能无限制地调用本身，须有个出口，化简为非递归状况处理。
-	递归与普通循环的区别是：循环是有去无回，而递归则是有去有回	它不是一次性完成的，是通过不断重复的，但每次重复又比之前更好一点，
	这样一种非线性的进程。
-	在循环的次数较大的时候，迭代的效率明显高于递归。
-	迭代是一种线性的进程。
-	递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。
-	迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。
-	迭代可以转换为递归，但递归不一定能转换为迭代。
##	rmf笔试
-	parent不是js的保留字
-	保留关键字不可以用作变量、标签或者函数名。有些保留关键字是作为 Javascript 以后扩展使用。
-	[] == ![]		-->true
-	null == undefined   -->true
-	null === undefined   -->false
-	null instanceof Object	-->false		null可以理解是原始数据类型  但是不属于object
-	typeof null			-->object		
-	foo对象有att属性	获取att属性的值		foo.att 		foo['att'] 
-	js全局函数		String()  Number()	eval()	encodeURIComponent()	decodeURIComponent()	isNaN()
-	isNaN() 函数用来确定一个值是否为NaN 
-	isFinite()	检查某个值是否为有穷大的数。
-	parseFloat()	解析一个字符串并返回一个浮点数。
-	parseInt()	解析一个字符串并返回一个整数。
-	全局函数与内置对象的属性或方法不是一个概念。全局函数它不属于任何一个内置对象
-	label标签的for属性和input框的id属性相互绑定	那么最后就是点击lable的时候	实际点击的是input标签
-	label元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内
	点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。
-	input框设置display:none		但是lable标签里面的文本还是显示的  点击label标签里面的文本相当于点击了input框  那么就触发了 点
	击事件		label的for属性和input框的id属性的配合		方便了元素样式在出现和消失样式的设置	类似事件委托
-	null === null -->true
-	null == 0 -->false
-	[] == [] --》false
-	typeof NaN	-->number
-	typeof null -->object
-	null == object	-->false
-	[] == false   0   '' -->true
-	false == ''    '  '   0		-->true
-	引用数据类型比较的是空间地址
-	对象==字符串 ： 对象转字符串，字符串比较
-	布尔==字符串 ： 布尔转数字，字符串转数字
-	Chrome默认最小字号是12px
-	content-length
-	Content-Length 是一个实体消息首部，用来指明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目。
-	是服务端告诉客户端body的大小有多大。
-	Http协议的请求报文和回复报文都有header和body，body就是你要获取的资源，例如一个html页面，一个jpeg图片，
	而header是用来做某些约定的。例如客户端与服务端商定一些传输格式，客户端先获取头部，得知一些格式信息，然后才开始读取body。
-	客户端： Accept-Encoding:gzip （给我压缩一下，我用的是流量，先下载下来我再慢慢解压吧）
	服务端1：Content-Encoding:null(没有Content-Encoding头。 我不给压缩，CPU没空，你爱要不要）
	服务端2：Content-Encoding:gzip (给你节省流量，压缩一下）
-	去除重复的字符str.replace(/(.)\1+/g,'$1')

##	rmfjs
-	JavaScript 可以通过不同的方式来输出数据：
	使用 window.alert() 弹出警告框。
	使用 document.write() 方法将内容写到 HTML 文档中。
	使用 innerHTML 写入到 HTML 元素。
	使用 console.log() 写入到浏览器的控制台。
-	JavaScript 对大小写是敏感的。
-	您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：
-	document.write("你好 \
	世界!");
-	你好世界
-	null undefined的理解
-	在 JavaScript 中, null 用于对象, undefined 用于变量，属性和方法
-	undefined表示一个变量没有被声明，或者被声明了但没有被赋值（未初始化），一个没有传入实参的形参变量的值为
	undefined，如果一个函数什么都不返回，则该函数默认返回undefined。null则表示“什么都没有”，即“空值”。
	Javascript将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的；
	undefined不是一个有效的JSON，而null是；
	null 和 undefined 的值相等，但类型不等：undefined的类型(typeof)是undefined；null的类型(typeof)是object。
-	在'null'上执行算术转换时，则值为0，
-	但是，“undefined”不执行任何此类转换	如果您尝试将“undefined”添加到数字中，您将获得NaN或Not-a-Number
-	Undefined 这个值表示变量不含有值。
	可以通过将变量的值设置为 null 来清空变量。
-	对象也是一个变量，但对象可以包含多个值（多个变量）
-	person["lastName"]		访问对象属性的一种方式
-	value = person.fullName();
-	value为函数的返回值
-	value = person.fullName;
-	value为函数的内容
-	因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。
	局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。
-	局部变量在函数执行完毕后销毁。
	全局变量在页面关闭后销毁。
-	var lastname="Doe",
		age=30,
		job="carpenter";
-	数据声明定义的常用格式
-	JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型：
-	var x;               // x 为 undefined
	var x = 5;           // 现在 x 为数字
	var x = "John";      // 现在 x 为字符串
-	toFixed()	把数字转换为字符串，结果的小数点后有指定位数的数字。会进行四舍五入
-	Number(" ")       // 返回 0
-	Number("99 88")   // 返回 NaN
-	+ 可用于将变量转换为数字：
-	var y = "5";      // y 是一个字符串
	var x = + y;      // x 是一个数字
-	如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字)
-	Boolean([])	-->true			Boolean({})	-->true
-	JavaScript 中的所有数据都是以 64 位浮点型数据(float) 来存储。
-	在 JavaScript 中, 对象 使用 名字作为索引。
-	person["age"] = 46;
-	在 JavaScript 中, 全局作用域是针对 JavaScript 环境。
	在 HTML 中, 全局作用域是针对 window 对象。
-	使用 var 关键字声明的全局作用域变量属于 window 对象
-	使用 let 关键字声明的全局作用域变量不属于 window 对象
-	在相同的作用域或块级作用域中，不能使用 let 关键字来重置 var 关键字声明的变量
-	使用 var 关键字声明的变量在任何地方都可以修改
-	在相同的作用域或块级作用域中，不能使用 let 关键字来重置 let 关键字声明的变量
-	在相同的作用域或块级作用域中，不能使用 var 关键字来重置 let 关键字声明的变量
-	