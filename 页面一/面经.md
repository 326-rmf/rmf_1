##  箭头函数

-    箭头函数没有prototype(原型)，所以**箭头函数本身没有this**
-    箭头函数的this在定义的时候继承自外层第一个普通函数的this。
-    如果箭头函数外层没有普通函数，严格模式和非严格模式下它的this都会指向window(全局对象)
-    箭头函数本身的this指向不能改变，但可以修改它要继承的对象的this。
-    箭头函数的this指向全局，使用arguments会报未声明的错误。
-    箭头函数的this指向普通函数时,它的argumens继承于该普通函数
-    使用new调用箭头函数会报错，因为**箭头函数没有constructor**
-    箭头函数不支持new.target
-    **箭头函数不支持重命名函数参数,普通函数的函数参数支持重命名**
-    箭头函数相对于普通函数语法更简洁优雅
-    箭头函数不能当做Generator函数,不能使用yield关键字(python)
-    箭头函数不能绑定arguments，取而代之用rest … 参数
    -   let C = (...c) => {
            console.log(c);
            }

##  宏任务和微任务

-   ”JS是单线程的”指的是JS 引擎线程。
-   在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。
    Node环境中，只有JS 线程。
-   当开始执行 JS 代码时，首先会执行一个 main 函数，然后执行我们的代码。

-   Event Loop
-   **JS引擎常驻于内存中，等待宿主将JS代码或函数传递给它**。
    也就是等待宿主环境分配宏观任务，反复等待 - 执行即为事件循环
    Event Loop中，每一次循环称为tick，每一次tick的任务如下：
    执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；
    检查是否存在微任务，有则会执行至微任务队列为空；
    如果宿主为浏览器，可能会渲染页面；
    开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。

-   在ES3以及以前的版本中，JavaScript本身没有发起异步请求的能力，也就没有微任务的存在。在ES5之后，JavaScript引入了Promise,
    不需要浏览器，JavaScript引擎自身也能够发起异步任务了。

-   ES6 规范中，microtask 称为 jobs，macrotask 称为 task
    宏任务是由宿主（Node、浏览器）发起的，而微任务由JavaScript自身发起。

-   宏任务
    -   1. script (可以理解为外层同步代码)
        2. setTimeout/setInterval
        3. UI rendering/UI事件
        4. postMessage，MessageChannel
        5. setImmediate，I/O（Node.js）

-   微任务
    -   1. Promise
        2. MutaionObserver
        3. Object.observe（已废弃；Proxy 对象替代）
        4. process.nextTick（Node.js）

-   async和await是如何处理异步任务的
    -   async是通过Promise包装异步任务。
    -   async function async1() {
            await async2()
            console.log('async1 end')
            }
            async function async2() {
            console.log('async2 end')
            }
            async1()
    -   当调用 async1 函数时，会马上输出 async2 end，并且函数返回一个 Promise，接下来在遇到 **await的时候会就让出线程**开始执行 
        async1 外的代码（可以把 await 看成是让出线程的标志）。

-   Node.js是运行在服务端的js，虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一
    些I/O，比如新的网络连接等，所以与浏览器Event Loop不太一样。
-   Node里面对setTimeout的特殊处理：setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)。

-   Promise，process.nextTick谁先执行？
-   process.nextTick() 是一个特殊的异步API，其不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进
    行，会马上停下来执行process.nextTick()，这个执行完后才会继续Event Loop。
-   nextTick和Promise同时出现时，肯定是nextTick先执行，原因是nextTick的队列比Promise队列优先级更高。

##  取反运算符（补码全部位置取反  包括符号位）

-   ~正数补码
    -  取反变为负数 被认为是负数的补码
    -   负数补码还原回源码的样式输出
-   ~负数补码
-   ~x = -(x+1)
    -   对原来数据取反减去1
-   可以用来取整    去除小数位数
    -   ~~x
##  flex布局        (容器和项目对应)

    它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

-   容器

    flex-direction  **属性决定主轴的方向（即项目的排列方向）**
        row（默认值）：主轴为水平方向，起点在左端。
        row-reverse：主轴为水平方向，起点在右端。
        column：主轴为垂直方向，起点在上沿。
        column-reverse：主轴为垂直方向，起点在下沿

    flex-wrap   **属性定义，如果一条轴线排不下，如何换行。**
        nowrap（默认）：不换行。
        wrap：换行，第一行在上方。
        wrap-reverse：换行，第一行在下方。

    **flex-flow**属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap

    justify-content 属性定义了**项目在主轴上的对齐方式。**
        flex-start（默认值）：左对齐
        flex-end：右对齐
        center： 居中
        space-between：两端对齐，项目之间的间隔都相等。
        space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

    align-items 属性定义**项目在交叉轴上如何对齐**
        flex-start：交叉轴的起点对齐。
        flex-end：交叉轴的终点对齐。
        center：交叉轴的中点对齐。
        baseline: 项目的第一行文字的基线对齐。
        stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

    align-content   属性定义了**多根轴线的对齐方式**。如果项目只有一根轴线，该属性不起作用。
        flex-start：与交叉轴的起点对齐。
        flex-end：与交叉轴的终点对齐。
        center：与交叉轴的中点对齐。
        space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
        space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
        stretch（默认值）：轴线占满整个交叉轴。

-   项目

    order属性定义项目的**排列顺序**。数值越小，排列越靠前，默认为0。
    flex-grow属性定义**项目的放大比例**，默认为0，即如果存在剩余空间，也不放大
    flex-shrink属性定义了**项目的缩小比例**，默认为1，即如果空间不足，该项目将缩小。
    flex-basis属性定义了在分配多余空间之前，**项目占据的主轴空间**（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
    **flex属性是flex-grow, flex-shrink 和 flex-basis**的简写，默认值为0 1 auto
    align-self属性允许**单个项目有与其他项目不一样的对齐方式**，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
-   flex总结
    -   容器
        -   flex-flow:row               nowrap;
                        ^                   ^
                    项目排列            项目换不换行
        -   justify-content     -->     项目**主轴**怎么对齐（center(居中)flex-start(项目靠左对齐)space-between(居中等间距))
        -   align-items         -->      项目**交叉轴**怎么对齐 (center(居中对齐)baseline(项目第一行文字的基线对齐))
        -   align-content   -->     多根轴线的对齐方式(flex-start(交叉轴起点对齐))

##  meta标签设置网页的元数据   一般用来告诉浏览器如何解析网页
							--》name设置属性的名字
							-->content设置属性的内容
							--》description用于告诉搜索引擎网页的主要内容
##  p标签不放任何块元素
##  ##	base64 用来将图片转换为字符串   直接在页面加载时候就可以用   提升速度	不可读	
##  iframe  src  引入外部网页   iframe不会被爬虫解析

##  选择器
##  span + p{}兄弟元素
        span ~ p{}选择后面的所有p兄弟元素
        div>p+tab //就生成了div 里面有个 p
##  +  {1,}   x + y{}同级别的兄弟       x ~ y{}x后面的兄弟
##  div p:first-child{}//div的第一个子元素必须并且是p 才成立 
    div p:first-of-type{}//div的p类型中的第一个
##  属性选择器   [title]{}//有title 这个属性的 时候就执行内容
        [title='hello']{}//title为hello
        [title^='h']{}//title以h开头
-   内联1000>id100>类和伪类10>元素1
##  visibility:hidden;			-->不显示元素但是占领位置
    但是 		display		-->不显示元素且不占领位置
##  <a>里面什么都可以放</a>
##  box-shadow-->设置阴影		和轮廓一样		就是加上一个特效
    box-shadow:（inset）20px 20px 10px #ffe;-->第一个值正值向右移动
                                    --》第二个值正值向下移动
                                    --》第三个值越大阴影就越模糊
                                    --》inset  表示内部阴影  	默认外部阴影
                                    --》可以设置多重阴影
##  脱离文档流的元素全是块元素

##  BFC是元素的一个隐藏属性		一旦元素开了BFC他将会开启一个独立的布局区域
-   设置元素浮动可以开启BFC
    CLEAR   来清除浮动元素的影响
    .clearfix::before,
    .clearfix::after{
        content:'';
        display:table;
        clear:both;
    }			
##  z-index:1..   父元素层级再高不会盖住子元素
##  opacity:		-->用来设置元素的不透明度
##  元素设置了		absolute，那么margin:0 auto;就不管用了 	除非设置的时候left top right bottom 设置为0   	
    margin:auto;-->就会水平居中
-   **元素设置了定位** 		那么就多了left bottom right top 这几个值
    -   元素定位之后   多了left		right
				-->记住left:0;right:0;
				-->margin:0 auto;-->这样才会居中

-   position  	默认值是static 	表示没有开启定位
-   text-align:-->left		左对齐
                -->right		右对齐
                -->center
                -->justify		文本两端对齐
    vertical-align-->baseline		沿基线对齐
                    --》sub		下标
                    --》super	上标
                    --》bottom	沿父元素底部对齐
                    --> top		沿父元素顶部对齐
                    --》middle	相对于小写子母的middle对齐
##  min-width 	max-width		最小宽度		最大宽度
    --》浏览器缩小放大的时候不改变框的大小
##  line-through		文本删除线
    over-line 		上划线
##  CSS Sprite(CSS精灵),雪碧图
                -->有效降低了发送请求的速度，提升用户的体验，降低图片的总大小
                -->降低加载的速度
                -->只适用于背景图片background-image
##  第一次刷新的时候为什么会闪烁呢
                因为图片这些外部资源只会在页面在加载之后，有页面请求的时候在来加载
                图片需要使用的时候才来加载就会闪烁这种叫做懒加载
##  小三角
    .div_9{
    width: 0;
    height: 0;
    border: 10px solid black;
    border-color: transparent transparent black transparent;
    }
##  transition:all 4s 1s;		-->第一个值是执行动画的属性
        -->第二个值执行动画的时间
        -->第三个值要延迟多久才来执行动画
-   transition实现了过渡效果		交互效果		类似动画效果但不是动画

##  ico文件就是web网站标签的图标
##  transform:translateX();		-->沿着x轴方向平移
				translateY()	-->沿着y轴方向平移
				translateZ()	-->沿着z轴方向平移	元素距离用户的距离
##  perspective		-->视距  设置人的眼睛和网页之间的距离	让视觉有3D效果
-   perspective:100px;-->不宜过小
    transform-style: preserve-3d;		-->**添加3D效果**
    perspective: 800px;                 --》眼屏距离
##  npm可以下载和上传
    **cnpm只可以下载**
##  darken()函数用来加深颜色
    background-color:darken(yellow,20%);	-->加深了黄色


##  less
-   @a:10px;
    .box1{
        width:@a;
        height:10px;
        .box2{}
    }	
-   .box1{
	width:160px;
	height:$width;
    }
            -->使用$符号来直接引用其他的值
            -->使用变量的时候就近原则
-   .box2{
	.box1();
        }								-->box2里面来使用box1的样式*
-   .hello(@a,@b){
	width:@a;
	height@b;
	background-color:#f00;
    }			--->简化了开发 		要引入的时候就引入
    -   .wrapper{
            .hello(300px,500px);	}	
                    -->简化了开发		减少了代码量
-   @import "demo02";		-->将外部的less文件来导入当前less文件

##  var age;		-->undefined		-->定义变量未赋值	-->里面存的就是undefined
-   null		-->空类型		var obj = null;-->一般定义对象的时候来使用	用于对象初始化或者删除一个对象的时候来使用
-   !==			--->不全等于
-   num+1		-->是一个表达式 
-   Number();			-->强转类型函数		若字符串看起来不是一个数字	那么转换为NaN		而不是数字		true->1		
    false->0        undefined-->NaN
-   parseInt(a)		-->提取整数		--》a="123adf"-->a==123
								-->a="asf123"-->a==NaN
-   1/0			--》infinity	-->无穷大
##  栈结构			--》先进后出	有序的	栈底	栈顶	栈是独享的
    堆结构			--》随意增删		堆是共享的
##  预解析只会解析带var的变量,不带var的,不进行预解析
-   预解析优先级		
			--》先去解析函数	函数如果有同名会发生覆盖
			-->再去解析var变量
-   匿名函数	不会发生预解析
##  Object是原型对象的原型对象
    对象找属性的过程形象地成为原型链
##  一般我们等待页面加载完成后		--》才去操作dom元素
-   window.onload		-->页面加载完成事件
##	textContent		innerText	的区别
    textContent	可以获取隐藏元素的文本		包括换行和空白**visible:hidden	的元素可见**
    innerText		不可获取隐藏元素的文本
##  keyup		keydown		键盘抬起	键盘按下
    inputNode.onkeyup = function(event){}
    keyCode		键盘键码
##  document.body.appendChild(ulNode);

##  DOM0 DOM1 DOM2 DOM3
-   **dom0事件取消浏览器的默认行为**直接在函数里面return false;
-   **dom2事件取消默认行为**event.preventDefault();

**onmouseenter onmouseleave		如果是父子元素模型		当鼠标移入父元素的子元素的时候事件没有移出再移入		事件没有切换**
**onmouseover	onmouseout		如果是父子元素模型		鼠标移入父元素的子元素的时候事件会移出再移入		事件有切换**

##  location		window.location		页面地址
    window.location.href		重定向地址

##  clientX	clientY             相对于**视口**左上角的位置
-    offsetX	offsetY         相对于**元素**左上角的位置
     pageX 		pageY           相对于整个页面左上角的位置	带上**滚动条滚动**的距离
     screenX	screenY         相对于**屏幕**左上角的位置

##  针对的是元素
    offsetWidth	-->拿的是盒子	        content  	padding border
    clientWidth	-->盒子                 content	    padding
    scrollwidth	-->内容比盒子小的时候	拿的是clientWidth
                -->内容大于盒子的时候	拿的是OffsetWidth加上盒子一侧的内边距
    clientLeft	    clientTop		拿到盒子边框的大小
    offsetLeft		offsetTop		拿到盒子的水平偏移量和垂直偏移量
    scrollLeft		scrollTop		拿到滚动条滚动的距离

## 视口宽高求法
    document.documentElement.clientWidth
    document.documentElement.clientHeight
##  系统滚动条有两个		body和document
    body 或者 html单独设置overflow:scroll	滚动条打开的全是document的
    body 和 html 都设置overflow:scroll	那么Html打开document身上的滚动条		body打开自己身上的滚动条
    禁止系统滚动条
##  __proto__   -->  prototype
## 	变量提升	函数提升
1.	js引擎正式执行代码之前	会预解析
2.	找var function
-	**全局的预解析在定义函数的时候不关心函数是否被使用**
-	**函数局部预解析的时候如果内部函数没有被使用就不会提前定义**
-  	执行上下文栈
	执行上下文式动态创建的	针对函数	函数每调用一次就创建一次执行上下文		执行完就销毁	
-   作用域
    只有全局作用域	函数作用域		**没有对象作用域**


#	闭包
-	闭包就是一个引用关系	引用关系存在于内部函数中	引用的是外部函数的变量的对象 
##	如何产生闭包
-	函数嵌套
-	内部函数引用外部函数的局部变量
-	使用内部函数
##	闭包的作用
-	延迟外部函数变量对象的生命周期(既是优点也是缺点)
	(占内存，如果不及时清除容易造成内存溢出，泄露)	那么使用完闭包之后就应该快速清除释放设置为null
-	让函数外部可以间接操作到函数内部的数据
##  console.log(1,console.log(2));-->2 1 undefined
-	**console.log()是一个函数 没有返回值**
##  #	工厂函数模式
-   	工厂函数
    function person(name,age){
        return{
            name:name,
            age:age
        }
    }
    -	构造函数
    function Person(name,age){
        this.name = name;
        this.age = age;
    }
##  Person.call(this,name,age)
-    Child  复用	Person的代码
##  进程 线程
-	进程是程序的一次执行，占有一定的内存空间	是程序**分配**和执行管理资源的基本单位	是计算机资源的基本单位
-	线程是CPU的基本**调度**单位	多个进程之间的数据是不可共享的	是进程的一部分
##  钩子函数就是回调函数	轮询机制
-   当主线程上所有的同步任务执行完毕会通过轮询机制来询问callback queue是否有可执行的回调函数	
-   setTimeout后面**不要写运算量大的代码**	定时器是非阻塞的 会继续询问后面的可执行代码	耽误定时器执行	导致不准时
-   **定时器不准时因为js是单线程的**
##  webworker
    worker.prototype.onmessage	用于接收另一个线程的回调函数
    worker.prototype.postmessage	向另一个线程发送信息


## 	ES5的扩展的静态方法		
-   **Object.create()**
    --》指定地去创建一个新的对象。并指定原型对象
    var obj2 = Object.create(obj);指定obj为obj2的隐式原型对象_proto_
    当然还可以添加obj2的新属性
    var obj2 = Object.create(obj,{
        sex:{value:'nan',
        `writable:true`//**属性可以修改**},
        age:{value:43}
    });
    `writable:true`//**标识属性可以修改**
    `configurable`-->**标识属性可以被删除true**
    `enumerable`-->**标识属性可以用for in俩枚举**
-    **Object.defineProperies	**配置对象****
-	get方法的作用	提供**扩展属性的值**
-   set方法在修改扩展属性的时候会自动调用	用来**监视扩展属性**	不可在set方法当中修改扩展属性	否则出现死循环	可以借助第三方变量来修改
-   添加的key必须是字符串	**加上引号''**
    var obj = {
        name:'kobe',
        age:42
    }
    Object.defineProperties(obj,{//配置对象
        sex:{get:function(){
            console.log('get()');
            return '男';
        },
        set:function(msg){
            console.log('set()',msg);//set有引号
        }}
    })
-	**obj2数据复制到obj3里面**
var obj2 = {name:'kobe',age:42}
var obj3={};
for(var item in obj2){//in来遍历对象
	if(obj2.hasOwnProperty(item)){
		console.log(item,':',abj2[item]);
		(function(item){
		Object.defineProperties(obj3,{
			[item]:{
				get:function(){//获取
					return obj2[item];
				},
				set:function(msg){//设置
					obj2[name] = msg;
				}
			}
		})
		})(item)
	}

##  Array
-	arr.forEach(function(item,index){})-->遍历数组  不改变原来数组      只有抛出异常才会中止    break不可中止   不返回数据
-	arr.map(function(item,index){})-->遍历数组返回加工后的数组      返回数据    
-	arr.filter(function(item,index){})-->返回符合条件的数组

##  let提升的变量在**没有赋值**之前那**不允许被使用**
-   a is not defined        **NG**
-   而var变量的是       可以使用不过是undefined
-   变量提升
	-	全局变量提升
		-	会创建一个**变量对象(script)**用来收集全局作用域下let定义的变量		但是没有赋值	不会成为window对象的属性	script是window的下级		因为压栈是不会平行去压栈的
	-	局部变量提升
		-	会将var let定义的变量全部放到当前函数的变量对象中
		-	但是**只有使用var关键字声明的变量才会被初始化undefined值**，而let和const声明的变量则不会被初始化值。
-   let的应用	**变量的解构赋值**	按需索取
    -   let obj2 = {username:'kobe',age:42};
        let {username,age} = obj2;
	-->**方便了变量的声明使用**--》全局来用	
## 	...运算符	可以打包	解包
-	用来取代arguments	比arguments更加灵活
##  Object.prototype.toString.call(target).slice(8,-1);
##	2D变换
-   transform:translate(200px) scale(0.5);//盒子平移200px 再缩放0.5倍
    transform: scale(0.5) translate(200px)//盒子先缩放0.5倍 再来平移100px
-   **scale在translate前面**   那么translate会随着scale的倍率来平移
##	响应式的好处 		写得好可以适配所有情况
	响应式的坏处		代码量大	维护成本高	
##  window.onkeydown=function(e){
	console.log(e.keyCode);
    }
##  document.querySelector('.search');
##  e.target当前元素的子元素	target属性
##  save()保存		restore()恢复在canvas画布里面很重要
##   清除画布很重要
      ctx.clearRect(0,0,1000,1000);
##  git是基于linux的
-   是一个微型的linux的虚拟机
-   git分为三个区域
-   工作区	暂存区	版本区
-  	git add xx.txt	添加指定文件到暂存区
-	git status	工作区状态	文件绿色代表在暂存区	红色在工作区
-	git reset --hard HEAD^	回到上一个版本
-	git reset --hard HEAD^^	回到上两个版本
-	git reset --head 版本号		回到指定的版本号
-	git checkout --x.txt	暂存区指定文件区替换工作区的指定文件
-	git rm -- cached x.txt  取消暂存区刚刚的提交文件
-	git rm x.txt	删除文件
-	git rm  -r xxx	删除文件夹
##  style标签是html解析器来异步解析的	那么就会有闪屏可能
-   link引入css样式就会避免闪屏	css解析器是同步的	就不会有闪屏
-   无论css js阻塞都不会阻塞外部资源的请求
-   defer的作用	defer紧随dom解析之后	使用之后可以知道dom解析什么时候解析完
##  前端优化
-	使用cdn节点进行外部资源加速
-	css进行压缩
-	减少http请求数	多个css文件进行合并
-	优化样式表代码
##	缓存机制
-	浏览器在本地磁盘上将用户之前请求的数据存储起来	用户再次改数据的时候无需再次发送请求	直接从浏览器本地获取数据
-	缓存的好处
	-	减少请求的个数
	-	节省带宽	减少浪费不必要的网络资源
	-	减轻服务器压力
	-	提高浏览器网页的加载速度	提高用户体验
-	缓存的分类	请求成功的资源状态码是200ok
	-	强缓存
		-	不会向服务器发送请求	直接从本地缓存中获取数据
	-	协商缓存
		-	向服务器发送请求	服务器根据请求头的资源判断是否命中协商缓存
		-	如果命中	则返回304状态码通知浏览器从缓存里读取资源
	-	强缓存和协商缓存的共同点
		-	都是从浏览器读取数据
	-	强缓存和协商缓存的不同点
		-	强缓存不会请求服务器
		-	协商缓存会请求服务器	根据服务器返回的信息决定是否使用缓存
-	强缓存里的header参数
	-	expires		指定具体日期强缓存到期
	-	cache-control:max-age=..(可以强缓存的时间)
	-	cache-control优先级高于expires
-	协商缓存
	-	Last-Modified上一次修改的时间是什么时候
	-	if-Modified-Since和Last-Modified一起控制协商缓存
	-	Etag解决了last-modified难解决的问题
	-	etag和if-none-match	一起解决协商缓存
		-	一些文件也许会周期性更改	但是内容并不会改变	
		-	某些文件修改频繁	一秒内修改n次
		-	某些服务器不能精确得到文件的最后修改时间
##  单线程处理不好cpu密集型任务
###	浏览器的js由哪几部分组成
-	BOM		window浏览器对象模型	很多的API(location,history)
-	DOM		document文档对象模型	很多的API(对DOM的增删改查)
-	ES规范		ES5	ES6	
###	node端的js由及部分组成
-	没有了BOM	因为服务器不需要	服务器没有浏览器对象	没有window
-	没有了DOM	没有浏览器窗口	就是没有document
-	几乎包含了所有的ES规范
-	没有了window 取而代之的式一个global的全局变量	node中禁止函数指向global		而是指向了一个空对象
##	node事件循环模型	有六个阶段	1.timers 2.pending callbacks	3.idle,prepare	4.poll	5.check	6.close callbacks
-	timers()	定时器阶段	计时	setTimeout	setInterval	执行定时器的回调
-	pending callbacks()	系统阶段	准备系统内置的东西
-	idle,prepare	准备阶段
-	poll	轮询阶段式核心	
	-	如果回调队列有待执行的回调	那么就去回调函数	同步执行	
	-	如果回调队列为空	
	-	如果有设置过setImmediate	进入下一个check阶段
	-	如果没有设置setImmediate	则停留 等待回调函数插入回调队列
	-	若定时器到点了	进入下一个check阶段		原因式为了走阶段	直到下一个阶段
-	check	专门用于执行setImmediate所设置的回调
-	close callbacks()	关闭回调阶段
-	process.nextTick()-----用于设置立即执行函数()---'人民币玩家'	在任意阶段都优先执行	但还是怕主线程
###	setImmediate设置立即执行函数		clearImmediate
-	**回调函数天生是要等其他忙完再执行的**	不是定时器
-	这里涉及到计时速度和轮询的速度关乎到定时器和setImmediate的先后顺序
-	**在主线程上加了代码	影响了轮询速度和定时器速度**	因为线程消耗的时间为定时器争取了时间		否则就只看轮询时间和计时开始时间	
###	process.nextTick()	是用来设置立即执行函数		process.nextTick高于定时器	是特殊的
##	commonJs是双端的js模块化规范	服务器端	浏览器端	只有commonjs是双端的
###	commonjs引入模块必须按顺序引入	服务器端比较敏感	干活有顺序
-	暴露模块
	-	module.exports = value;
	-	exports.xxx = value;
	-	export是es6里面的语法
	-	module1.js	对象
		-	module.exports = {data:..,test(){}}
	-	module2.js	函数
		-	exports.haha = function(){
		}
	-	module3.js	数组
		-	exports.perqi = [1,2,34,5,6];
	-	可以引入对象	函数	数组...
	-	创建了module1.js	modules2.js	module3.js来暴露对象	函数...
	-	app.js里面来引入module1.js....
		-	let module1 = require('./modules/module1');..
		-	let {data,test}=require('./modules/module1');
		-	引入的同时	进行解构赋值
		-	'./'必须写清楚	要加上
		-	let xx = ..来引入
		-	这里写了路径	就是说不是在node_modules里面去找	而是去自定义那里去找
		-	let a = require('uniq');//当然在npm i uniq之后这样来引入	默认去node_modules里去找
		-	uniq([1,2,3,45,6,7,12,23,45,12,34])
		-	这样写是字典排序并且去重1 12 2 23 3.. 
###		commonJs模块化内置的一个关系	module.exports ={} exports ={}		{}暴露出的对象	module.exports和exports以module.exports为主
##	不使用模块化的缺点
-	文件冲突
-	不便于维护
-	不便于按需加载
##	浏览器里面没有require	window.require
-	服务器	和	浏览器里运行js可能有天壤之别
-	浏览器不认识require		那么会用browserify
	-	npm i browserify -g			全局安装在c盘		4048表示权限不够	要以管理员身份打开9
	-	有些东西是不可全局安装的
	-	**browserify js/src/app.js -o js/dist/peiqi.js**	borwserify将A目录下的js翻译到了B目录		使得浏览器认识翻译后的js文件
#	ES6		相应的暴露方式对应各自的引入方式	es6可以混合暴露
-	暴露模块
	-	结构
	-	js
		-	src
			-	module1.js..
			-	app.js
	-	index.html
	-	分别暴露
	-	统一暴露
	-	默认暴露	优点写法简单	import uniq from 'uniq'
-	module1.js	分别暴露
	-	export let data = ''
		export funtion demo(){}..
-	module2.js	统一暴露
	-	let arr = []
		function demo2(){}
		function test2(){}
		export{demo2,test2}//统一暴露函数	精简版写法
		export{demo2 as h1,test2 as h2}		完整版写法
-	module3.js	默认暴露		只能暴露一次	只能写一次	否则报错
	-	export default {
		name:'',age:,speak(){}
	}
-	app.js	汇总modulexxxx.js的js文件
-	引入模块
	-	分别暴露的引入
	-	import {data,demo1,test1} from	'./module1'
	-	分别暴露引入的另一种方式	import * as haha from './module1'
	-	统一暴露的引入
	-	import {demo1,test1} from	'./module2'
	-	统一暴露引入的另一种方式	import * as haha from './module2'
	-	默认暴露的引入
	-	import module3 from './module3'
	-	默认暴露引入的另一种方式	import * as haha from './module3'	但是尽量不要用这种方式
	-	混合暴露	包含分别暴露	统一暴露	默认暴露
	-	再来引入	import {} from ''	import module from ''
	-	当然两种引入方式也可以一起用	import module,{} from''
	-	上面默认暴露的	应该写在最前面
##	浏览器不认识es6模块化语法	那么要用到 babel来翻译转换
-	babel是facebook的
-	babel可以把es6==》es5
-				jsx==>js	jsx必须闭合
##	cli:command line interface	命令行接口工具	babel的'经纪人'
-	npm i babel-cli -g	**babel体积大**
-	npm install babel-preset-es2015	--save-dev
-	创建.babelrc文件	rc = run control	运行控制	在包里直接创建这个运行时控制文件
-	babel在干完		babel xxx.js -d xx.js
-	只是转换后的js文件可能是commonjs模块规范的 	那么就还要操作
-	browserify xx.js -o xx.js	这样才能转换成功	浏览器才认识
#	AMD-RequireJS
-	结构
	-	js
		-	lib//放一些第三方的库
		-	modules
		-	定义没有依赖的模块
-	定义没有依赖的模块
-	define(function(){
	//数据只读
	let data = 'atguigu'
	function getDataL(){
		return data.toLowerCase()
	}
	return {getDataL};
})
-	定义一个有依赖的模块
-	define(['module1'],function(module1){
	let msg = '',
	function getDataAndMsg(){}
	return getDataAndMsg
})
-	app.js里面来设置requirejs
	-	requirejs.config({

	})
-	AMD模块化中	也要用特殊的引入方式	移入require.js
-	AMD模块化用jquery	不用jQuery
-	baseUrl:''	//开始的根目录就是index.html所在的目录
-	404请求资源未定位
#	CMD模块化
-	module1.js
	-	define(function(require,exports,module){})
-	module2.js
	-	define(function(){})
-	module3.js
	-	define(function(){
		//引入module2	同步引入
		let module2 = require('./module2')
		//异步引入
		require.async('./module1',function(m3){})
		module.exports = {}
	})
-	汇总js配置	main.js
	-	define(function(require){
		let module1 = require('./module1')..
	})
-	index.html里面来引入sea.js
-	`<script>seajs.use(./../main)</script>`
##	buffer缓冲器
-	buffer是和数组类似的对象		不同的是buffer是专门来保存二进制数据的
-	buffer大小一旦确定就不可修改
-	buffer效率很高	存储和读取很快	直接对计算机的内存进行操作
-	每个元素占用内存的大小为1字节		就是8bit
-	buffer是node 的核心模块	无需下载
##	node里面的文件操作
-	**简单文件写入(异步文件写入)**
-	fs是node的核心模块	无需下载 但是要引入
-	let fs = require('fs')//引入内置的fs
-	fs.writeFile('路径','写的内容',{mode:0o444},(err)=>{
	if(err){

	}else{

	}
})//调用writeFile方法
-	sync是同步的		async是异步的
	-	fs.writeFile(file,data[,options],callback)
	-	file是要写入的文件路径
	-	data要输入的数据
	-	options	可选参数
		-	encoding	设置文件的编码方式	默认似乎utf-8
		-	mode	设置文件的操作权限
					默认值是0o666=0o222+0o444
					0o111是文件可被执行的权限
					0o222文件可被写入的权限
					0o444文件可被读取的权限	mode:0o444
		-	flag	打开文件要执行的操作	默认值是'w'
			-	w写入
			-	a追加		flag:'a'
	-	callback	回调函数
	-	err	错误对象
##  关系型数据库只能使用硬盘
###	如何判断对象是否为空对象
-	JSON.stringify(errMsg !== '{}')//true为不是空对象
##	分类
-	会话cookie	关闭浏览器	会话cookie会自动消失	存在内存里
-	持久化cookie	有有效期	到期自动销毁	存储在用户的硬盘上
##	工作原理
-	cookie是服务器给浏览器的	服务器拿到cookie	分析里面的内容	校验cookie的合法性	根据cookie内容	进行具体的业务逻辑
##	应用
-	解析http无状态问题	7天免登录
-	cookie不一定只由服务器生成	前端同样可以生成cookie但是毫无意义 
##	cookie   当前讲的是基于node 下的express
-	给客户端种cookie不需要任何的库
	res.cookie('mignzi',JSON.stringify(obj))//会话cookie
	res.cookie('ming','hello',{maxAge:1000*30})//持久化30秒的cookie	到点会自动销毁
-	let cookieParser = require('cookie-parser')//是一个中间件
	app.use(cookieParser)
	req.cookies
	res.clearCookie('cookieName')//清除cookie
-	浏览器模板引擎
##	cookie和session配合
-	session会话存储是存储在服务器内存里面的	避免服务器断电影响	那么就要做session持久化
#	session
-	session就是会话
	-	前端通过浏览器去查看cookie时候	会看到cookie的过期时间是session	
	-	后端人那员通常把session会话存储		简称为session存储
-	特点
	-	存储在服务端
	-	存储的是浏览器和服务器之间沟通产生的一些信息
-	工作流程
	-	第一次浏览器请求服务器	服务器开辟内存空间	供session会话存储
	-	返回响应的时候	自动返回一个cookie	
	-	以后请求的时候	会自动携带这个cookie	给服务器
	-	服务器从cookie中拿到对应的session的id	去服务器中匹配
	-	服务器匹配信息	决定下一步逻辑
##	令牌盗取	就是	cookie被他人盗取
#	AJAX就是JS和XML
-	无刷新获取数据	纯数据
-	是一种使用现有标准的新方法
##	XML可扩展标记语言
-	被设计用来传输和存储数据
-	AJAX工作原理是相当于用户和服务器之间加了一个中间层(AJAX引擎)使得用户操作和服务器响应异步化
##	AJAX的缺点
-	没有浏览历史	不可以回退
-	存在跨域问题	用代理解决跨域问题
-	SEO不友好	搜索引擎优化
###	post请求注意加上有一句
-	xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')//设置特殊的请求头
-	用于解析post请求请求体参数	参数的编码类型是
-	Content-Type 标头告诉客户端实际返回的内容的内容类型。
-	app.use(express.urlencoded({extend:true}))
-	ie发送get请求问题就是会总是走缓存	那么就要用欺骗Date.now()		来每次都是不同的字符串
-	res.send(123)不可以只返回数字	要数字.toString()
##	跨域	ajax请求可以发送	但是不可以获取数据	
-	跨域对服务器没有影响	对浏览器有影响
-	浏览器为了安全	而采用同源策略
##	同源策略是一个安全策略		netspace网景公司提出
-	web是构建在同源策略之上的
-	所谓同源	也称为同域	是指协议	域名	端口都要相同
###	非同源受到哪些限制
-	cookie不可以读取
-	dom无法获得
-	ajax请求不可获取数据
###	form表单跨域不会被拦截
-	ajax发的请求------ajax引擎-------听从同源策略
-	form发请求--------浏览器其他模块------不听从同源策略
#	promise
-	promise抽象表达:
-	promise是一门新的技术	ES6规范
-	promise是js中进行异步编程的新解决方案
-	promise具体表达:
-	promise是一个构造函数
-	promise对象用来封装一个异步操作并且可以获取成功和失败的结果值
###	promise初始状态是pending 表示是初始的	未确认的
-	var promise1 = new Promise(function(resolve,reject){
	//excutor执行器函数	同步回调函数
	console.log('excutor()')
	setTimeout(function(){
		resolve('foo')
	},1000)
})//promise封装了一个定时器的异步操作
promise1.then(function(value){//异步执行成功的回调函数
	console.log(value)
})
###	使用promise封装异步ajax请求
-	function myAsyncFunction(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest()
		xhr.open('GET',url)
		xhr.onload = () => resolve(JSON.parse(xhr.responseText))//成功回调
		xhr.onerror = () => reject(xhr.statusText)//出错的回调
		xhr.send()
	})
}
**自己写promise封装**
	function promiseAjax(url){
	return new Promise((resolve,reject)=>{
		const xhr = new XMLHttpRequest()
		xhr.open('GET',url)
		xhr.send()
		xhr.onreadystatechange = () => {
			if(xhr.readyState!==4)return
			if(xhr.status >= 200 && xhr.status < 300){
				resolve(JSON.parse(xhr.response))//resolve交出正确数据
			}else{
				reject(new Error('request error status:'+xhr.status))//交出错误数据
			}
		}
	})
}
	promiseAjax('url')
	.then(
		data => {
			console.log('yes',data)//正确数据的输出
		},
		error => {
			alert(error.message)//错误数据的输出
		}
	)
**async/await	解决回调地狱的终极解决方案	更加精简**
-	async function request(){
	try{
		const result = await doSimething()
		const newResult = await doSomethingElse(result)
		const finalResult = await doThirdThing(newResult)
		console.log('Got the final result:' + finaResult)
	}catch(error){
		failureCallback(error)
	}
}
###	改变promise状态(resolve reject)和指定回调函数(.then .catch)谁先谁后	常规是先指定回调函数	指定不是执行	后来改变状态
-   状态改变一次之后不会再改变了    状态只改变一次  分先后顺序
-   没有定时器的时候	就是先改变状态	后指定回调函数
-   先是回调    还是状态    看定时器的时间设定  短的优先
-   fn (){}//在类里面放在原型对象上面
-	fn = () => {}//放在实例对象上面
##	async和await作用
-	简化promise对象的使用	不要通过then指定回调函数去结果数据
-	是回调地狱的终极解决方案
##  宏队列和微队列
-	宏队列
	-	dom事件回调
	-	ajax回调
	-	定时器回调
-	微队列
	-	promise回调
	-	mutation()回调
##  await在console.log()之前执行
async function async1(){
	console.log('async start')
	await async2()//相当于.then 函数来执行  
	console.log('async end')//放进微队列
}
###	AJAX请求和http请求的关系	AJAX请求是特殊的http请求
-	AJAX请求获取数据	不需要整个页面的刷新
-	只有XHR或者fetch发出的才是ajax请求	其他所有的都是非ajax请求
###	浏览器端收到响应
-	一般请求	浏览器会直接显示响应体数据	也就是刷新/跳转页面
-	ajax请求	浏览器不会对界面进行任何更新操作	只是调用监视的回调函数并传入响应相关数据
###	axios处理链流程
-	添加请求拦截器	在发请求之前执行
-	作用
	-	对请求的配置做一些处理	data header 
	-	对请求进行检查	不满足就不发请求
-	axios.interceptors.request.use(function (config) {
	console.log('req interceptor onResolved()')
	return config//必须返回config
})
-	**后面的请求拦截器会先console.log**
-	添加响应拦截器	得到响应后执行的回调函数
-	作用
	-	对请求成功的数据
	-	对请求失败的数据
-	axios.interceptors.response.use(
	function(response){
		console.log('res interceptor1 onResolved()')
		return response;
	},
)
#	webpack	模块打包器(构建工具)	遵循CommonJS规范的文件
-	webpack看来	前端所有资源文件作为**模块处理**
-	webpack不支持三点运算符的解析
##	五个核心概念
-	Entry	入口起点	指示webpack应该使用哪个模块	作为构建内部依赖图开始
-	Output	告诉webpack再哪里输出它所创建的bundles	以及如何命名这些文件	默认值是./dist
-	Loader	本身是运行在node.js里的js模块 让webpack能够去处理那些非js文件		webpack自身只能解析js json
-	Pulgins	插件可以用于执行范围更广的任务	打包优化和压缩	定义环境中的变量等
-	Mode	生产模式production和开发模式development
-	优点:
-	webpack可以编译打包js和json文件
-	可以将es6的模块化语法转换为浏览器可识别的语法
-	可以压缩代码
-	缺点:
-	不可编译打包css img等文件
-	不可将js的es6基本语法转化为es5以下的语法
##	打包样式文件中的图片资源
-	npm i file-loader url-loader -D
-	import img from './image.png'
-	图片编码格式base64
-	图片<8kb	转为base64		图片>8kb	不转为base64
-	file-loader和url-loader是一对兄弟
-	用的时候url-loader是对file-loader的上层封装
-	那么使用的时候都要安装
#	自动编译打包运行	webpack-dev-server
-	安装loader
-	npm i webpack-dev-server -D
-	自带了自动刷新效果	但是是整个页面刷新
-	那么避免页面复杂的时候	耗资源	
-	**那么用到了局部刷新	叫做热模替换HMR	是webpack提供的最有用功能**
-	不会在本地生成打包文件		只会在内存里面生成
	那么在devServer里面加上hot:true就实现了局部刷新
-	**html不支持热模替换	css支持**
-	npx webpack --watch	//内部启动服务器来监视文件的变化 但是	不会自动刷新浏览器	热模替换	代理	
##	消息订阅和发布机制	
	-	适用于任意组件之间通信
	-	缺点是乱像菜市场	没有集中式管理
##	VM是ViewModel	模板视图	
	-	完成了Data Bingdings	数据绑定
	-	DOM Listeners			DOM监听
##  -	(function(){})()//这是立即执行函数表达式
##	for in 可以遍历到myObject的原型方法method